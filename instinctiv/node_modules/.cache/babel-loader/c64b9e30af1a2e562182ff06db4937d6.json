{"ast":null,"code":"/*\n Highstock JS v7.0.3 (2019-02-06)\n\n (c) 2009-2018 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n(function (Q, H) {\n  \"object\" === typeof module && module.exports ? (H[\"default\"] = H, module.exports = Q.document ? H(Q) : H) : \"function\" === typeof define && define.amd ? define(function () {\n    return H(Q);\n  }) : Q.Highcharts = H(Q);\n})(\"undefined\" !== typeof window ? window : this, function (Q) {\n  var H = function () {\n    var a = \"undefined\" === typeof Q ? \"undefined\" !== typeof window ? window : {} : Q,\n        B = a.document,\n        A = a.navigator && a.navigator.userAgent || \"\",\n        G = B && B.createElementNS && !!B.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\").createSVGRect,\n        m = /(edge|msie|trident)/i.test(A) && !a.opera,\n        g = -1 !== A.indexOf(\"Firefox\"),\n        t = -1 !== A.indexOf(\"Chrome\"),\n        u = g && 4 > parseInt(A.split(\"Firefox/\")[1], 10);\n    return a.Highcharts ? a.Highcharts.error(16, !0) : {\n      product: \"Highstock\",\n      version: \"7.0.3\",\n      deg2rad: 2 * Math.PI / 360,\n      doc: B,\n      hasBidiBug: u,\n      hasTouch: B && void 0 !== B.documentElement.ontouchstart,\n      isMS: m,\n      isWebKit: -1 !== A.indexOf(\"AppleWebKit\"),\n      isFirefox: g,\n      isChrome: t,\n      isSafari: !t && -1 !== A.indexOf(\"Safari\"),\n      isTouchDevice: /(Mobile|Android|Windows Phone)/.test(A),\n      SVG_NS: \"http://www.w3.org/2000/svg\",\n      chartCount: 0,\n      seriesTypes: {},\n      symbolSizes: {},\n      svg: G,\n      win: a,\n      marginNames: [\"plotTop\", \"marginRight\", \"marginBottom\", \"plotLeft\"],\n      noop: function noop() {},\n      charts: []\n    };\n  }();\n\n  (function (a) {\n    a.timers = [];\n    var B = a.charts,\n        A = a.doc,\n        G = a.win;\n\n    a.error = function (m, g, t) {\n      var u = a.isNumber(m) ? \"Highcharts error #\" + m + \": www.highcharts.com/errors/\" + m : m;\n      t && a.fireEvent(t, \"displayError\", {\n        code: m\n      });\n      if (g) throw Error(u);\n      G.console && console.log(u);\n    };\n\n    a.Fx = function (a, g, t) {\n      this.options = g;\n      this.elem = a;\n      this.prop = t;\n    };\n\n    a.Fx.prototype = {\n      dSetter: function dSetter() {\n        var a = this.paths[0],\n            g = this.paths[1],\n            t = [],\n            u = this.now,\n            v = a.length,\n            y;\n        if (1 === u) t = this.toD;else if (v === g.length && 1 > u) for (; v--;) {\n          y = parseFloat(a[v]), t[v] = isNaN(y) ? g[v] : u * parseFloat(g[v] - y) + y;\n        } else t = g;\n        this.elem.attr(\"d\", t, null, !0);\n      },\n      update: function update() {\n        var a = this.elem,\n            g = this.prop,\n            t = this.now,\n            u = this.options.step;\n        if (this[g + \"Setter\"]) this[g + \"Setter\"]();else a.attr ? a.element && a.attr(g, t, null, !0) : a.style[g] = t + this.unit;\n        u && u.call(a, t, this);\n      },\n      run: function run(m, g, t) {\n        var u = this,\n            v = u.options,\n            y = function y(a) {\n          return y.stopped ? !1 : u.step(a);\n        },\n            q = G.requestAnimationFrame || function (a) {\n          setTimeout(a, 13);\n        },\n            f = function f() {\n          for (var e = 0; e < a.timers.length; e++) {\n            a.timers[e]() || a.timers.splice(e--, 1);\n          }\n\n          a.timers.length && q(f);\n        };\n\n        m !== g || this.elem[\"forceAnimate:\" + this.prop] ? (this.startTime = +new Date(), this.start = m, this.end = g, this.unit = t, this.now = this.start, this.pos = 0, y.elem = this.elem, y.prop = this.prop, y() && 1 === a.timers.push(y) && q(f)) : (delete v.curAnim[this.prop], v.complete && 0 === Object.keys(v.curAnim).length && v.complete.call(this.elem));\n      },\n      step: function step(m) {\n        var g = +new Date(),\n            t,\n            u = this.options,\n            v = this.elem,\n            y = u.complete,\n            q = u.duration,\n            f = u.curAnim;\n        v.attr && !v.element ? m = !1 : m || g >= q + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), t = f[this.prop] = !0, a.objectEach(f, function (a) {\n          !0 !== a && (t = !1);\n        }), t && y && y.call(v), m = !1) : (this.pos = u.easing((g - this.startTime) / q), this.now = this.start + (this.end - this.start) * this.pos, this.update(), m = !0);\n        return m;\n      },\n      initPath: function initPath(m, g, t) {\n        function u(b) {\n          var a, c;\n\n          for (n = b.length; n--;) {\n            a = \"M\" === b[n] || \"L\" === b[n], c = /[a-zA-Z]/.test(b[n + 3]), a && c && b.splice(n + 1, 0, b[n + 1], b[n + 2], b[n + 1], b[n + 2]);\n          }\n        }\n\n        function v(a, l) {\n          for (; a.length < b;) {\n            a[0] = l[b - a.length];\n            var c = a.slice(0, r);\n            [].splice.apply(a, [0, 0].concat(c));\n            d && (c = a.slice(a.length - r), [].splice.apply(a, [a.length, 0].concat(c)), n--);\n          }\n\n          a[0] = \"M\";\n        }\n\n        function y(a, n) {\n          for (var c = (b - a.length) / r; 0 < c && c--;) {\n            l = a.slice().splice(a.length / w - r, r * w), l[0] = n[b - r - c * r], p && (l[r - 6] = l[r - 2], l[r - 5] = l[r - 1]), [].splice.apply(a, [a.length / w, 0].concat(l)), d && c--;\n          }\n        }\n\n        g = g || \"\";\n        var q,\n            f = m.startX,\n            e = m.endX,\n            p = -1 < g.indexOf(\"C\"),\n            r = p ? 7 : 3,\n            b,\n            l,\n            n;\n        g = g.split(\" \");\n        t = t.slice();\n        var d = m.isArea,\n            w = d ? 2 : 1,\n            E;\n        p && (u(g), u(t));\n\n        if (f && e) {\n          for (n = 0; n < f.length; n++) {\n            if (f[n] === e[0]) {\n              q = n;\n              break;\n            } else if (f[0] === e[e.length - f.length + n]) {\n              q = n;\n              E = !0;\n              break;\n            }\n          }\n\n          void 0 === q && (g = []);\n        }\n\n        g.length && a.isNumber(q) && (b = t.length + q * w * r, E ? (v(g, t), y(t, g)) : (v(t, g), y(g, t)));\n        return [g, t];\n      },\n      fillSetter: function fillSetter() {\n        a.Fx.prototype.strokeSetter.apply(this, arguments);\n      },\n      strokeSetter: function strokeSetter() {\n        this.elem.attr(this.prop, a.color(this.start).tweenTo(a.color(this.end), this.pos), null, !0);\n      }\n    };\n\n    a.merge = function () {\n      var m,\n          g = arguments,\n          t,\n          u = {},\n          v = function v(g, q) {\n        \"object\" !== typeof g && (g = {});\n        a.objectEach(q, function (f, e) {\n          !a.isObject(f, !0) || a.isClass(f) || a.isDOMElement(f) ? g[e] = q[e] : g[e] = v(g[e] || {}, f);\n        });\n        return g;\n      };\n\n      !0 === g[0] && (u = g[1], g = Array.prototype.slice.call(g, 2));\n      t = g.length;\n\n      for (m = 0; m < t; m++) {\n        u = v(u, g[m]);\n      }\n\n      return u;\n    };\n\n    a.pInt = function (a, g) {\n      return parseInt(a, g || 10);\n    };\n\n    a.isString = function (a) {\n      return \"string\" === typeof a;\n    };\n\n    a.isArray = function (a) {\n      a = Object.prototype.toString.call(a);\n      return \"[object Array]\" === a || \"[object Array Iterator]\" === a;\n    };\n\n    a.isObject = function (m, g) {\n      return !!m && \"object\" === typeof m && (!g || !a.isArray(m));\n    };\n\n    a.isDOMElement = function (m) {\n      return a.isObject(m) && \"number\" === typeof m.nodeType;\n    };\n\n    a.isClass = function (m) {\n      var g = m && m.constructor;\n      return !(!a.isObject(m, !0) || a.isDOMElement(m) || !g || !g.name || \"Object\" === g.name);\n    };\n\n    a.isNumber = function (a) {\n      return \"number\" === typeof a && !isNaN(a) && Infinity > a && -Infinity < a;\n    };\n\n    a.erase = function (a, g) {\n      for (var m = a.length; m--;) {\n        if (a[m] === g) {\n          a.splice(m, 1);\n          break;\n        }\n      }\n    };\n\n    a.defined = function (a) {\n      return void 0 !== a && null !== a;\n    };\n\n    a.attr = function (m, g, t) {\n      var u;\n      a.isString(g) ? a.defined(t) ? m.setAttribute(g, t) : m && m.getAttribute && ((u = m.getAttribute(g)) || \"class\" !== g || (u = m.getAttribute(g + \"Name\"))) : a.defined(g) && a.isObject(g) && a.objectEach(g, function (a, g) {\n        m.setAttribute(g, a);\n      });\n      return u;\n    };\n\n    a.splat = function (m) {\n      return a.isArray(m) ? m : [m];\n    };\n\n    a.syncTimeout = function (a, g, t) {\n      if (g) return setTimeout(a, g, t);\n      a.call(0, t);\n    };\n\n    a.clearTimeout = function (m) {\n      a.defined(m) && clearTimeout(m);\n    };\n\n    a.extend = function (a, g) {\n      var m;\n      a || (a = {});\n\n      for (m in g) {\n        a[m] = g[m];\n      }\n\n      return a;\n    };\n\n    a.pick = function () {\n      var a = arguments,\n          g,\n          t,\n          u = a.length;\n\n      for (g = 0; g < u; g++) {\n        if (t = a[g], void 0 !== t && null !== t) return t;\n      }\n    };\n\n    a.css = function (m, g) {\n      a.isMS && !a.svg && g && void 0 !== g.opacity && (g.filter = \"alpha(opacity\\x3d\" + 100 * g.opacity + \")\");\n      a.extend(m.style, g);\n    };\n\n    a.createElement = function (m, g, t, u, v) {\n      m = A.createElement(m);\n      var y = a.css;\n      g && a.extend(m, g);\n      v && y(m, {\n        padding: 0,\n        border: \"none\",\n        margin: 0\n      });\n      t && y(m, t);\n      u && u.appendChild(m);\n      return m;\n    };\n\n    a.extendClass = function (m, g) {\n      var t = function t() {};\n\n      t.prototype = new m();\n      a.extend(t.prototype, g);\n      return t;\n    };\n\n    a.pad = function (a, g, t) {\n      return Array((g || 2) + 1 - String(a).replace(\"-\", \"\").length).join(t || 0) + a;\n    };\n\n    a.relativeLength = function (a, g, t) {\n      return /%$/.test(a) ? g * parseFloat(a) / 100 + (t || 0) : parseFloat(a);\n    };\n\n    a.wrap = function (a, g, t) {\n      var m = a[g];\n\n      a[g] = function () {\n        var a = Array.prototype.slice.call(arguments),\n            g = arguments,\n            q = this;\n\n        q.proceed = function () {\n          m.apply(q, arguments.length ? arguments : g);\n        };\n\n        a.unshift(m);\n        a = t.apply(this, a);\n        q.proceed = null;\n        return a;\n      };\n    };\n\n    a.datePropsToTimestamps = function (m) {\n      a.objectEach(m, function (g, t) {\n        a.isObject(g) && \"function\" === typeof g.getTime ? m[t] = g.getTime() : (a.isObject(g) || a.isArray(g)) && a.datePropsToTimestamps(g);\n      });\n    };\n\n    a.formatSingle = function (m, g, t) {\n      var u = /\\.([0-9])/,\n          v = a.defaultOptions.lang;\n      /f$/.test(m) ? (t = (t = m.match(u)) ? t[1] : -1, null !== g && (g = a.numberFormat(g, t, v.decimalPoint, -1 < m.indexOf(\",\") ? v.thousandsSep : \"\"))) : g = (t || a.time).dateFormat(m, g);\n      return g;\n    };\n\n    a.format = function (m, g, t) {\n      for (var u = \"{\", v = !1, y, q, f, e, p = [], r; m;) {\n        u = m.indexOf(u);\n        if (-1 === u) break;\n        y = m.slice(0, u);\n\n        if (v) {\n          y = y.split(\":\");\n          q = y.shift().split(\".\");\n          e = q.length;\n          r = g;\n\n          for (f = 0; f < e; f++) {\n            r && (r = r[q[f]]);\n          }\n\n          y.length && (r = a.formatSingle(y.join(\":\"), r, t));\n          p.push(r);\n        } else p.push(y);\n\n        m = m.slice(u + 1);\n        u = (v = !v) ? \"}\" : \"{\";\n      }\n\n      p.push(m);\n      return p.join(\"\");\n    };\n\n    a.getMagnitude = function (a) {\n      return Math.pow(10, Math.floor(Math.log(a) / Math.LN10));\n    };\n\n    a.normalizeTickInterval = function (m, g, t, u, v) {\n      var y,\n          q = m;\n      t = a.pick(t, 1);\n      y = m / t;\n      g || (g = v ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === u && (1 === t ? g = g.filter(function (a) {\n        return 0 === a % 1;\n      }) : .1 >= t && (g = [1 / t])));\n\n      for (u = 0; u < g.length && !(q = g[u], v && q * t >= m || !v && y <= (g[u] + (g[u + 1] || g[u])) / 2); u++) {\n        ;\n      }\n\n      return q = a.correctFloat(q * t, -Math.round(Math.log(.001) / Math.LN10));\n    };\n\n    a.stableSort = function (a, g) {\n      var m = a.length,\n          u,\n          v;\n\n      for (v = 0; v < m; v++) {\n        a[v].safeI = v;\n      }\n\n      a.sort(function (a, q) {\n        u = g(a, q);\n        return 0 === u ? a.safeI - q.safeI : u;\n      });\n\n      for (v = 0; v < m; v++) {\n        delete a[v].safeI;\n      }\n    };\n\n    a.arrayMin = function (a) {\n      for (var g = a.length, m = a[0]; g--;) {\n        a[g] < m && (m = a[g]);\n      }\n\n      return m;\n    };\n\n    a.arrayMax = function (a) {\n      for (var g = a.length, m = a[0]; g--;) {\n        a[g] > m && (m = a[g]);\n      }\n\n      return m;\n    };\n\n    a.destroyObjectProperties = function (m, g) {\n      a.objectEach(m, function (a, u) {\n        a && a !== g && a.destroy && a.destroy();\n        delete m[u];\n      });\n    };\n\n    a.discardElement = function (m) {\n      var g = a.garbageBin;\n      g || (g = a.createElement(\"div\"));\n      m && g.appendChild(m);\n      g.innerHTML = \"\";\n    };\n\n    a.correctFloat = function (a, g) {\n      return parseFloat(a.toPrecision(g || 14));\n    };\n\n    a.setAnimation = function (m, g) {\n      g.renderer.globalAnimation = a.pick(m, g.options.chart.animation, !0);\n    };\n\n    a.animObject = function (m) {\n      return a.isObject(m) ? a.merge(m) : {\n        duration: m ? 500 : 0\n      };\n    };\n\n    a.timeUnits = {\n      millisecond: 1,\n      second: 1E3,\n      minute: 6E4,\n      hour: 36E5,\n      day: 864E5,\n      week: 6048E5,\n      month: 24192E5,\n      year: 314496E5\n    };\n\n    a.numberFormat = function (m, g, t, u) {\n      m = +m || 0;\n      g = +g;\n      var v = a.defaultOptions.lang,\n          y = (m.toString().split(\".\")[1] || \"\").split(\"e\")[0].length,\n          q,\n          f,\n          e = m.toString().split(\"e\");\n      -1 === g ? g = Math.min(y, 20) : a.isNumber(g) ? g && e[1] && 0 > e[1] && (q = g + +e[1], 0 <= q ? (e[0] = (+e[0]).toExponential(q).split(\"e\")[0], g = q) : (e[0] = e[0].split(\".\")[0] || 0, m = 20 > g ? (e[0] * Math.pow(10, e[1])).toFixed(g) : 0, e[1] = 0)) : g = 2;\n      f = (Math.abs(e[1] ? e[0] : m) + Math.pow(10, -Math.max(g, y) - 1)).toFixed(g);\n      y = String(a.pInt(f));\n      q = 3 < y.length ? y.length % 3 : 0;\n      t = a.pick(t, v.decimalPoint);\n      u = a.pick(u, v.thousandsSep);\n      m = (0 > m ? \"-\" : \"\") + (q ? y.substr(0, q) + u : \"\");\n      m += y.substr(q).replace(/(\\d{3})(?=\\d)/g, \"$1\" + u);\n      g && (m += t + f.slice(-g));\n      e[1] && 0 !== +m && (m += \"e\" + e[1]);\n      return m;\n    };\n\n    Math.easeInOutSine = function (a) {\n      return -.5 * (Math.cos(Math.PI * a) - 1);\n    };\n\n    a.getStyle = function (m, g, t) {\n      if (\"width\" === g) return Math.max(0, Math.min(m.offsetWidth, m.scrollWidth, m.getBoundingClientRect && \"none\" === a.getStyle(m, \"transform\", !1) ? Math.floor(m.getBoundingClientRect().width) : Infinity) - a.getStyle(m, \"padding-left\") - a.getStyle(m, \"padding-right\"));\n      if (\"height\" === g) return Math.max(0, Math.min(m.offsetHeight, m.scrollHeight) - a.getStyle(m, \"padding-top\") - a.getStyle(m, \"padding-bottom\"));\n      G.getComputedStyle || a.error(27, !0);\n      if (m = G.getComputedStyle(m, void 0)) m = m.getPropertyValue(g), a.pick(t, \"opacity\" !== g) && (m = a.pInt(m));\n      return m;\n    };\n\n    a.inArray = function (a, g, t) {\n      return g.indexOf(a, t);\n    };\n\n    a.find = Array.prototype.find ? function (a, g) {\n      return a.find(g);\n    } : function (a, g) {\n      var m,\n          u = a.length;\n\n      for (m = 0; m < u; m++) {\n        if (g(a[m], m)) return a[m];\n      }\n    };\n    a.keys = Object.keys;\n\n    a.offset = function (a) {\n      var g = A.documentElement;\n      a = a.parentElement || a.parentNode ? a.getBoundingClientRect() : {\n        top: 0,\n        left: 0\n      };\n      return {\n        top: a.top + (G.pageYOffset || g.scrollTop) - (g.clientTop || 0),\n        left: a.left + (G.pageXOffset || g.scrollLeft) - (g.clientLeft || 0)\n      };\n    };\n\n    a.stop = function (m, g) {\n      for (var t = a.timers.length; t--;) {\n        a.timers[t].elem !== m || g && g !== a.timers[t].prop || (a.timers[t].stopped = !0);\n      }\n    };\n\n    a.objectEach = function (a, g, t) {\n      for (var m in a) {\n        a.hasOwnProperty(m) && g.call(t || a[m], a[m], m, a);\n      }\n    };\n\n    a.objectEach({\n      map: \"map\",\n      each: \"forEach\",\n      grep: \"filter\",\n      reduce: \"reduce\",\n      some: \"some\"\n    }, function (m, g) {\n      a[g] = function (a) {\n        return Array.prototype[m].apply(a, [].slice.call(arguments, 1));\n      };\n    });\n\n    a.addEvent = function (m, g, t, u) {\n      var v,\n          y = m.addEventListener || a.addEventListenerPolyfill;\n      v = \"function\" === typeof m && m.prototype ? m.prototype.protoEvents = m.prototype.protoEvents || {} : m.hcEvents = m.hcEvents || {};\n      a.Point && m instanceof a.Point && m.series && m.series.chart && (m.series.chart.runTrackerClick = !0);\n      y && y.call(m, g, t, !1);\n      v[g] || (v[g] = []);\n      v[g].push(t);\n      u && a.isNumber(u.order) && (t.order = u.order, v[g].sort(function (a, f) {\n        return a.order - f.order;\n      }));\n      return function () {\n        a.removeEvent(m, g, t);\n      };\n    };\n\n    a.removeEvent = function (m, g, t) {\n      function u(f, e) {\n        var p = m.removeEventListener || a.removeEventListenerPolyfill;\n        p && p.call(m, f, e, !1);\n      }\n\n      function v(f) {\n        var e, p;\n        m.nodeName && (g ? (e = {}, e[g] = !0) : e = f, a.objectEach(e, function (a, b) {\n          if (f[b]) for (p = f[b].length; p--;) {\n            u(b, f[b][p]);\n          }\n        }));\n      }\n\n      var y, q;\n      [\"protoEvents\", \"hcEvents\"].forEach(function (a) {\n        var e = m[a];\n        e && (g ? (y = e[g] || [], t ? (q = y.indexOf(t), -1 < q && (y.splice(q, 1), e[g] = y), u(g, t)) : (v(e), e[g] = [])) : (v(e), m[a] = {}));\n      });\n    };\n\n    a.fireEvent = function (m, g, t, u) {\n      var v, y, q, f, e;\n      t = t || {};\n      A.createEvent && (m.dispatchEvent || m.fireEvent) ? (v = A.createEvent(\"Events\"), v.initEvent(g, !0, !0), a.extend(v, t), m.dispatchEvent ? m.dispatchEvent(v) : m.fireEvent(g, v)) : [\"protoEvents\", \"hcEvents\"].forEach(function (p) {\n        if (m[p]) for (y = m[p][g] || [], q = y.length, t.target || a.extend(t, {\n          preventDefault: function preventDefault() {\n            t.defaultPrevented = !0;\n          },\n          target: m,\n          type: g\n        }), f = 0; f < q; f++) {\n          (e = y[f]) && !1 === e.call(m, t) && t.preventDefault();\n        }\n      });\n      u && !t.defaultPrevented && u.call(m, t);\n    };\n\n    a.animate = function (m, g, t) {\n      var u,\n          v = \"\",\n          y,\n          q,\n          f;\n      a.isObject(t) || (f = arguments, t = {\n        duration: f[2],\n        easing: f[3],\n        complete: f[4]\n      });\n      a.isNumber(t.duration) || (t.duration = 400);\n      t.easing = \"function\" === typeof t.easing ? t.easing : Math[t.easing] || Math.easeInOutSine;\n      t.curAnim = a.merge(g);\n      a.objectEach(g, function (e, f) {\n        a.stop(m, f);\n        q = new a.Fx(m, t, f);\n        y = null;\n        \"d\" === f ? (q.paths = q.initPath(m, m.d, g.d), q.toD = g.d, u = 0, y = 1) : m.attr ? u = m.attr(f) : (u = parseFloat(a.getStyle(m, f)) || 0, \"opacity\" !== f && (v = \"px\"));\n        y || (y = e);\n        y && y.match && y.match(\"px\") && (y = y.replace(/px/g, \"\"));\n        q.run(u, y, v);\n      });\n    };\n\n    a.seriesType = function (m, g, t, u, v) {\n      var y = a.getOptions(),\n          q = a.seriesTypes;\n      y.plotOptions[m] = a.merge(y.plotOptions[g], t);\n      q[m] = a.extendClass(q[g] || function () {}, u);\n      q[m].prototype.type = m;\n      v && (q[m].prototype.pointClass = a.extendClass(a.Point, v));\n      return q[m];\n    };\n\n    a.uniqueKey = function () {\n      var a = Math.random().toString(36).substring(2, 9),\n          g = 0;\n      return function () {\n        return \"highcharts-\" + a + \"-\" + g++;\n      };\n    }();\n\n    a.isFunction = function (a) {\n      return \"function\" === typeof a;\n    };\n\n    G.jQuery && (G.jQuery.fn.highcharts = function () {\n      var m = [].slice.call(arguments);\n      if (this[0]) return m[0] ? (new a[a.isString(m[0]) ? m.shift() : \"Chart\"](this[0], m[0], m[1]), this) : B[a.attr(this[0], \"data-highcharts-chart\")];\n    });\n  })(H);\n\n  (function (a) {\n    var B = a.isNumber,\n        A = a.merge,\n        G = a.pInt;\n\n    a.Color = function (m) {\n      if (!(this instanceof a.Color)) return new a.Color(m);\n      this.init(m);\n    };\n\n    a.Color.prototype = {\n      parsers: [{\n        regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n        parse: function parse(a) {\n          return [G(a[1]), G(a[2]), G(a[3]), parseFloat(a[4], 10)];\n        }\n      }, {\n        regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n        parse: function parse(a) {\n          return [G(a[1]), G(a[2]), G(a[3]), 1];\n        }\n      }],\n      names: {\n        white: \"#ffffff\",\n        black: \"#000000\"\n      },\n      init: function init(m) {\n        var g, t, u, v;\n        if ((this.input = m = this.names[m && m.toLowerCase ? m.toLowerCase() : \"\"] || m) && m.stops) this.stops = m.stops.map(function (g) {\n          return new a.Color(g[1]);\n        });else if (m && m.charAt && \"#\" === m.charAt() && (g = m.length, m = parseInt(m.substr(1), 16), 7 === g ? t = [(m & 16711680) >> 16, (m & 65280) >> 8, m & 255, 1] : 4 === g && (t = [(m & 3840) >> 4 | (m & 3840) >> 8, (m & 240) >> 4 | m & 240, (m & 15) << 4 | m & 15, 1])), !t) for (u = this.parsers.length; u-- && !t;) {\n          v = this.parsers[u], (g = v.regex.exec(m)) && (t = v.parse(g));\n        }\n        this.rgba = t || [];\n      },\n      get: function get(a) {\n        var g = this.input,\n            m = this.rgba,\n            u;\n        this.stops ? (u = A(g), u.stops = [].concat(u.stops), this.stops.forEach(function (g, m) {\n          u.stops[m] = [u.stops[m][0], g.get(a)];\n        })) : u = m && B(m[0]) ? \"rgb\" === a || !a && 1 === m[3] ? \"rgb(\" + m[0] + \",\" + m[1] + \",\" + m[2] + \")\" : \"a\" === a ? m[3] : \"rgba(\" + m.join(\",\") + \")\" : g;\n        return u;\n      },\n      brighten: function brighten(a) {\n        var g,\n            m = this.rgba;\n        if (this.stops) this.stops.forEach(function (g) {\n          g.brighten(a);\n        });else if (B(a) && 0 !== a) for (g = 0; 3 > g; g++) {\n          m[g] += G(255 * a), 0 > m[g] && (m[g] = 0), 255 < m[g] && (m[g] = 255);\n        }\n        return this;\n      },\n      setOpacity: function setOpacity(a) {\n        this.rgba[3] = a;\n        return this;\n      },\n      tweenTo: function tweenTo(a, g) {\n        var m = this.rgba,\n            u = a.rgba;\n        u.length && m && m.length ? (a = 1 !== u[3] || 1 !== m[3], g = (a ? \"rgba(\" : \"rgb(\") + Math.round(u[0] + (m[0] - u[0]) * (1 - g)) + \",\" + Math.round(u[1] + (m[1] - u[1]) * (1 - g)) + \",\" + Math.round(u[2] + (m[2] - u[2]) * (1 - g)) + (a ? \",\" + (u[3] + (m[3] - u[3]) * (1 - g)) : \"\") + \")\") : g = a.input || \"none\";\n        return g;\n      }\n    };\n\n    a.color = function (m) {\n      return new a.Color(m);\n    };\n  })(H);\n\n  (function (a) {\n    var B,\n        A,\n        G = a.addEvent,\n        m = a.animate,\n        g = a.attr,\n        t = a.charts,\n        u = a.color,\n        v = a.css,\n        y = a.createElement,\n        q = a.defined,\n        f = a.deg2rad,\n        e = a.destroyObjectProperties,\n        p = a.doc,\n        r = a.extend,\n        b = a.erase,\n        l = a.hasTouch,\n        n = a.isArray,\n        d = a.isFirefox,\n        w = a.isMS,\n        E = a.isObject,\n        C = a.isString,\n        F = a.isWebKit,\n        c = a.merge,\n        k = a.noop,\n        x = a.objectEach,\n        D = a.pick,\n        h = a.pInt,\n        z = a.removeEvent,\n        L = a.splat,\n        J = a.stop,\n        W = a.svg,\n        I = a.SVG_NS,\n        O = a.symbolSizes,\n        R = a.win;\n\n    B = a.SVGElement = function () {\n      return this;\n    };\n\n    r(B.prototype, {\n      opacity: 1,\n      SVG_NS: I,\n      textProps: \"direction fontSize fontWeight fontFamily fontStyle color lineHeight width textAlign textDecoration textOverflow textOutline cursor\".split(\" \"),\n      init: function init(h, c) {\n        this.element = \"span\" === c ? y(c) : p.createElementNS(this.SVG_NS, c);\n        this.renderer = h;\n        a.fireEvent(this, \"afterInit\");\n      },\n      animate: function animate(h, c, b) {\n        var k = a.animObject(D(c, this.renderer.globalAnimation, !0));\n        D(p.hidden, p.msHidden, p.webkitHidden, !1) && (k.duration = 0);\n        0 !== k.duration ? (b && (k.complete = b), m(this, h, k)) : (this.attr(h, null, b), a.objectEach(h, function (a, h) {\n          k.step && k.step.call(this, a, {\n            prop: h,\n            pos: 1\n          });\n        }, this));\n        return this;\n      },\n      complexColor: function complexColor(h, b, k) {\n        var z = this.renderer,\n            K,\n            l,\n            d,\n            e,\n            r,\n            f,\n            w,\n            p,\n            I,\n            D,\n            J,\n            L = [],\n            E;\n        a.fireEvent(this.renderer, \"complexColor\", {\n          args: arguments\n        }, function () {\n          h.radialGradient ? l = \"radialGradient\" : h.linearGradient && (l = \"linearGradient\");\n          l && (d = h[l], r = z.gradients, w = h.stops, D = k.radialReference, n(d) && (h[l] = d = {\n            x1: d[0],\n            y1: d[1],\n            x2: d[2],\n            y2: d[3],\n            gradientUnits: \"userSpaceOnUse\"\n          }), \"radialGradient\" === l && D && !q(d.gradientUnits) && (e = d, d = c(d, z.getRadialAttr(D, e), {\n            gradientUnits: \"userSpaceOnUse\"\n          })), x(d, function (a, h) {\n            \"id\" !== h && L.push(h, a);\n          }), x(w, function (a) {\n            L.push(a);\n          }), L = L.join(\",\"), r[L] ? J = r[L].attr(\"id\") : (d.id = J = a.uniqueKey(), r[L] = f = z.createElement(l).attr(d).add(z.defs), f.radAttr = e, f.stops = [], w.forEach(function (h) {\n            0 === h[1].indexOf(\"rgba\") ? (K = a.color(h[1]), p = K.get(\"rgb\"), I = K.get(\"a\")) : (p = h[1], I = 1);\n            h = z.createElement(\"stop\").attr({\n              offset: h[0],\n              \"stop-color\": p,\n              \"stop-opacity\": I\n            }).add(f);\n            f.stops.push(h);\n          })), E = \"url(\" + z.url + \"#\" + J + \")\", k.setAttribute(b, E), k.gradient = L, h.toString = function () {\n            return E;\n          });\n        });\n      },\n      applyTextOutline: function applyTextOutline(h) {\n        var c = this.element,\n            k,\n            z,\n            K,\n            l,\n            d;\n        -1 !== h.indexOf(\"contrast\") && (h = h.replace(/contrast/g, this.renderer.getContrast(c.style.fill)));\n        h = h.split(\" \");\n        z = h[h.length - 1];\n\n        if ((K = h[0]) && \"none\" !== K && a.svg) {\n          this.fakeTS = !0;\n          h = [].slice.call(c.getElementsByTagName(\"tspan\"));\n          this.ySetter = this.xSetter;\n          K = K.replace(/(^[\\d\\.]+)(.*?)$/g, function (a, h, c) {\n            return 2 * h + c;\n          });\n\n          for (d = h.length; d--;) {\n            k = h[d], \"highcharts-text-outline\" === k.getAttribute(\"class\") && b(h, c.removeChild(k));\n          }\n\n          l = c.firstChild;\n          h.forEach(function (a, h) {\n            0 === h && (a.setAttribute(\"x\", c.getAttribute(\"x\")), h = c.getAttribute(\"y\"), a.setAttribute(\"y\", h || 0), null === h && c.setAttribute(\"y\", 0));\n            a = a.cloneNode(1);\n            g(a, {\n              \"class\": \"highcharts-text-outline\",\n              fill: z,\n              stroke: z,\n              \"stroke-width\": K,\n              \"stroke-linejoin\": \"round\"\n            });\n            c.insertBefore(a, l);\n          });\n        }\n      },\n      symbolCustomAttribs: \"x y width height r start end innerR anchorX anchorY rounded\".split(\" \"),\n      attr: function attr(h, c, b, k) {\n        var z,\n            K = this.element,\n            d,\n            l = this,\n            n,\n            e,\n            r = this.symbolCustomAttribs;\n        \"string\" === typeof h && void 0 !== c && (z = h, h = {}, h[z] = c);\n        \"string\" === typeof h ? l = (this[h + \"Getter\"] || this._defaultGetter).call(this, h, K) : (x(h, function (c, b) {\n          n = !1;\n          k || J(this, b);\n          this.symbolName && -1 !== a.inArray(b, r) && (d || (this.symbolAttr(h), d = !0), n = !0);\n          !this.rotation || \"x\" !== b && \"y\" !== b || (this.doTransform = !0);\n          n || (e = this[b + \"Setter\"] || this._defaultSetter, e.call(this, c, b, K), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(b) && this.updateShadows(b, c, e));\n        }, this), this.afterSetters());\n        b && b.call(this);\n        return l;\n      },\n      afterSetters: function afterSetters() {\n        this.doTransform && (this.updateTransform(), this.doTransform = !1);\n      },\n      updateShadows: function updateShadows(a, h, c) {\n        for (var b = this.shadows, k = b.length; k--;) {\n          c.call(b[k], \"height\" === a ? Math.max(h - (b[k].cutHeight || 0), 0) : \"d\" === a ? this.d : h, a, b[k]);\n        }\n      },\n      addClass: function addClass(a, h) {\n        var c = this.attr(\"class\") || \"\";\n        -1 === c.indexOf(a) && (h || (a = (c + (c ? \" \" : \"\") + a).replace(\"  \", \" \")), this.attr(\"class\", a));\n        return this;\n      },\n      hasClass: function hasClass(a) {\n        return -1 !== (this.attr(\"class\") || \"\").split(\" \").indexOf(a);\n      },\n      removeClass: function removeClass(a) {\n        return this.attr(\"class\", (this.attr(\"class\") || \"\").replace(a, \"\"));\n      },\n      symbolAttr: function symbolAttr(a) {\n        var h = this;\n        \"x y r start end width height innerR anchorX anchorY\".split(\" \").forEach(function (c) {\n          h[c] = D(a[c], h[c]);\n        });\n        h.attr({\n          d: h.renderer.symbols[h.symbolName](h.x, h.y, h.width, h.height, h)\n        });\n      },\n      clip: function clip(a) {\n        return this.attr(\"clip-path\", a ? \"url(\" + this.renderer.url + \"#\" + a.id + \")\" : \"none\");\n      },\n      crisp: function crisp(a, h) {\n        var c;\n        h = h || a.strokeWidth || 0;\n        c = Math.round(h) % 2 / 2;\n        a.x = Math.floor(a.x || this.x || 0) + c;\n        a.y = Math.floor(a.y || this.y || 0) + c;\n        a.width = Math.floor((a.width || this.width || 0) - 2 * c);\n        a.height = Math.floor((a.height || this.height || 0) - 2 * c);\n        q(a.strokeWidth) && (a.strokeWidth = h);\n        return a;\n      },\n      css: function css(a) {\n        var c = this.styles,\n            b = {},\n            k = this.element,\n            z,\n            d = \"\",\n            l,\n            n = !c,\n            K = [\"textOutline\", \"textOverflow\", \"width\"];\n        a && a.color && (a.fill = a.color);\n        c && x(a, function (a, h) {\n          a !== c[h] && (b[h] = a, n = !0);\n        });\n        n && (c && (a = r(c, b)), a && (null === a.width || \"auto\" === a.width ? delete this.textWidth : \"text\" === k.nodeName.toLowerCase() && a.width && (z = this.textWidth = h(a.width))), this.styles = a, z && !W && this.renderer.forExport && delete a.width, k.namespaceURI === this.SVG_NS ? (l = function l(a, h) {\n          return \"-\" + h.toLowerCase();\n        }, x(a, function (a, h) {\n          -1 === K.indexOf(h) && (d += h.replace(/([A-Z])/g, l) + \":\" + a + \";\");\n        }), d && g(k, \"style\", d)) : v(k, a), this.added && (\"text\" === this.element.nodeName && this.renderer.buildText(this), a && a.textOutline && this.applyTextOutline(a.textOutline)));\n        return this;\n      },\n      getStyle: function getStyle(a) {\n        return R.getComputedStyle(this.element || this, \"\").getPropertyValue(a);\n      },\n      strokeWidth: function strokeWidth() {\n        if (!this.renderer.styledMode) return this[\"stroke-width\"] || 0;\n        var a = this.getStyle(\"stroke-width\"),\n            c;\n        a.indexOf(\"px\") === a.length - 2 ? a = h(a) : (c = p.createElementNS(I, \"rect\"), g(c, {\n          width: a,\n          \"stroke-width\": 0\n        }), this.element.parentNode.appendChild(c), a = c.getBBox().width, c.parentNode.removeChild(c));\n        return a;\n      },\n      on: function on(a, h) {\n        var c = this,\n            b = c.element;\n        l && \"click\" === a ? (b.ontouchstart = function (a) {\n          c.touchEventFired = Date.now();\n          a.preventDefault();\n          h.call(b, a);\n        }, b.onclick = function (a) {\n          (-1 === R.navigator.userAgent.indexOf(\"Android\") || 1100 < Date.now() - (c.touchEventFired || 0)) && h.call(b, a);\n        }) : b[\"on\" + a] = h;\n        return this;\n      },\n      setRadialReference: function setRadialReference(a) {\n        var h = this.renderer.gradients[this.element.gradient];\n        this.element.radialReference = a;\n        h && h.radAttr && h.animate(this.renderer.getRadialAttr(a, h.radAttr));\n        return this;\n      },\n      translate: function translate(a, h) {\n        return this.attr({\n          translateX: a,\n          translateY: h\n        });\n      },\n      invert: function invert(a) {\n        this.inverted = a;\n        this.updateTransform();\n        return this;\n      },\n      updateTransform: function updateTransform() {\n        var a = this.translateX || 0,\n            h = this.translateY || 0,\n            c = this.scaleX,\n            b = this.scaleY,\n            k = this.inverted,\n            z = this.rotation,\n            d = this.matrix,\n            l = this.element;\n        k && (a += this.width, h += this.height);\n        a = [\"translate(\" + a + \",\" + h + \")\"];\n        q(d) && a.push(\"matrix(\" + d.join(\",\") + \")\");\n        k ? a.push(\"rotate(90) scale(-1,1)\") : z && a.push(\"rotate(\" + z + \" \" + D(this.rotationOriginX, l.getAttribute(\"x\"), 0) + \" \" + D(this.rotationOriginY, l.getAttribute(\"y\") || 0) + \")\");\n        (q(c) || q(b)) && a.push(\"scale(\" + D(c, 1) + \" \" + D(b, 1) + \")\");\n        a.length && l.setAttribute(\"transform\", a.join(\" \"));\n      },\n      toFront: function toFront() {\n        var a = this.element;\n        a.parentNode.appendChild(a);\n        return this;\n      },\n      align: function align(a, h, c) {\n        var k,\n            z,\n            d,\n            l,\n            x = {};\n        z = this.renderer;\n        d = z.alignedObjects;\n        var n, e;\n\n        if (a) {\n          if (this.alignOptions = a, this.alignByTranslate = h, !c || C(c)) this.alignTo = k = c || \"renderer\", b(d, this), d.push(this), c = null;\n        } else a = this.alignOptions, h = this.alignByTranslate, k = this.alignTo;\n\n        c = D(c, z[k], z);\n        k = a.align;\n        z = a.verticalAlign;\n        d = (c.x || 0) + (a.x || 0);\n        l = (c.y || 0) + (a.y || 0);\n        \"right\" === k ? n = 1 : \"center\" === k && (n = 2);\n        n && (d += (c.width - (a.width || 0)) / n);\n        x[h ? \"translateX\" : \"x\"] = Math.round(d);\n        \"bottom\" === z ? e = 1 : \"middle\" === z && (e = 2);\n        e && (l += (c.height - (a.height || 0)) / e);\n        x[h ? \"translateY\" : \"y\"] = Math.round(l);\n        this[this.placed ? \"animate\" : \"attr\"](x);\n        this.placed = !0;\n        this.alignAttr = x;\n        return this;\n      },\n      getBBox: function getBBox(a, h) {\n        var c,\n            b = this.renderer,\n            k,\n            z = this.element,\n            d = this.styles,\n            l,\n            x = this.textStr,\n            n,\n            e = b.cache,\n            K = b.cacheKeys,\n            w = z.namespaceURI === this.SVG_NS,\n            p;\n        h = D(h, this.rotation);\n        k = h * f;\n        l = b.styledMode ? z && B.prototype.getStyle.call(z, \"font-size\") : d && d.fontSize;\n        q(x) && (p = x.toString(), -1 === p.indexOf(\"\\x3c\") && (p = p.replace(/[0-9]/g, \"0\")), p += [\"\", h || 0, l, this.textWidth, d && d.textOverflow].join());\n        p && !a && (c = e[p]);\n\n        if (!c) {\n          if (w || b.forExport) {\n            try {\n              (n = this.fakeTS && function (a) {\n                [].forEach.call(z.querySelectorAll(\".highcharts-text-outline\"), function (h) {\n                  h.style.display = a;\n                });\n              }) && n(\"none\"), c = z.getBBox ? r({}, z.getBBox()) : {\n                width: z.offsetWidth,\n                height: z.offsetHeight\n              }, n && n(\"\");\n            } catch (Y) {}\n\n            if (!c || 0 > c.width) c = {\n              width: 0,\n              height: 0\n            };\n          } else c = this.htmlGetBBox();\n\n          b.isSVG && (a = c.width, b = c.height, w && (c.height = b = {\n            \"11px,17\": 14,\n            \"13px,20\": 16\n          }[d && d.fontSize + \",\" + Math.round(b)] || b), h && (c.width = Math.abs(b * Math.sin(k)) + Math.abs(a * Math.cos(k)), c.height = Math.abs(b * Math.cos(k)) + Math.abs(a * Math.sin(k))));\n\n          if (p && 0 < c.height) {\n            for (; 250 < K.length;) {\n              delete e[K.shift()];\n            }\n\n            e[p] || K.push(p);\n            e[p] = c;\n          }\n        }\n\n        return c;\n      },\n      show: function show(a) {\n        return this.attr({\n          visibility: a ? \"inherit\" : \"visible\"\n        });\n      },\n      hide: function hide() {\n        return this.attr({\n          visibility: \"hidden\"\n        });\n      },\n      fadeOut: function fadeOut(a) {\n        var h = this;\n        h.animate({\n          opacity: 0\n        }, {\n          duration: a || 150,\n          complete: function complete() {\n            h.attr({\n              y: -9999\n            });\n          }\n        });\n      },\n      add: function add(a) {\n        var h = this.renderer,\n            c = this.element,\n            b;\n        a && (this.parentGroup = a);\n        this.parentInverted = a && a.inverted;\n        void 0 !== this.textStr && h.buildText(this);\n        this.added = !0;\n        if (!a || a.handleZ || this.zIndex) b = this.zIndexSetter();\n        b || (a ? a.element : h.box).appendChild(c);\n        if (this.onAdd) this.onAdd();\n        return this;\n      },\n      safeRemoveChild: function safeRemoveChild(a) {\n        var h = a.parentNode;\n        h && h.removeChild(a);\n      },\n      destroy: function destroy() {\n        var a = this,\n            h = a.element || {},\n            c = a.renderer,\n            k = c.isSVG && \"SPAN\" === h.nodeName && a.parentGroup,\n            z = h.ownerSVGElement,\n            d = a.clipPath;\n        h.onclick = h.onmouseout = h.onmouseover = h.onmousemove = h.point = null;\n        J(a);\n        d && z && ([].forEach.call(z.querySelectorAll(\"[clip-path],[CLIP-PATH]\"), function (a) {\n          var h = a.getAttribute(\"clip-path\"),\n              c = d.element.id;\n          (-1 < h.indexOf(\"(#\" + c + \")\") || -1 < h.indexOf('(\"#' + c + '\")')) && a.removeAttribute(\"clip-path\");\n        }), a.clipPath = d.destroy());\n\n        if (a.stops) {\n          for (z = 0; z < a.stops.length; z++) {\n            a.stops[z] = a.stops[z].destroy();\n          }\n\n          a.stops = null;\n        }\n\n        a.safeRemoveChild(h);\n\n        for (c.styledMode || a.destroyShadows(); k && k.div && 0 === k.div.childNodes.length;) {\n          h = k.parentGroup, a.safeRemoveChild(k.div), delete k.div, k = h;\n        }\n\n        a.alignTo && b(c.alignedObjects, a);\n        x(a, function (h, c) {\n          delete a[c];\n        });\n        return null;\n      },\n      shadow: function shadow(a, h, c) {\n        var b = [],\n            k,\n            z,\n            d = this.element,\n            l,\n            x,\n            n,\n            e;\n        if (!a) this.destroyShadows();else if (!this.shadows) {\n          x = D(a.width, 3);\n          n = (a.opacity || .15) / x;\n          e = this.parentInverted ? \"(-1,-1)\" : \"(\" + D(a.offsetX, 1) + \", \" + D(a.offsetY, 1) + \")\";\n\n          for (k = 1; k <= x; k++) {\n            z = d.cloneNode(0), l = 2 * x + 1 - 2 * k, g(z, {\n              stroke: a.color || \"#000000\",\n              \"stroke-opacity\": n * k,\n              \"stroke-width\": l,\n              transform: \"translate\" + e,\n              fill: \"none\"\n            }), z.setAttribute(\"class\", (z.getAttribute(\"class\") || \"\") + \" highcharts-shadow\"), c && (g(z, \"height\", Math.max(g(z, \"height\") - l, 0)), z.cutHeight = l), h ? h.element.appendChild(z) : d.parentNode && d.parentNode.insertBefore(z, d), b.push(z);\n          }\n\n          this.shadows = b;\n        }\n        return this;\n      },\n      destroyShadows: function destroyShadows() {\n        (this.shadows || []).forEach(function (a) {\n          this.safeRemoveChild(a);\n        }, this);\n        this.shadows = void 0;\n      },\n      xGetter: function xGetter(a) {\n        \"circle\" === this.element.nodeName && (\"x\" === a ? a = \"cx\" : \"y\" === a && (a = \"cy\"));\n        return this._defaultGetter(a);\n      },\n      _defaultGetter: function _defaultGetter(a) {\n        a = D(this[a + \"Value\"], this[a], this.element ? this.element.getAttribute(a) : null, 0);\n        /^[\\-0-9\\.]+$/.test(a) && (a = parseFloat(a));\n        return a;\n      },\n      dSetter: function dSetter(a, h, c) {\n        a && a.join && (a = a.join(\" \"));\n        /(NaN| {2}|^$)/.test(a) && (a = \"M 0 0\");\n        this[h] !== a && (c.setAttribute(h, a), this[h] = a);\n      },\n      dashstyleSetter: function dashstyleSetter(a) {\n        var c,\n            b = this[\"stroke-width\"];\n        \"inherit\" === b && (b = 1);\n\n        if (a = a && a.toLowerCase()) {\n          a = a.replace(\"shortdashdotdot\", \"3,1,1,1,1,1,\").replace(\"shortdashdot\", \"3,1,1,1\").replace(\"shortdot\", \"1,1,\").replace(\"shortdash\", \"3,1,\").replace(\"longdash\", \"8,3,\").replace(/dot/g, \"1,3,\").replace(\"dash\", \"4,3,\").replace(/,$/, \"\").split(\",\");\n\n          for (c = a.length; c--;) {\n            a[c] = h(a[c]) * b;\n          }\n\n          a = a.join(\",\").replace(/NaN/g, \"none\");\n          this.element.setAttribute(\"stroke-dasharray\", a);\n        }\n      },\n      alignSetter: function alignSetter(a) {\n        var h = {\n          left: \"start\",\n          center: \"middle\",\n          right: \"end\"\n        };\n        h[a] && (this.alignValue = a, this.element.setAttribute(\"text-anchor\", h[a]));\n      },\n      opacitySetter: function opacitySetter(a, h, c) {\n        this[h] = a;\n        c.setAttribute(h, a);\n      },\n      titleSetter: function titleSetter(a) {\n        var h = this.element.getElementsByTagName(\"title\")[0];\n        h || (h = p.createElementNS(this.SVG_NS, \"title\"), this.element.appendChild(h));\n        h.firstChild && h.removeChild(h.firstChild);\n        h.appendChild(p.createTextNode(String(D(a), \"\").replace(/<[^>]*>/g, \"\").replace(/&lt;/g, \"\\x3c\").replace(/&gt;/g, \"\\x3e\")));\n      },\n      textSetter: function textSetter(a) {\n        a !== this.textStr && (delete this.bBox, this.textStr = a, this.added && this.renderer.buildText(this));\n      },\n      fillSetter: function fillSetter(a, h, c) {\n        \"string\" === typeof a ? c.setAttribute(h, a) : a && this.complexColor(a, h, c);\n      },\n      visibilitySetter: function visibilitySetter(a, h, c) {\n        \"inherit\" === a ? c.removeAttribute(h) : this[h] !== a && c.setAttribute(h, a);\n        this[h] = a;\n      },\n      zIndexSetter: function zIndexSetter(a, c) {\n        var b = this.renderer,\n            k = this.parentGroup,\n            z = (k || b).element || b.box,\n            d,\n            l = this.element,\n            x,\n            n,\n            b = z === b.box;\n        d = this.added;\n        var e;\n        q(a) ? (l.setAttribute(\"data-z-index\", a), a = +a, this[c] === a && (d = !1)) : q(this[c]) && l.removeAttribute(\"data-z-index\");\n        this[c] = a;\n\n        if (d) {\n          (a = this.zIndex) && k && (k.handleZ = !0);\n          c = z.childNodes;\n\n          for (e = c.length - 1; 0 <= e && !x; e--) {\n            if (k = c[e], d = k.getAttribute(\"data-z-index\"), n = !q(d), k !== l) if (0 > a && n && !b && !e) z.insertBefore(l, c[e]), x = !0;else if (h(d) <= a || n && (!q(a) || 0 <= a)) z.insertBefore(l, c[e + 1] || null), x = !0;\n          }\n\n          x || (z.insertBefore(l, c[b ? 3 : 0] || null), x = !0);\n        }\n\n        return x;\n      },\n      _defaultSetter: function _defaultSetter(a, h, c) {\n        c.setAttribute(h, a);\n      }\n    });\n    B.prototype.yGetter = B.prototype.xGetter;\n\n    B.prototype.translateXSetter = B.prototype.translateYSetter = B.prototype.rotationSetter = B.prototype.verticalAlignSetter = B.prototype.rotationOriginXSetter = B.prototype.rotationOriginYSetter = B.prototype.scaleXSetter = B.prototype.scaleYSetter = B.prototype.matrixSetter = function (a, h) {\n      this[h] = a;\n      this.doTransform = !0;\n    };\n\n    B.prototype[\"stroke-widthSetter\"] = B.prototype.strokeSetter = function (a, h, c) {\n      this[h] = a;\n      this.stroke && this[\"stroke-width\"] ? (B.prototype.fillSetter.call(this, this.stroke, \"stroke\", c), c.setAttribute(\"stroke-width\", this[\"stroke-width\"]), this.hasStroke = !0) : \"stroke-width\" === h && 0 === a && this.hasStroke && (c.removeAttribute(\"stroke\"), this.hasStroke = !1);\n    };\n\n    A = a.SVGRenderer = function () {\n      this.init.apply(this, arguments);\n    };\n\n    r(A.prototype, {\n      Element: B,\n      SVG_NS: I,\n      init: function init(a, h, c, b, k, z, l) {\n        var x;\n        x = this.createElement(\"svg\").attr({\n          version: \"1.1\",\n          \"class\": \"highcharts-root\"\n        });\n        l || x.css(this.getStyle(b));\n        b = x.element;\n        a.appendChild(b);\n        g(a, \"dir\", \"ltr\");\n        -1 === a.innerHTML.indexOf(\"xmlns\") && g(b, \"xmlns\", this.SVG_NS);\n        this.isSVG = !0;\n        this.box = b;\n        this.boxWrapper = x;\n        this.alignedObjects = [];\n        this.url = (d || F) && p.getElementsByTagName(\"base\").length ? R.location.href.split(\"#\")[0].replace(/<[^>]*>/g, \"\").replace(/([\\('\\)])/g, \"\\\\$1\").replace(/ /g, \"%20\") : \"\";\n        this.createElement(\"desc\").add().element.appendChild(p.createTextNode(\"Created with Highstock 7.0.3\"));\n        this.defs = this.createElement(\"defs\").add();\n        this.allowHTML = z;\n        this.forExport = k;\n        this.styledMode = l;\n        this.gradients = {};\n        this.cache = {};\n        this.cacheKeys = [];\n        this.imgCount = 0;\n        this.setSize(h, c, !1);\n        var n;\n        d && a.getBoundingClientRect && (h = function h() {\n          v(a, {\n            left: 0,\n            top: 0\n          });\n          n = a.getBoundingClientRect();\n          v(a, {\n            left: Math.ceil(n.left) - n.left + \"px\",\n            top: Math.ceil(n.top) - n.top + \"px\"\n          });\n        }, h(), this.unSubPixelFix = G(R, \"resize\", h));\n      },\n      definition: function definition(a) {\n        function h(a, b) {\n          var k;\n          L(a).forEach(function (a) {\n            var z = c.createElement(a.tagName),\n                d = {};\n            x(a, function (a, h) {\n              \"tagName\" !== h && \"children\" !== h && \"textContent\" !== h && (d[h] = a);\n            });\n            z.attr(d);\n            z.add(b || c.defs);\n            a.textContent && z.element.appendChild(p.createTextNode(a.textContent));\n            h(a.children || [], z);\n            k = z;\n          });\n          return k;\n        }\n\n        var c = this;\n        return h(a);\n      },\n      getStyle: function getStyle(a) {\n        return this.style = r({\n          fontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Arial, Helvetica, sans-serif',\n          fontSize: \"12px\"\n        }, a);\n      },\n      setStyle: function setStyle(a) {\n        this.boxWrapper.css(this.getStyle(a));\n      },\n      isHidden: function isHidden() {\n        return !this.boxWrapper.getBBox().width;\n      },\n      destroy: function destroy() {\n        var a = this.defs;\n        this.box = null;\n        this.boxWrapper = this.boxWrapper.destroy();\n        e(this.gradients || {});\n        this.gradients = null;\n        a && (this.defs = a.destroy());\n        this.unSubPixelFix && this.unSubPixelFix();\n        return this.alignedObjects = null;\n      },\n      createElement: function createElement(a) {\n        var h = new this.Element();\n        h.init(this, a);\n        return h;\n      },\n      draw: k,\n      getRadialAttr: function getRadialAttr(a, h) {\n        return {\n          cx: a[0] - a[2] / 2 + h.cx * a[2],\n          cy: a[1] - a[2] / 2 + h.cy * a[2],\n          r: h.r * a[2]\n        };\n      },\n      truncate: function truncate(a, h, c, b, k, z, d) {\n        var l = this,\n            x = a.rotation,\n            n,\n            e = b ? 1 : 0,\n            r = (c || b).length,\n            f = r,\n            w = [],\n            I = function I(a) {\n          h.firstChild && h.removeChild(h.firstChild);\n          a && h.appendChild(p.createTextNode(a));\n        },\n            q = function q(z, x) {\n          x = x || z;\n          if (void 0 === w[x]) if (h.getSubStringLength) try {\n            w[x] = k + h.getSubStringLength(0, b ? x + 1 : x);\n          } catch (ea) {} else l.getSpanWidth && (I(d(c || b, z)), w[x] = k + l.getSpanWidth(a, h));\n          return w[x];\n        },\n            D,\n            J;\n\n        a.rotation = 0;\n        D = q(h.textContent.length);\n\n        if (J = k + D > z) {\n          for (; e <= r;) {\n            f = Math.ceil((e + r) / 2), b && (n = d(b, f)), D = q(f, n && n.length - 1), e === r ? e = r + 1 : D > z ? r = f - 1 : e = f;\n          }\n\n          0 === r ? I(\"\") : c && r === c.length - 1 || I(n || d(c || b, f));\n        }\n\n        b && b.splice(0, f);\n        a.actualWidth = D;\n        a.rotation = x;\n        return J;\n      },\n      escapes: {\n        \"\\x26\": \"\\x26amp;\",\n        \"\\x3c\": \"\\x26lt;\",\n        \"\\x3e\": \"\\x26gt;\",\n        \"'\": \"\\x26#39;\",\n        '\"': \"\\x26quot;\"\n      },\n      buildText: function buildText(a) {\n        var c = a.element,\n            b = this,\n            k = b.forExport,\n            z = D(a.textStr, \"\").toString(),\n            d = -1 !== z.indexOf(\"\\x3c\"),\n            l = c.childNodes,\n            n,\n            e = g(c, \"x\"),\n            r = a.styles,\n            f = a.textWidth,\n            w = r && r.lineHeight,\n            q = r && r.textOutline,\n            J = r && \"ellipsis\" === r.textOverflow,\n            L = r && \"nowrap\" === r.whiteSpace,\n            E = r && r.fontSize,\n            K,\n            C,\n            F = l.length,\n            r = f && !a.added && this.box,\n            O = function O(a) {\n          var k;\n          b.styledMode || (k = /(px|em)$/.test(a && a.style.fontSize) ? a.style.fontSize : E || b.style.fontSize || 12);\n          return w ? h(w) : b.fontMetrics(k, a.getAttribute(\"style\") ? a : c).h;\n        },\n            m = function m(a, h) {\n          x(b.escapes, function (c, b) {\n            h && -1 !== h.indexOf(c) || (a = a.toString().replace(new RegExp(c, \"g\"), b));\n          });\n          return a;\n        },\n            y = function y(a, h) {\n          var c;\n          c = a.indexOf(\"\\x3c\");\n          a = a.substring(c, a.indexOf(\"\\x3e\") - c);\n          c = a.indexOf(h + \"\\x3d\");\n          if (-1 !== c && (c = c + h.length + 1, h = a.charAt(c), '\"' === h || \"'\" === h)) return a = a.substring(c + 1), a.substring(0, a.indexOf(h));\n        };\n\n        K = [z, J, L, w, q, E, f].join();\n\n        if (K !== a.textCache) {\n          for (a.textCache = K; F--;) {\n            c.removeChild(l[F]);\n          }\n\n          d || q || J || f || -1 !== z.indexOf(\" \") ? (r && r.appendChild(c), d ? (z = b.styledMode ? z.replace(/<(b|strong)>/g, '\\x3cspan class\\x3d\"highcharts-strong\"\\x3e').replace(/<(i|em)>/g, '\\x3cspan class\\x3d\"highcharts-emphasized\"\\x3e') : z.replace(/<(b|strong)>/g, '\\x3cspan style\\x3d\"font-weight:bold\"\\x3e').replace(/<(i|em)>/g, '\\x3cspan style\\x3d\"font-style:italic\"\\x3e'), z = z.replace(/<a/g, \"\\x3cspan\").replace(/<\\/(b|strong|i|em|a)>/g, \"\\x3c/span\\x3e\").split(/<br.*?>/g)) : z = [z], z = z.filter(function (a) {\n            return \"\" !== a;\n          }), z.forEach(function (h, z) {\n            var d,\n                l = 0,\n                x = 0;\n            h = h.replace(/^\\s+|\\s+$/g, \"\").replace(/<span/g, \"|||\\x3cspan\").replace(/<\\/span>/g, \"\\x3c/span\\x3e|||\");\n            d = h.split(\"|||\");\n            d.forEach(function (h) {\n              if (\"\" !== h || 1 === d.length) {\n                var r = {},\n                    w = p.createElementNS(b.SVG_NS, \"tspan\"),\n                    q,\n                    D;\n                (q = y(h, \"class\")) && g(w, \"class\", q);\n                if (q = y(h, \"style\")) q = q.replace(/(;| |^)color([ :])/, \"$1fill$2\"), g(w, \"style\", q);\n                (D = y(h, \"href\")) && !k && (g(w, \"onclick\", 'location.href\\x3d\"' + D + '\"'), g(w, \"class\", \"highcharts-anchor\"), b.styledMode || v(w, {\n                  cursor: \"pointer\"\n                }));\n                h = m(h.replace(/<[a-zA-Z\\/](.|\\n)*?>/g, \"\") || \" \");\n\n                if (\" \" !== h) {\n                  w.appendChild(p.createTextNode(h));\n                  l ? r.dx = 0 : z && null !== e && (r.x = e);\n                  g(w, r);\n                  c.appendChild(w);\n                  !l && C && (!W && k && v(w, {\n                    display: \"block\"\n                  }), g(w, \"dy\", O(w)));\n\n                  if (f) {\n                    var K = h.replace(/([^\\^])-/g, \"$1- \").split(\" \"),\n                        r = !L && (1 < d.length || z || 1 < K.length);\n                    D = 0;\n                    var F = O(w);\n                    if (J) n = b.truncate(a, w, h, void 0, 0, Math.max(0, f - parseInt(E || 12, 10)), function (a, h) {\n                      return a.substring(0, h) + \"\\u2026\";\n                    });else if (r) for (; K.length;) {\n                      K.length && !L && 0 < D && (w = p.createElementNS(I, \"tspan\"), g(w, {\n                        dy: F,\n                        x: e\n                      }), q && g(w, \"style\", q), w.appendChild(p.createTextNode(K.join(\" \").replace(/- /g, \"-\"))), c.appendChild(w)), b.truncate(a, w, null, K, 0 === D ? x : 0, f, function (a, h) {\n                        return K.slice(0, h).join(\" \").replace(/- /g, \"-\");\n                      }), x = a.actualWidth, D++;\n                    }\n                  }\n\n                  l++;\n                }\n              }\n            });\n            C = C || c.childNodes.length;\n          }), J && n && a.attr(\"title\", m(a.textStr, [\"\\x26lt;\", \"\\x26gt;\"])), r && r.removeChild(c), q && a.applyTextOutline && a.applyTextOutline(q)) : c.appendChild(p.createTextNode(m(z)));\n        }\n      },\n      getContrast: function getContrast(a) {\n        a = u(a).rgba;\n        a[0] *= 1;\n        a[1] *= 1.2;\n        a[2] *= .5;\n        return 459 < a[0] + a[1] + a[2] ? \"#000000\" : \"#FFFFFF\";\n      },\n      button: function button(a, h, b, k, z, d, l, x, n) {\n        var e = this.label(a, h, b, n, null, null, null, null, \"button\"),\n            f = 0,\n            p = this.styledMode;\n        e.attr(c({\n          padding: 8,\n          r: 2\n        }, z));\n\n        if (!p) {\n          var q, I, D, J;\n          z = c({\n            fill: \"#f7f7f7\",\n            stroke: \"#cccccc\",\n            \"stroke-width\": 1,\n            style: {\n              color: \"#333333\",\n              cursor: \"pointer\",\n              fontWeight: \"normal\"\n            }\n          }, z);\n          q = z.style;\n          delete z.style;\n          d = c(z, {\n            fill: \"#e6e6e6\"\n          }, d);\n          I = d.style;\n          delete d.style;\n          l = c(z, {\n            fill: \"#e6ebf5\",\n            style: {\n              color: \"#000000\",\n              fontWeight: \"bold\"\n            }\n          }, l);\n          D = l.style;\n          delete l.style;\n          x = c(z, {\n            style: {\n              color: \"#cccccc\"\n            }\n          }, x);\n          J = x.style;\n          delete x.style;\n        }\n\n        G(e.element, w ? \"mouseover\" : \"mouseenter\", function () {\n          3 !== f && e.setState(1);\n        });\n        G(e.element, w ? \"mouseout\" : \"mouseleave\", function () {\n          3 !== f && e.setState(f);\n        });\n\n        e.setState = function (a) {\n          1 !== a && (e.state = f = a);\n          e.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass(\"highcharts-button-\" + [\"normal\", \"hover\", \"pressed\", \"disabled\"][a || 0]);\n          p || e.attr([z, d, l, x][a || 0]).css([q, I, D, J][a || 0]);\n        };\n\n        p || e.attr(z).css(r({\n          cursor: \"default\"\n        }, q));\n        return e.on(\"click\", function (a) {\n          3 !== f && k.call(e, a);\n        });\n      },\n      crispLine: function crispLine(a, h) {\n        a[1] === a[4] && (a[1] = a[4] = Math.round(a[1]) - h % 2 / 2);\n        a[2] === a[5] && (a[2] = a[5] = Math.round(a[2]) + h % 2 / 2);\n        return a;\n      },\n      path: function path(a) {\n        var h = this.styledMode ? {} : {\n          fill: \"none\"\n        };\n        n(a) ? h.d = a : E(a) && r(h, a);\n        return this.createElement(\"path\").attr(h);\n      },\n      circle: function circle(a, h, c) {\n        a = E(a) ? a : void 0 === a ? {} : {\n          x: a,\n          y: h,\n          r: c\n        };\n        h = this.createElement(\"circle\");\n\n        h.xSetter = h.ySetter = function (a, h, c) {\n          c.setAttribute(\"c\" + h, a);\n        };\n\n        return h.attr(a);\n      },\n      arc: function arc(a, h, c, b, k, z) {\n        E(a) ? (b = a, h = b.y, c = b.r, a = b.x) : b = {\n          innerR: b,\n          start: k,\n          end: z\n        };\n        a = this.symbol(\"arc\", a, h, c, c, b);\n        a.r = c;\n        return a;\n      },\n      rect: function rect(a, h, c, b, k, z) {\n        k = E(a) ? a.r : k;\n        var d = this.createElement(\"rect\");\n        a = E(a) ? a : void 0 === a ? {} : {\n          x: a,\n          y: h,\n          width: Math.max(c, 0),\n          height: Math.max(b, 0)\n        };\n        this.styledMode || (void 0 !== z && (a.strokeWidth = z, a = d.crisp(a)), a.fill = \"none\");\n        k && (a.r = k);\n\n        d.rSetter = function (a, h, c) {\n          g(c, {\n            rx: a,\n            ry: a\n          });\n        };\n\n        return d.attr(a);\n      },\n      setSize: function setSize(a, h, c) {\n        var b = this.alignedObjects,\n            k = b.length;\n        this.width = a;\n        this.height = h;\n\n        for (this.boxWrapper.animate({\n          width: a,\n          height: h\n        }, {\n          step: function step() {\n            this.attr({\n              viewBox: \"0 0 \" + this.attr(\"width\") + \" \" + this.attr(\"height\")\n            });\n          },\n          duration: D(c, !0) ? void 0 : 0\n        }); k--;) {\n          b[k].align();\n        }\n      },\n      g: function g(a) {\n        var h = this.createElement(\"g\");\n        return a ? h.attr({\n          \"class\": \"highcharts-\" + a\n        }) : h;\n      },\n      image: function image(a, h, c, b, k, z) {\n        var d = {\n          preserveAspectRatio: \"none\"\n        },\n            l,\n            x = function x(a, h) {\n          a.setAttributeNS ? a.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", h) : a.setAttribute(\"hc-svg-href\", h);\n        },\n            n = function n(h) {\n          x(l.element, a);\n          z.call(l, h);\n        };\n\n        1 < arguments.length && r(d, {\n          x: h,\n          y: c,\n          width: b,\n          height: k\n        });\n        l = this.createElement(\"image\").attr(d);\n        z ? (x(l.element, \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw\\x3d\\x3d\"), d = new R.Image(), G(d, \"load\", n), d.src = a, d.complete && n({})) : x(l.element, a);\n        return l;\n      },\n      symbol: function symbol(a, h, c, b, k, z) {\n        var d = this,\n            l,\n            x = /^url\\((.*?)\\)$/,\n            n = x.test(a),\n            e = !n && (this.symbols[a] ? a : \"circle\"),\n            f = e && this.symbols[e],\n            w = q(h) && f && f.call(this.symbols, Math.round(h), Math.round(c), b, k, z),\n            I,\n            J;\n        f ? (l = this.path(w), d.styledMode || l.attr(\"fill\", \"none\"), r(l, {\n          symbolName: e,\n          x: h,\n          y: c,\n          width: b,\n          height: k\n        }), z && r(l, z)) : n && (I = a.match(x)[1], l = this.image(I), l.imgwidth = D(O[I] && O[I].width, z && z.width), l.imgheight = D(O[I] && O[I].height, z && z.height), J = function J() {\n          l.attr({\n            width: l.width,\n            height: l.height\n          });\n        }, [\"width\", \"height\"].forEach(function (a) {\n          l[a + \"Setter\"] = function (a, h) {\n            var c = {},\n                b = this[\"img\" + h],\n                k = \"width\" === h ? \"translateX\" : \"translateY\";\n            this[h] = a;\n            q(b) && (this.element && this.element.setAttribute(h, b), this.alignByTranslate || (c[k] = ((this[h] || 0) - b) / 2, this.attr(c)));\n          };\n        }), q(h) && l.attr({\n          x: h,\n          y: c\n        }), l.isImg = !0, q(l.imgwidth) && q(l.imgheight) ? J() : (l.attr({\n          width: 0,\n          height: 0\n        }), y(\"img\", {\n          onload: function onload() {\n            var a = t[d.chartIndex];\n            0 === this.width && (v(this, {\n              position: \"absolute\",\n              top: \"-999em\"\n            }), p.body.appendChild(this));\n            O[I] = {\n              width: this.width,\n              height: this.height\n            };\n            l.imgwidth = this.width;\n            l.imgheight = this.height;\n            l.element && J();\n            this.parentNode && this.parentNode.removeChild(this);\n            d.imgCount--;\n            if (!d.imgCount && a && a.onload) a.onload();\n          },\n          src: I\n        }), this.imgCount++));\n        return l;\n      },\n      symbols: {\n        circle: function circle(a, h, c, b) {\n          return this.arc(a + c / 2, h + b / 2, c / 2, b / 2, {\n            start: 0,\n            end: 2 * Math.PI,\n            open: !1\n          });\n        },\n        square: function square(a, h, c, b) {\n          return [\"M\", a, h, \"L\", a + c, h, a + c, h + b, a, h + b, \"Z\"];\n        },\n        triangle: function triangle(a, h, c, b) {\n          return [\"M\", a + c / 2, h, \"L\", a + c, h + b, a, h + b, \"Z\"];\n        },\n        \"triangle-down\": function triangleDown(a, h, c, b) {\n          return [\"M\", a, h, \"L\", a + c, h, a + c / 2, h + b, \"Z\"];\n        },\n        diamond: function diamond(a, h, c, b) {\n          return [\"M\", a + c / 2, h, \"L\", a + c, h + b / 2, a + c / 2, h + b, a, h + b / 2, \"Z\"];\n        },\n        arc: function arc(a, h, c, b, k) {\n          var z = k.start,\n              d = k.r || c,\n              l = k.r || b || c,\n              x = k.end - .001;\n          c = k.innerR;\n          b = D(k.open, .001 > Math.abs(k.end - k.start - 2 * Math.PI));\n          var n = Math.cos(z),\n              e = Math.sin(z),\n              r = Math.cos(x),\n              x = Math.sin(x);\n          k = .001 > k.end - z - Math.PI ? 0 : 1;\n          d = [\"M\", a + d * n, h + l * e, \"A\", d, l, 0, k, 1, a + d * r, h + l * x];\n          q(c) && d.push(b ? \"M\" : \"L\", a + c * r, h + c * x, \"A\", c, c, 0, k, 0, a + c * n, h + c * e);\n          d.push(b ? \"\" : \"Z\");\n          return d;\n        },\n        callout: function callout(a, h, c, b, k) {\n          var z = Math.min(k && k.r || 0, c, b),\n              d = z + 6,\n              l = k && k.anchorX;\n          k = k && k.anchorY;\n          var x;\n          x = [\"M\", a + z, h, \"L\", a + c - z, h, \"C\", a + c, h, a + c, h, a + c, h + z, \"L\", a + c, h + b - z, \"C\", a + c, h + b, a + c, h + b, a + c - z, h + b, \"L\", a + z, h + b, \"C\", a, h + b, a, h + b, a, h + b - z, \"L\", a, h + z, \"C\", a, h, a, h, a + z, h];\n          l && l > c ? k > h + d && k < h + b - d ? x.splice(13, 3, \"L\", a + c, k - 6, a + c + 6, k, a + c, k + 6, a + c, h + b - z) : x.splice(13, 3, \"L\", a + c, b / 2, l, k, a + c, b / 2, a + c, h + b - z) : l && 0 > l ? k > h + d && k < h + b - d ? x.splice(33, 3, \"L\", a, k + 6, a - 6, k, a, k - 6, a, h + z) : x.splice(33, 3, \"L\", a, b / 2, l, k, a, b / 2, a, h + z) : k && k > b && l > a + d && l < a + c - d ? x.splice(23, 3, \"L\", l + 6, h + b, l, h + b + 6, l - 6, h + b, a + z, h + b) : k && 0 > k && l > a + d && l < a + c - d && x.splice(3, 3, \"L\", l - 6, h, l, h - 6, l + 6, h, c - z, h);\n          return x;\n        }\n      },\n      clipRect: function clipRect(h, c, b, k) {\n        var z = a.uniqueKey(),\n            l = this.createElement(\"clipPath\").attr({\n          id: z\n        }).add(this.defs);\n        h = this.rect(h, c, b, k, 0).add(l);\n        h.id = z;\n        h.clipPath = l;\n        h.count = 0;\n        return h;\n      },\n      text: function text(a, h, c, b) {\n        var k = {};\n        if (b && (this.allowHTML || !this.forExport)) return this.html(a, h, c);\n        k.x = Math.round(h || 0);\n        c && (k.y = Math.round(c));\n        q(a) && (k.text = a);\n        a = this.createElement(\"text\").attr(k);\n        b || (a.xSetter = function (a, h, c) {\n          var b = c.getElementsByTagName(\"tspan\"),\n              k,\n              z = c.getAttribute(h),\n              l;\n\n          for (l = 0; l < b.length; l++) {\n            k = b[l], k.getAttribute(h) === z && k.setAttribute(h, a);\n          }\n\n          c.setAttribute(h, a);\n        });\n        return a;\n      },\n      fontMetrics: function fontMetrics(a, c) {\n        a = !this.styledMode && /px/.test(a) || !R.getComputedStyle ? a || c && c.style && c.style.fontSize || this.style && this.style.fontSize : c && B.prototype.getStyle.call(c, \"font-size\");\n        a = /px/.test(a) ? h(a) : 12;\n        c = 24 > a ? a + 3 : Math.round(1.2 * a);\n        return {\n          h: c,\n          b: Math.round(.8 * c),\n          f: a\n        };\n      },\n      rotCorr: function rotCorr(a, h, c) {\n        var b = a;\n        h && c && (b = Math.max(b * Math.cos(h * f), 4));\n        return {\n          x: -a / 3 * Math.sin(h * f),\n          y: b\n        };\n      },\n      label: function label(h, b, k, l, d, x, n, e, f) {\n        var w = this,\n            p = w.styledMode,\n            I = w.g(\"button\" !== f && \"label\"),\n            D = I.text = w.text(\"\", 0, 0, n).attr({\n          zIndex: 1\n        }),\n            J,\n            L,\n            E = 0,\n            g = 3,\n            C = 0,\n            F,\n            W,\n            O,\n            m,\n            y,\n            R = {},\n            v,\n            t,\n            K = /^url\\((.*?)\\)$/.test(l),\n            u = p || K,\n            S = function S() {\n          return p ? J.strokeWidth() % 2 / 2 : (v ? parseInt(v, 10) : 0) % 2 / 2;\n        },\n            aa,\n            A,\n            T;\n\n        f && I.addClass(\"highcharts-\" + f);\n\n        aa = function aa() {\n          var a = D.element.style,\n              h = {};\n          L = (void 0 === F || void 0 === W || y) && q(D.textStr) && D.getBBox();\n          I.width = (F || L.width || 0) + 2 * g + C;\n          I.height = (W || L.height || 0) + 2 * g;\n          t = g + Math.min(w.fontMetrics(a && a.fontSize, D).b, L ? L.height : Infinity);\n          u && (J || (I.box = J = w.symbols[l] || K ? w.symbol(l) : w.rect(), J.addClass((\"button\" === f ? \"\" : \"highcharts-label-box\") + (f ? \" highcharts-\" + f + \"-box\" : \"\")), J.add(I), a = S(), h.x = a, h.y = (e ? -t : 0) + a), h.width = Math.round(I.width), h.height = Math.round(I.height), J.attr(r(h, R)), R = {});\n        };\n\n        A = function A() {\n          var a = C + g,\n              h;\n          h = e ? 0 : t;\n          q(F) && L && (\"center\" === y || \"right\" === y) && (a += {\n            center: .5,\n            right: 1\n          }[y] * (F - L.width));\n          if (a !== D.x || h !== D.y) D.attr(\"x\", a), D.hasBoxWidthChanged && (L = D.getBBox(!0), aa()), void 0 !== h && D.attr(\"y\", h);\n          D.x = a;\n          D.y = h;\n        };\n\n        T = function T(a, h) {\n          J ? J.attr(a, h) : R[a] = h;\n        };\n\n        I.onAdd = function () {\n          D.add(I);\n          I.attr({\n            text: h || 0 === h ? h : \"\",\n            x: b,\n            y: k\n          });\n          J && q(d) && I.attr({\n            anchorX: d,\n            anchorY: x\n          });\n        };\n\n        I.widthSetter = function (h) {\n          F = a.isNumber(h) ? h : null;\n        };\n\n        I.heightSetter = function (a) {\n          W = a;\n        };\n\n        I[\"text-alignSetter\"] = function (a) {\n          y = a;\n        };\n\n        I.paddingSetter = function (a) {\n          q(a) && a !== g && (g = I.padding = a, A());\n        };\n\n        I.paddingLeftSetter = function (a) {\n          q(a) && a !== C && (C = a, A());\n        };\n\n        I.alignSetter = function (a) {\n          a = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[a];\n          a !== E && (E = a, L && I.attr({\n            x: O\n          }));\n        };\n\n        I.textSetter = function (a) {\n          void 0 !== a && D.textSetter(a);\n          aa();\n          A();\n        };\n\n        I[\"stroke-widthSetter\"] = function (a, h) {\n          a && (u = !0);\n          v = this[\"stroke-width\"] = a;\n          T(h, a);\n        };\n\n        p ? I.rSetter = function (a, h) {\n          T(h, a);\n        } : I.strokeSetter = I.fillSetter = I.rSetter = function (a, h) {\n          \"r\" !== h && (\"fill\" === h && a && (u = !0), I[h] = a);\n          T(h, a);\n        };\n\n        I.anchorXSetter = function (a, h) {\n          d = I.anchorX = a;\n          T(h, Math.round(a) - S() - O);\n        };\n\n        I.anchorYSetter = function (a, h) {\n          x = I.anchorY = a;\n          T(h, a - m);\n        };\n\n        I.xSetter = function (a) {\n          I.x = a;\n          E && (a -= E * ((F || L.width) + 2 * g), I[\"forceAnimate:x\"] = !0);\n          O = Math.round(a);\n          I.attr(\"translateX\", O);\n        };\n\n        I.ySetter = function (a) {\n          m = I.y = Math.round(a);\n          I.attr(\"translateY\", m);\n        };\n\n        var P = I.css;\n        n = {\n          css: function css(a) {\n            if (a) {\n              var h = {};\n              a = c(a);\n              I.textProps.forEach(function (c) {\n                void 0 !== a[c] && (h[c] = a[c], delete a[c]);\n              });\n              D.css(h);\n              \"width\" in h && aa();\n              \"fontSize\" in h && (aa(), A());\n            }\n\n            return P.call(I, a);\n          },\n          getBBox: function getBBox() {\n            return {\n              width: L.width + 2 * g,\n              height: L.height + 2 * g,\n              x: L.x - g,\n              y: L.y - g\n            };\n          },\n          destroy: function destroy() {\n            z(I.element, \"mouseenter\");\n            z(I.element, \"mouseleave\");\n            D && (D = D.destroy());\n            J && (J = J.destroy());\n            B.prototype.destroy.call(I);\n            I = w = aa = A = T = null;\n          }\n        };\n        p || (n.shadow = function (a) {\n          a && (aa(), J && J.shadow(a));\n          return I;\n        });\n        return r(I, n);\n      }\n    });\n    a.Renderer = A;\n  })(H);\n\n  (function (a) {\n    var B = a.attr,\n        A = a.createElement,\n        G = a.css,\n        m = a.defined,\n        g = a.extend,\n        t = a.isFirefox,\n        u = a.isMS,\n        v = a.isWebKit,\n        y = a.pick,\n        q = a.pInt,\n        f = a.SVGElement,\n        e = a.SVGRenderer,\n        p = a.win;\n    g(f.prototype, {\n      htmlCss: function htmlCss(a) {\n        var b = \"SPAN\" === this.element.tagName && a && \"width\" in a,\n            l = y(b && a.width, void 0),\n            n;\n        b && (delete a.width, this.textWidth = l, n = !0);\n        a && \"ellipsis\" === a.textOverflow && (a.whiteSpace = \"nowrap\", a.overflow = \"hidden\");\n        this.styles = g(this.styles, a);\n        G(this.element, a);\n        n && this.htmlUpdateTransform();\n        return this;\n      },\n      htmlGetBBox: function htmlGetBBox() {\n        var a = this.element;\n        return {\n          x: a.offsetLeft,\n          y: a.offsetTop,\n          width: a.offsetWidth,\n          height: a.offsetHeight\n        };\n      },\n      htmlUpdateTransform: function htmlUpdateTransform() {\n        if (this.added) {\n          var a = this.renderer,\n              b = this.element,\n              l = this.translateX || 0,\n              n = this.translateY || 0,\n              d = this.x || 0,\n              e = this.y || 0,\n              f = this.textAlign || \"left\",\n              p = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[f],\n              g = this.styles,\n              c = g && g.whiteSpace;\n          G(b, {\n            marginLeft: l,\n            marginTop: n\n          });\n          !a.styledMode && this.shadows && this.shadows.forEach(function (a) {\n            G(a, {\n              marginLeft: l + 1,\n              marginTop: n + 1\n            });\n          });\n          this.inverted && [].forEach.call(b.childNodes, function (h) {\n            a.invertChild(h, b);\n          });\n\n          if (\"SPAN\" === b.tagName) {\n            var g = this.rotation,\n                k = this.textWidth && q(this.textWidth),\n                x = [g, f, b.innerHTML, this.textWidth, this.textAlign].join(),\n                D;\n            (D = k !== this.oldTextWidth) && !(D = k > this.oldTextWidth) && ((D = this.textPxLength) || (G(b, {\n              width: \"\",\n              whiteSpace: c || \"nowrap\"\n            }), D = b.offsetWidth), D = D > k);\n            D && (/[ \\-]/.test(b.textContent || b.innerText) || \"ellipsis\" === b.style.textOverflow) ? (G(b, {\n              width: k + \"px\",\n              display: \"block\",\n              whiteSpace: c || \"normal\"\n            }), this.oldTextWidth = k, this.hasBoxWidthChanged = !0) : this.hasBoxWidthChanged = !1;\n            x !== this.cTT && (c = a.fontMetrics(b.style.fontSize, b).b, !m(g) || g === (this.oldRotation || 0) && f === this.oldAlign || this.setSpanRotation(g, p, c), this.getSpanCorrection(!m(g) && this.textPxLength || b.offsetWidth, c, p, g, f));\n            G(b, {\n              left: d + (this.xCorr || 0) + \"px\",\n              top: e + (this.yCorr || 0) + \"px\"\n            });\n            this.cTT = x;\n            this.oldRotation = g;\n            this.oldAlign = f;\n          }\n        } else this.alignOnAdd = !0;\n      },\n      setSpanRotation: function setSpanRotation(a, b, l) {\n        var n = {},\n            d = this.renderer.getTransformKey();\n        n[d] = n.transform = \"rotate(\" + a + \"deg)\";\n        n[d + (t ? \"Origin\" : \"-origin\")] = n.transformOrigin = 100 * b + \"% \" + l + \"px\";\n        G(this.element, n);\n      },\n      getSpanCorrection: function getSpanCorrection(a, b, l) {\n        this.xCorr = -a * l;\n        this.yCorr = -b;\n      }\n    });\n    g(e.prototype, {\n      getTransformKey: function getTransformKey() {\n        return u && !/Edge/.test(p.navigator.userAgent) ? \"-ms-transform\" : v ? \"-webkit-transform\" : t ? \"MozTransform\" : p.opera ? \"-o-transform\" : \"\";\n      },\n      html: function html(e, b, l) {\n        var n = this.createElement(\"span\"),\n            d = n.element,\n            w = n.renderer,\n            r = w.isSVG,\n            p = function p(a, b) {\n          [\"opacity\", \"visibility\"].forEach(function (c) {\n            a[c + \"Setter\"] = function (a, h, k) {\n              f.prototype[c + \"Setter\"].call(this, a, h, k);\n              b[h] = a;\n            };\n          });\n          a.addedSetters = !0;\n        },\n            q = a.charts[w.chartIndex],\n            q = q && q.styledMode;\n\n        n.textSetter = function (a) {\n          a !== d.innerHTML && delete this.bBox;\n          this.textStr = a;\n          d.innerHTML = y(a, \"\");\n          n.doTransform = !0;\n        };\n\n        r && p(n, n.element.style);\n\n        n.xSetter = n.ySetter = n.alignSetter = n.rotationSetter = function (a, b) {\n          \"align\" === b && (b = \"textAlign\");\n          n[b] = a;\n          n.doTransform = !0;\n        };\n\n        n.afterSetters = function () {\n          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);\n        };\n\n        n.attr({\n          text: e,\n          x: Math.round(b),\n          y: Math.round(l)\n        }).css({\n          position: \"absolute\"\n        });\n        q || n.css({\n          fontFamily: this.style.fontFamily,\n          fontSize: this.style.fontSize\n        });\n        d.style.whiteSpace = \"nowrap\";\n        n.css = n.htmlCss;\n        r && (n.add = function (a) {\n          var c,\n              b = w.box.parentNode,\n              l = [];\n\n          if (this.parentGroup = a) {\n            if (c = a.div, !c) {\n              for (; a;) {\n                l.push(a), a = a.parentGroup;\n              }\n\n              l.reverse().forEach(function (a) {\n                function h(h, c) {\n                  a[c] = h;\n                  \"translateX\" === c ? k.left = h + \"px\" : k.top = h + \"px\";\n                  a.doTransform = !0;\n                }\n\n                var k,\n                    d = B(a.element, \"class\");\n                d && (d = {\n                  className: d\n                });\n                c = a.div = a.div || A(\"div\", d, {\n                  position: \"absolute\",\n                  left: (a.translateX || 0) + \"px\",\n                  top: (a.translateY || 0) + \"px\",\n                  display: a.display,\n                  opacity: a.opacity,\n                  pointerEvents: a.styles && a.styles.pointerEvents\n                }, c || b);\n                k = c.style;\n                g(a, {\n                  classSetter: function (a) {\n                    return function (h) {\n                      this.element.setAttribute(\"class\", h);\n                      a.className = h;\n                    };\n                  }(c),\n                  on: function on() {\n                    l[0].div && n.on.apply({\n                      element: l[0].div\n                    }, arguments);\n                    return a;\n                  },\n                  translateXSetter: h,\n                  translateYSetter: h\n                });\n                a.addedSetters || p(a, k);\n              });\n            }\n          } else c = b;\n\n          c.appendChild(d);\n          n.added = !0;\n          n.alignOnAdd && n.htmlUpdateTransform();\n          return n;\n        });\n        return n;\n      }\n    });\n  })(H);\n\n  (function (a) {\n    var B = a.defined,\n        A = a.extend,\n        G = a.merge,\n        m = a.pick,\n        g = a.timeUnits,\n        t = a.win;\n\n    a.Time = function (a) {\n      this.update(a, !1);\n    };\n\n    a.Time.prototype = {\n      defaultOptions: {},\n      update: function update(a) {\n        var g = m(a && a.useUTC, !0),\n            y = this;\n        this.options = a = G(!0, this.options || {}, a);\n        this.Date = a.Date || t.Date || Date;\n        this.timezoneOffset = (this.useUTC = g) && a.timezoneOffset;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        (this.variableTimezone = !(g && !a.getTimezoneOffset && !a.timezone)) || this.timezoneOffset ? (this.get = function (a, f) {\n          var e = f.getTime(),\n              p = e - y.getTimezoneOffset(f);\n          f.setTime(p);\n          a = f[\"getUTC\" + a]();\n          f.setTime(e);\n          return a;\n        }, this.set = function (a, f, e) {\n          var p;\n          if (\"Milliseconds\" === a || \"Seconds\" === a || \"Minutes\" === a && 0 === f.getTimezoneOffset() % 60) f[\"set\" + a](e);else p = y.getTimezoneOffset(f), p = f.getTime() - p, f.setTime(p), f[\"setUTC\" + a](e), a = y.getTimezoneOffset(f), p = f.getTime() + a, f.setTime(p);\n        }) : g ? (this.get = function (a, f) {\n          return f[\"getUTC\" + a]();\n        }, this.set = function (a, f, e) {\n          return f[\"setUTC\" + a](e);\n        }) : (this.get = function (a, f) {\n          return f[\"get\" + a]();\n        }, this.set = function (a, f, e) {\n          return f[\"set\" + a](e);\n        });\n      },\n      makeTime: function makeTime(g, t, y, q, f, e) {\n        var p, r, b;\n        this.useUTC ? (p = this.Date.UTC.apply(0, arguments), r = this.getTimezoneOffset(p), p += r, b = this.getTimezoneOffset(p), r !== b ? p += b - r : r - 36E5 !== this.getTimezoneOffset(p - 36E5) || a.isSafari || (p -= 36E5)) : p = new this.Date(g, t, m(y, 1), m(q, 0), m(f, 0), m(e, 0)).getTime();\n        return p;\n      },\n      timezoneOffsetFunction: function timezoneOffsetFunction() {\n        var g = this,\n            m = this.options,\n            y = t.moment;\n        if (!this.useUTC) return function (a) {\n          return 6E4 * new Date(a).getTimezoneOffset();\n        };\n\n        if (m.timezone) {\n          if (y) return function (a) {\n            return 6E4 * -y.tz(a, m.timezone).utcOffset();\n          };\n          a.error(25);\n        }\n\n        return this.useUTC && m.getTimezoneOffset ? function (a) {\n          return 6E4 * m.getTimezoneOffset(a);\n        } : function () {\n          return 6E4 * (g.timezoneOffset || 0);\n        };\n      },\n      dateFormat: function dateFormat(g, m, y) {\n        if (!a.defined(m) || isNaN(m)) return a.defaultOptions.lang.invalidDate || \"\";\n        g = a.pick(g, \"%Y-%m-%d %H:%M:%S\");\n        var q = this,\n            f = new this.Date(m),\n            e = this.get(\"Hours\", f),\n            p = this.get(\"Day\", f),\n            r = this.get(\"Date\", f),\n            b = this.get(\"Month\", f),\n            l = this.get(\"FullYear\", f),\n            n = a.defaultOptions.lang,\n            d = n.weekdays,\n            w = n.shortWeekdays,\n            E = a.pad,\n            f = a.extend({\n          a: w ? w[p] : d[p].substr(0, 3),\n          A: d[p],\n          d: E(r),\n          e: E(r, 2, \" \"),\n          w: p,\n          b: n.shortMonths[b],\n          B: n.months[b],\n          m: E(b + 1),\n          o: b + 1,\n          y: l.toString().substr(2, 2),\n          Y: l,\n          H: E(e),\n          k: e,\n          I: E(e % 12 || 12),\n          l: e % 12 || 12,\n          M: E(q.get(\"Minutes\", f)),\n          p: 12 > e ? \"AM\" : \"PM\",\n          P: 12 > e ? \"am\" : \"pm\",\n          S: E(f.getSeconds()),\n          L: E(Math.floor(m % 1E3), 3)\n        }, a.dateFormats);\n        a.objectEach(f, function (a, b) {\n          for (; -1 !== g.indexOf(\"%\" + b);) {\n            g = g.replace(\"%\" + b, \"function\" === typeof a ? a.call(q, m) : a);\n          }\n        });\n        return y ? g.substr(0, 1).toUpperCase() + g.substr(1) : g;\n      },\n      resolveDTLFormat: function resolveDTLFormat(g) {\n        return a.isObject(g, !0) ? g : (g = a.splat(g), {\n          main: g[0],\n          from: g[1],\n          to: g[2]\n        });\n      },\n      getTimeTicks: function getTimeTicks(a, t, y, q) {\n        var f = this,\n            e = [],\n            p,\n            r = {},\n            b;\n        p = new f.Date(t);\n        var l = a.unitRange,\n            n = a.count || 1,\n            d;\n        q = m(q, 1);\n\n        if (B(t)) {\n          f.set(\"Milliseconds\", p, l >= g.second ? 0 : n * Math.floor(f.get(\"Milliseconds\", p) / n));\n          l >= g.second && f.set(\"Seconds\", p, l >= g.minute ? 0 : n * Math.floor(f.get(\"Seconds\", p) / n));\n          l >= g.minute && f.set(\"Minutes\", p, l >= g.hour ? 0 : n * Math.floor(f.get(\"Minutes\", p) / n));\n          l >= g.hour && f.set(\"Hours\", p, l >= g.day ? 0 : n * Math.floor(f.get(\"Hours\", p) / n));\n          l >= g.day && f.set(\"Date\", p, l >= g.month ? 1 : Math.max(1, n * Math.floor(f.get(\"Date\", p) / n)));\n          l >= g.month && (f.set(\"Month\", p, l >= g.year ? 0 : n * Math.floor(f.get(\"Month\", p) / n)), b = f.get(\"FullYear\", p));\n          l >= g.year && f.set(\"FullYear\", p, b - b % n);\n          l === g.week && (b = f.get(\"Day\", p), f.set(\"Date\", p, f.get(\"Date\", p) - b + q + (b < q ? -7 : 0)));\n          b = f.get(\"FullYear\", p);\n          q = f.get(\"Month\", p);\n          var w = f.get(\"Date\", p),\n              E = f.get(\"Hours\", p);\n          t = p.getTime();\n          f.variableTimezone && (d = y - t > 4 * g.month || f.getTimezoneOffset(t) !== f.getTimezoneOffset(y));\n          t = p.getTime();\n\n          for (p = 1; t < y;) {\n            e.push(t), t = l === g.year ? f.makeTime(b + p * n, 0) : l === g.month ? f.makeTime(b, q + p * n) : !d || l !== g.day && l !== g.week ? d && l === g.hour && 1 < n ? f.makeTime(b, q, w, E + p * n) : t + l * n : f.makeTime(b, q, w + p * n * (l === g.day ? 1 : 7)), p++;\n          }\n\n          e.push(t);\n          l <= g.hour && 1E4 > e.length && e.forEach(function (a) {\n            0 === a % 18E5 && \"000000000\" === f.dateFormat(\"%H%M%S%L\", a) && (r[a] = \"day\");\n          });\n        }\n\n        e.info = A(a, {\n          higherRanks: r,\n          totalRange: l * n\n        });\n        return e;\n      }\n    };\n  })(H);\n\n  (function (a) {\n    var B = a.color,\n        A = a.merge;\n    a.defaultOptions = {\n      colors: \"#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1\".split(\" \"),\n      symbols: [\"circle\", \"diamond\", \"square\", \"triangle\", \"triangle-down\"],\n      lang: {\n        loading: \"Loading...\",\n        months: \"January February March April May June July August September October November December\".split(\" \"),\n        shortMonths: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),\n        weekdays: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n        decimalPoint: \".\",\n        numericSymbols: \"kMGTPE\".split(\"\"),\n        resetZoom: \"Reset zoom\",\n        resetZoomTitle: \"Reset zoom level 1:1\",\n        thousandsSep: \" \"\n      },\n      global: {},\n      time: a.Time.prototype.defaultOptions,\n      chart: {\n        styledMode: !1,\n        borderRadius: 0,\n        colorCount: 10,\n        defaultSeriesType: \"line\",\n        ignoreHiddenSeries: !0,\n        spacing: [10, 10, 15, 10],\n        resetZoomButton: {\n          theme: {\n            zIndex: 6\n          },\n          position: {\n            align: \"right\",\n            x: -10,\n            y: 10\n          }\n        },\n        width: null,\n        height: null,\n        borderColor: \"#335cad\",\n        backgroundColor: \"#ffffff\",\n        plotBorderColor: \"#cccccc\"\n      },\n      title: {\n        text: \"Chart title\",\n        align: \"center\",\n        margin: 15,\n        widthAdjust: -44\n      },\n      subtitle: {\n        text: \"\",\n        align: \"center\",\n        widthAdjust: -44\n      },\n      plotOptions: {},\n      labels: {\n        style: {\n          position: \"absolute\",\n          color: \"#333333\"\n        }\n      },\n      legend: {\n        enabled: !0,\n        align: \"center\",\n        alignColumns: !0,\n        layout: \"horizontal\",\n        labelFormatter: function labelFormatter() {\n          return this.name;\n        },\n        borderColor: \"#999999\",\n        borderRadius: 0,\n        navigation: {\n          activeColor: \"#003399\",\n          inactiveColor: \"#cccccc\"\n        },\n        itemStyle: {\n          color: \"#333333\",\n          cursor: \"pointer\",\n          fontSize: \"12px\",\n          fontWeight: \"bold\",\n          textOverflow: \"ellipsis\"\n        },\n        itemHoverStyle: {\n          color: \"#000000\"\n        },\n        itemHiddenStyle: {\n          color: \"#cccccc\"\n        },\n        shadow: !1,\n        itemCheckboxStyle: {\n          position: \"absolute\",\n          width: \"13px\",\n          height: \"13px\"\n        },\n        squareSymbol: !0,\n        symbolPadding: 5,\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0,\n        title: {\n          style: {\n            fontWeight: \"bold\"\n          }\n        }\n      },\n      loading: {\n        labelStyle: {\n          fontWeight: \"bold\",\n          position: \"relative\",\n          top: \"45%\"\n        },\n        style: {\n          position: \"absolute\",\n          backgroundColor: \"#ffffff\",\n          opacity: .5,\n          textAlign: \"center\"\n        }\n      },\n      tooltip: {\n        enabled: !0,\n        animation: a.svg,\n        borderRadius: 3,\n        dateTimeLabelFormats: {\n          millisecond: \"%A, %b %e, %H:%M:%S.%L\",\n          second: \"%A, %b %e, %H:%M:%S\",\n          minute: \"%A, %b %e, %H:%M\",\n          hour: \"%A, %b %e, %H:%M\",\n          day: \"%A, %b %e, %Y\",\n          week: \"Week from %A, %b %e, %Y\",\n          month: \"%B %Y\",\n          year: \"%Y\"\n        },\n        footerFormat: \"\",\n        padding: 8,\n        snap: a.isTouchDevice ? 25 : 10,\n        headerFormat: '\\x3cspan style\\x3d\"font-size: 10px\"\\x3e{point.key}\\x3c/span\\x3e\\x3cbr/\\x3e',\n        pointFormat: \"<span style=\\\"color:{point.color}\\\">\\u25CF</span> {series.name}: <b>{point.y}</b><br/>\",\n        backgroundColor: B(\"#f7f7f7\").setOpacity(.85).get(),\n        borderWidth: 1,\n        shadow: !0,\n        style: {\n          color: \"#333333\",\n          cursor: \"default\",\n          fontSize: \"12px\",\n          pointerEvents: \"none\",\n          whiteSpace: \"nowrap\"\n        }\n      },\n      credits: {\n        enabled: !0,\n        href: \"https://www.highcharts.com?credits\",\n        position: {\n          align: \"right\",\n          x: -10,\n          verticalAlign: \"bottom\",\n          y: -5\n        },\n        style: {\n          cursor: \"pointer\",\n          color: \"#999999\",\n          fontSize: \"9px\"\n        },\n        text: \"Highcharts.com\"\n      }\n    };\n\n    a.setOptions = function (B) {\n      a.defaultOptions = A(!0, a.defaultOptions, B);\n      a.time.update(A(a.defaultOptions.global, a.defaultOptions.time), !1);\n      return a.defaultOptions;\n    };\n\n    a.getOptions = function () {\n      return a.defaultOptions;\n    };\n\n    a.defaultPlotOptions = a.defaultOptions.plotOptions;\n    a.time = new a.Time(A(a.defaultOptions.global, a.defaultOptions.time));\n\n    a.dateFormat = function (A, m, g) {\n      return a.time.dateFormat(A, m, g);\n    };\n  })(H);\n\n  (function (a) {\n    var B = a.correctFloat,\n        A = a.defined,\n        G = a.destroyObjectProperties,\n        m = a.fireEvent,\n        g = a.isNumber,\n        t = a.merge,\n        u = a.pick,\n        v = a.deg2rad;\n\n    a.Tick = function (a, q, f, e, p) {\n      this.axis = a;\n      this.pos = q;\n      this.type = f || \"\";\n      this.isNewLabel = this.isNew = !0;\n      this.parameters = p || {};\n      this.tickmarkOffset = this.parameters.tickmarkOffset;\n      this.options = this.parameters.options;\n      f || e || this.addLabel();\n    };\n\n    a.Tick.prototype = {\n      addLabel: function addLabel() {\n        var g = this,\n            q = g.axis,\n            f = q.options,\n            e = q.chart,\n            p = q.categories,\n            r = q.names,\n            b = g.pos,\n            l = u(g.options && g.options.labels, f.labels),\n            n = q.tickPositions,\n            d = b === n[0],\n            w = b === n[n.length - 1],\n            p = this.parameters.category || (p ? u(p[b], r[b], b) : b),\n            E = g.label,\n            n = n.info,\n            C,\n            F,\n            c,\n            k;\n        q.isDatetimeAxis && n && (F = e.time.resolveDTLFormat(f.dateTimeLabelFormats[!f.grid && n.higherRanks[b] || n.unitName]), C = F.main);\n        g.isFirst = d;\n        g.isLast = w;\n        g.formatCtx = {\n          axis: q,\n          chart: e,\n          isFirst: d,\n          isLast: w,\n          dateTimeLabelFormat: C,\n          tickPositionInfo: n,\n          value: q.isLog ? B(q.lin2log(p)) : p,\n          pos: b\n        };\n        f = q.labelFormatter.call(g.formatCtx, this.formatCtx);\n        if (k = F && F.list) g.shortenLabel = function () {\n          for (c = 0; c < k.length; c++) {\n            if (E.attr({\n              text: q.labelFormatter.call(a.extend(g.formatCtx, {\n                dateTimeLabelFormat: k[c]\n              }))\n            }), E.getBBox().width < q.getSlotWidth(g) - 2 * u(l.padding, 5)) return;\n          }\n\n          E.attr({\n            text: \"\"\n          });\n        };\n        if (A(E)) E && E.textStr !== f && (!E.textWidth || l.style && l.style.width || E.styles.width || E.css({\n          width: null\n        }), E.attr({\n          text: f\n        }));else {\n          if (g.label = E = A(f) && l.enabled ? e.renderer.text(f, 0, 0, l.useHTML).add(q.labelGroup) : null) e.styledMode || E.css(t(l.style)), E.textPxLength = E.getBBox().width;\n          g.rotation = 0;\n        }\n      },\n      getLabelSize: function getLabelSize() {\n        return this.label ? this.label.getBBox()[this.axis.horiz ? \"height\" : \"width\"] : 0;\n      },\n      handleOverflow: function handleOverflow(a) {\n        var q = this.axis,\n            f = q.options.labels,\n            e = a.x,\n            p = q.chart.chartWidth,\n            r = q.chart.spacing,\n            b = u(q.labelLeft, Math.min(q.pos, r[3])),\n            r = u(q.labelRight, Math.max(q.isRadial ? 0 : q.pos + q.len, p - r[1])),\n            l = this.label,\n            n = this.rotation,\n            d = {\n          left: 0,\n          center: .5,\n          right: 1\n        }[q.labelAlign || l.attr(\"align\")],\n            w = l.getBBox().width,\n            g = q.getSlotWidth(this),\n            C = g,\n            F = 1,\n            c,\n            k = {};\n        if (n || \"justify\" !== u(f.overflow, \"justify\")) 0 > n && e - d * w < b ? c = Math.round(e / Math.cos(n * v) - b) : 0 < n && e + d * w > r && (c = Math.round((p - e) / Math.cos(n * v)));else if (p = e + (1 - d) * w, e - d * w < b ? C = a.x + C * (1 - d) - b : p > r && (C = r - a.x + C * d, F = -1), C = Math.min(g, C), C < g && \"center\" === q.labelAlign && (a.x += F * (g - C - d * (g - Math.min(w, C)))), w > C || q.autoRotation && (l.styles || {}).width) c = C;\n        c && (this.shortenLabel ? this.shortenLabel() : (k.width = Math.floor(c), (f.style || {}).textOverflow || (k.textOverflow = \"ellipsis\"), l.css(k)));\n      },\n      getPosition: function getPosition(g, q, f, e) {\n        var p = this.axis,\n            r = p.chart,\n            b = e && r.oldChartHeight || r.chartHeight;\n        g = {\n          x: g ? a.correctFloat(p.translate(q + f, null, null, e) + p.transB) : p.left + p.offset + (p.opposite ? (e && r.oldChartWidth || r.chartWidth) - p.right - p.left : 0),\n          y: g ? b - p.bottom + p.offset - (p.opposite ? p.height : 0) : a.correctFloat(b - p.translate(q + f, null, null, e) - p.transB)\n        };\n        m(this, \"afterGetPosition\", {\n          pos: g\n        });\n        return g;\n      },\n      getLabelPosition: function getLabelPosition(a, q, f, e, p, r, b, l) {\n        var n = this.axis,\n            d = n.transA,\n            w = n.reversed,\n            g = n.staggerLines,\n            C = n.tickRotCorr || {\n          x: 0,\n          y: 0\n        },\n            F = p.y,\n            c = e || n.reserveSpaceDefault ? 0 : -n.labelOffset * (\"center\" === n.labelAlign ? .5 : 1),\n            k = {};\n        A(F) || (F = 0 === n.side ? f.rotation ? -8 : -f.getBBox().height : 2 === n.side ? C.y + 8 : Math.cos(f.rotation * v) * (C.y - f.getBBox(!1, 0).height / 2));\n        a = a + p.x + c + C.x - (r && e ? r * d * (w ? -1 : 1) : 0);\n        q = q + F - (r && !e ? r * d * (w ? 1 : -1) : 0);\n        g && (f = b / (l || 1) % g, n.opposite && (f = g - f - 1), q += n.labelOffset / g * f);\n        k.x = a;\n        k.y = Math.round(q);\n        m(this, \"afterGetLabelPosition\", {\n          pos: k,\n          tickmarkOffset: r,\n          index: b\n        });\n        return k;\n      },\n      getMarkPath: function getMarkPath(a, q, f, e, p, r) {\n        return r.crispLine([\"M\", a, q, \"L\", a + (p ? 0 : -f), q + (p ? f : 0)], e);\n      },\n      renderGridLine: function renderGridLine(a, q, f) {\n        var e = this.axis,\n            p = e.options,\n            r = this.gridLine,\n            b = {},\n            l = this.pos,\n            n = this.type,\n            d = u(this.tickmarkOffset, e.tickmarkOffset),\n            w = e.chart.renderer,\n            g = n ? n + \"Grid\" : \"grid\",\n            C = p[g + \"LineWidth\"],\n            F = p[g + \"LineColor\"],\n            p = p[g + \"LineDashStyle\"];\n        r || (e.chart.styledMode || (b.stroke = F, b[\"stroke-width\"] = C, p && (b.dashstyle = p)), n || (b.zIndex = 1), a && (q = 0), this.gridLine = r = w.path().attr(b).addClass(\"highcharts-\" + (n ? n + \"-\" : \"\") + \"grid-line\").add(e.gridGroup));\n        if (r && (f = e.getPlotLinePath(l + d, r.strokeWidth() * f, a, \"pass\"))) r[a || this.isNew ? \"attr\" : \"animate\"]({\n          d: f,\n          opacity: q\n        });\n      },\n      renderMark: function renderMark(a, q, f) {\n        var e = this.axis,\n            p = e.options,\n            r = e.chart.renderer,\n            b = this.type,\n            l = b ? b + \"Tick\" : \"tick\",\n            n = e.tickSize(l),\n            d = this.mark,\n            w = !d,\n            g = a.x;\n        a = a.y;\n        var C = u(p[l + \"Width\"], !b && e.isXAxis ? 1 : 0),\n            p = p[l + \"Color\"];\n        n && (e.opposite && (n[0] = -n[0]), w && (this.mark = d = r.path().addClass(\"highcharts-\" + (b ? b + \"-\" : \"\") + \"tick\").add(e.axisGroup), e.chart.styledMode || d.attr({\n          stroke: p,\n          \"stroke-width\": C\n        })), d[w ? \"attr\" : \"animate\"]({\n          d: this.getMarkPath(g, a, n[0], d.strokeWidth() * f, e.horiz, r),\n          opacity: q\n        }));\n      },\n      renderLabel: function renderLabel(a, q, f, e) {\n        var p = this.axis,\n            r = p.horiz,\n            b = p.options,\n            l = this.label,\n            n = b.labels,\n            d = n.step,\n            p = u(this.tickmarkOffset, p.tickmarkOffset),\n            w = !0,\n            E = a.x;\n        a = a.y;\n        l && g(E) && (l.xy = a = this.getLabelPosition(E, a, l, r, n, p, e, d), this.isFirst && !this.isLast && !u(b.showFirstLabel, 1) || this.isLast && !this.isFirst && !u(b.showLastLabel, 1) ? w = !1 : !r || n.step || n.rotation || q || 0 === f || this.handleOverflow(a), d && e % d && (w = !1), w && g(a.y) ? (a.opacity = f, l[this.isNewLabel ? \"attr\" : \"animate\"](a), this.isNewLabel = !1) : (l.attr(\"y\", -9999), this.isNewLabel = !0));\n      },\n      render: function render(g, q, f) {\n        var e = this.axis,\n            p = e.horiz,\n            r = this.pos,\n            b = u(this.tickmarkOffset, e.tickmarkOffset),\n            r = this.getPosition(p, r, b, q),\n            b = r.x,\n            l = r.y,\n            e = p && b === e.pos + e.len || !p && l === e.pos ? -1 : 1;\n        f = u(f, 1);\n        this.isActive = !0;\n        this.renderGridLine(q, f, e);\n        this.renderMark(r, f, e);\n        this.renderLabel(r, q, f, g);\n        this.isNew = !1;\n        a.fireEvent(this, \"afterRender\");\n      },\n      destroy: function destroy() {\n        G(this, this.axis);\n      }\n    };\n  })(H);\n\n  var da = function (a) {\n    var B = a.addEvent,\n        A = a.animObject,\n        G = a.arrayMax,\n        m = a.arrayMin,\n        g = a.color,\n        t = a.correctFloat,\n        u = a.defaultOptions,\n        v = a.defined,\n        y = a.deg2rad,\n        q = a.destroyObjectProperties,\n        f = a.extend,\n        e = a.fireEvent,\n        p = a.format,\n        r = a.getMagnitude,\n        b = a.isArray,\n        l = a.isNumber,\n        n = a.isString,\n        d = a.merge,\n        w = a.normalizeTickInterval,\n        E = a.objectEach,\n        C = a.pick,\n        F = a.removeEvent,\n        c = a.splat,\n        k = a.syncTimeout,\n        x = a.Tick,\n        D = function D() {\n      this.init.apply(this, arguments);\n    };\n\n    a.extend(D.prototype, {\n      defaultOptions: {\n        dateTimeLabelFormats: {\n          millisecond: {\n            main: \"%H:%M:%S.%L\",\n            range: !1\n          },\n          second: {\n            main: \"%H:%M:%S\",\n            range: !1\n          },\n          minute: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          hour: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          day: {\n            main: \"%e. %b\"\n          },\n          week: {\n            main: \"%e. %b\"\n          },\n          month: {\n            main: \"%b '%y\"\n          },\n          year: {\n            main: \"%Y\"\n          }\n        },\n        endOnTick: !1,\n        labels: {\n          enabled: !0,\n          indentation: 10,\n          x: 0,\n          style: {\n            color: \"#666666\",\n            cursor: \"default\",\n            fontSize: \"11px\"\n          }\n        },\n        maxPadding: .01,\n        minorTickLength: 2,\n        minorTickPosition: \"outside\",\n        minPadding: .01,\n        startOfWeek: 1,\n        startOnTick: !1,\n        tickLength: 10,\n        tickPixelInterval: 100,\n        tickmarkPlacement: \"between\",\n        tickPosition: \"outside\",\n        title: {\n          align: \"middle\",\n          style: {\n            color: \"#666666\"\n          }\n        },\n        type: \"linear\",\n        minorGridLineColor: \"#f2f2f2\",\n        minorGridLineWidth: 1,\n        minorTickColor: \"#999999\",\n        lineColor: \"#ccd6eb\",\n        lineWidth: 1,\n        gridLineColor: \"#e6e6e6\",\n        tickColor: \"#ccd6eb\"\n      },\n      defaultYAxisOptions: {\n        endOnTick: !0,\n        maxPadding: .05,\n        minPadding: .05,\n        tickPixelInterval: 72,\n        showLastLabel: !0,\n        labels: {\n          x: -8\n        },\n        startOnTick: !0,\n        title: {\n          rotation: 270,\n          text: \"Values\"\n        },\n        stackLabels: {\n          allowOverlap: !1,\n          enabled: !1,\n          formatter: function formatter() {\n            return a.numberFormat(this.total, -1);\n          },\n          style: {\n            color: \"#000000\",\n            fontSize: \"11px\",\n            fontWeight: \"bold\",\n            textOutline: \"1px contrast\"\n          }\n        },\n        gridLineWidth: 1,\n        lineWidth: 0\n      },\n      defaultLeftAxisOptions: {\n        labels: {\n          x: -15\n        },\n        title: {\n          rotation: 270\n        }\n      },\n      defaultRightAxisOptions: {\n        labels: {\n          x: 15\n        },\n        title: {\n          rotation: 90\n        }\n      },\n      defaultBottomAxisOptions: {\n        labels: {\n          autoRotation: [-45],\n          x: 0\n        },\n        margin: 15,\n        title: {\n          rotation: 0\n        }\n      },\n      defaultTopAxisOptions: {\n        labels: {\n          autoRotation: [-45],\n          x: 0\n        },\n        margin: 15,\n        title: {\n          rotation: 0\n        }\n      },\n      init: function init(a, b) {\n        var h = b.isX,\n            k = this;\n        k.chart = a;\n        k.horiz = a.inverted && !k.isZAxis ? !h : h;\n        k.isXAxis = h;\n        k.coll = k.coll || (h ? \"xAxis\" : \"yAxis\");\n        e(this, \"init\", {\n          userOptions: b\n        });\n        k.opposite = b.opposite;\n        k.side = b.side || (k.horiz ? k.opposite ? 0 : 2 : k.opposite ? 1 : 3);\n        k.setOptions(b);\n        var z = this.options,\n            l = z.type;\n        k.labelFormatter = z.labels.formatter || k.defaultLabelFormatter;\n        k.userOptions = b;\n        k.minPixelPadding = 0;\n        k.reversed = z.reversed;\n        k.visible = !1 !== z.visible;\n        k.zoomEnabled = !1 !== z.zoomEnabled;\n        k.hasNames = \"category\" === l || !0 === z.categories;\n        k.categories = z.categories || k.hasNames;\n        k.names || (k.names = [], k.names.keys = {});\n        k.plotLinesAndBandsGroups = {};\n        k.isLog = \"logarithmic\" === l;\n        k.isDatetimeAxis = \"datetime\" === l;\n        k.positiveValuesOnly = k.isLog && !k.allowNegativeLog;\n        k.isLinked = v(z.linkedTo);\n        k.ticks = {};\n        k.labelEdge = [];\n        k.minorTicks = {};\n        k.plotLinesAndBands = [];\n        k.alternateBands = {};\n        k.len = 0;\n        k.minRange = k.userMinRange = z.minRange || z.maxZoom;\n        k.range = z.range;\n        k.offset = z.offset || 0;\n        k.stacks = {};\n        k.oldStacks = {};\n        k.stacksTouched = 0;\n        k.max = null;\n        k.min = null;\n        k.crosshair = C(z.crosshair, c(a.options.tooltip.crosshairs)[h ? 0 : 1], !1);\n        b = k.options.events;\n        -1 === a.axes.indexOf(k) && (h ? a.axes.splice(a.xAxis.length, 0, k) : a.axes.push(k), a[k.coll].push(k));\n        k.series = k.series || [];\n        a.inverted && !k.isZAxis && h && void 0 === k.reversed && (k.reversed = !0);\n        E(b, function (a, h) {\n          B(k, h, a);\n        });\n        k.lin2log = z.linearToLogConverter || k.lin2log;\n        k.isLog && (k.val2lin = k.log2lin, k.lin2val = k.lin2log);\n        e(this, \"afterInit\");\n      },\n      setOptions: function setOptions(a) {\n        this.options = d(this.defaultOptions, \"yAxis\" === this.coll && this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], d(u[this.coll], a));\n        e(this, \"afterSetOptions\", {\n          userOptions: a\n        });\n      },\n      defaultLabelFormatter: function defaultLabelFormatter() {\n        var h = this.axis,\n            c = this.value,\n            b = h.chart.time,\n            k = h.categories,\n            l = this.dateTimeLabelFormat,\n            d = u.lang,\n            x = d.numericSymbols,\n            d = d.numericSymbolMagnitude || 1E3,\n            n = x && x.length,\n            e,\n            f = h.options.labels.format,\n            h = h.isLog ? Math.abs(c) : h.tickInterval;\n        if (f) e = p(f, this, b);else if (k) e = c;else if (l) e = b.dateFormat(l, c);else if (n && 1E3 <= h) for (; n-- && void 0 === e;) {\n          b = Math.pow(d, n + 1), h >= b && 0 === 10 * c % b && null !== x[n] && 0 !== c && (e = a.numberFormat(c / b, -1) + x[n]);\n        }\n        void 0 === e && (e = 1E4 <= Math.abs(c) ? a.numberFormat(c, -1) : a.numberFormat(c, -1, void 0, \"\"));\n        return e;\n      },\n      getSeriesExtremes: function getSeriesExtremes() {\n        var a = this,\n            c = a.chart;\n        e(this, \"getSeriesExtremes\", null, function () {\n          a.hasVisibleSeries = !1;\n          a.dataMin = a.dataMax = a.threshold = null;\n          a.softThreshold = !a.isXAxis;\n          a.buildStacks && a.buildStacks();\n          a.series.forEach(function (h) {\n            if (h.visible || !c.options.chart.ignoreHiddenSeries) {\n              var b = h.options,\n                  k = b.threshold,\n                  z;\n              a.hasVisibleSeries = !0;\n              a.positiveValuesOnly && 0 >= k && (k = null);\n              if (a.isXAxis) b = h.xData, b.length && (h = m(b), z = G(b), l(h) || h instanceof Date || (b = b.filter(l), h = m(b), z = G(b)), b.length && (a.dataMin = Math.min(C(a.dataMin, b[0], h), h), a.dataMax = Math.max(C(a.dataMax, b[0], z), z)));else if (h.getExtremes(), z = h.dataMax, h = h.dataMin, v(h) && v(z) && (a.dataMin = Math.min(C(a.dataMin, h), h), a.dataMax = Math.max(C(a.dataMax, z), z)), v(k) && (a.threshold = k), !b.softThreshold || a.positiveValuesOnly) a.softThreshold = !1;\n            }\n          });\n        });\n        e(this, \"afterGetSeriesExtremes\");\n      },\n      translate: function translate(a, c, b, k, d, x) {\n        var h = this.linkedParent || this,\n            z = 1,\n            n = 0,\n            e = k ? h.oldTransA : h.transA;\n        k = k ? h.oldMin : h.min;\n        var f = h.minPixelPadding;\n        d = (h.isOrdinal || h.isBroken || h.isLog && d) && h.lin2val;\n        e || (e = h.transA);\n        b && (z *= -1, n = h.len);\n        h.reversed && (z *= -1, n -= z * (h.sector || h.len));\n        c ? (a = (a * z + n - f) / e + k, d && (a = h.lin2val(a))) : (d && (a = h.val2lin(a)), a = l(k) ? z * (a - k) * e + n + z * f + (l(x) ? e * x : 0) : void 0);\n        return a;\n      },\n      toPixels: function toPixels(a, c) {\n        return this.translate(a, !1, !this.horiz, null, !0) + (c ? 0 : this.pos);\n      },\n      toValue: function toValue(a, c) {\n        return this.translate(a - (c ? 0 : this.pos), !0, !this.horiz, null, !0);\n      },\n      getPlotLinePath: function getPlotLinePath(a, c, b, k, d) {\n        var h = this,\n            z = h.chart,\n            x = h.left,\n            n = h.top,\n            f,\n            w,\n            r,\n            p,\n            D = b && z.oldChartHeight || z.chartHeight,\n            q = b && z.oldChartWidth || z.chartWidth,\n            g,\n            L = h.transB,\n            E,\n            J = function J(a, h, c) {\n          if (\"pass\" !== k && a < h || a > c) k ? a = Math.min(Math.max(h, a), c) : g = !0;\n          return a;\n        };\n\n        E = {\n          value: a,\n          lineWidth: c,\n          old: b,\n          force: k,\n          translatedValue: d\n        };\n        e(this, \"getPlotLinePath\", E, function (e) {\n          d = C(d, h.translate(a, null, null, b));\n          d = Math.min(Math.max(-1E5, d), 1E5);\n          f = r = Math.round(d + L);\n          w = p = Math.round(D - d - L);\n          l(d) ? h.horiz ? (w = n, p = D - h.bottom, f = r = J(f, x, x + h.width)) : (f = x, r = q - h.right, w = p = J(w, n, n + h.height)) : (g = !0, k = !1);\n          e.path = g && !k ? null : z.renderer.crispLine([\"M\", f, w, \"L\", r, p], c || 1);\n        });\n        return E.path;\n      },\n      getLinearTickPositions: function getLinearTickPositions(a, c, b) {\n        var h,\n            k = t(Math.floor(c / a) * a);\n        b = t(Math.ceil(b / a) * a);\n        var z = [],\n            d;\n        t(k + a) === k && (d = 20);\n        if (this.single) return [c];\n\n        for (c = k; c <= b;) {\n          z.push(c);\n          c = t(c + a, d);\n          if (c === h) break;\n          h = c;\n        }\n\n        return z;\n      },\n      getMinorTickInterval: function getMinorTickInterval() {\n        var a = this.options;\n        return !0 === a.minorTicks ? C(a.minorTickInterval, \"auto\") : !1 === a.minorTicks ? null : a.minorTickInterval;\n      },\n      getMinorTickPositions: function getMinorTickPositions() {\n        var a = this,\n            c = a.options,\n            b = a.tickPositions,\n            k = a.minorTickInterval,\n            d = [],\n            l = a.pointRangePadding || 0,\n            x = a.min - l,\n            l = a.max + l,\n            n = l - x;\n        if (n && n / k < a.len / 3) if (a.isLog) this.paddedTicks.forEach(function (h, c, b) {\n          c && d.push.apply(d, a.getLogTickPositions(k, b[c - 1], b[c], !0));\n        });else if (a.isDatetimeAxis && \"auto\" === this.getMinorTickInterval()) d = d.concat(a.getTimeTicks(a.normalizeTimeTickInterval(k), x, l, c.startOfWeek));else for (c = x + (b[0] - x) % k; c <= l && c !== d[0]; c += k) {\n          d.push(c);\n        }\n        0 !== d.length && a.trimTicks(d);\n        return d;\n      },\n      adjustForMinRange: function adjustForMinRange() {\n        var a = this.options,\n            c = this.min,\n            b = this.max,\n            k,\n            d,\n            l,\n            x,\n            n,\n            e,\n            f,\n            w;\n        this.isXAxis && void 0 === this.minRange && !this.isLog && (v(a.min) || v(a.max) ? this.minRange = null : (this.series.forEach(function (a) {\n          e = a.xData;\n\n          for (x = f = a.xIncrement ? 1 : e.length - 1; 0 < x; x--) {\n            if (n = e[x] - e[x - 1], void 0 === l || n < l) l = n;\n          }\n        }), this.minRange = Math.min(5 * l, this.dataMax - this.dataMin)));\n        b - c < this.minRange && (d = this.dataMax - this.dataMin >= this.minRange, w = this.minRange, k = (w - b + c) / 2, k = [c - k, C(a.min, c - k)], d && (k[2] = this.isLog ? this.log2lin(this.dataMin) : this.dataMin), c = G(k), b = [c + w, C(a.max, c + w)], d && (b[2] = this.isLog ? this.log2lin(this.dataMax) : this.dataMax), b = m(b), b - c < w && (k[0] = b - w, k[1] = C(a.min, b - w), c = G(k)));\n        this.min = c;\n        this.max = b;\n      },\n      getClosest: function getClosest() {\n        var a;\n        this.categories ? a = 1 : this.series.forEach(function (h) {\n          var c = h.closestPointRange,\n              b = h.visible || !h.chart.options.chart.ignoreHiddenSeries;\n          !h.noSharedTooltip && v(c) && b && (a = v(a) ? Math.min(a, c) : c);\n        });\n        return a;\n      },\n      nameToX: function nameToX(a) {\n        var h = b(this.categories),\n            c = h ? this.categories : this.names,\n            k = a.options.x,\n            d;\n        a.series.requireSorting = !1;\n        v(k) || (k = !1 === this.options.uniqueNames ? a.series.autoIncrement() : h ? c.indexOf(a.name) : C(c.keys[a.name], -1));\n        -1 === k ? h || (d = c.length) : d = k;\n        void 0 !== d && (this.names[d] = a.name, this.names.keys[a.name] = d);\n        return d;\n      },\n      updateNames: function updateNames() {\n        var a = this,\n            c = this.names;\n        0 < c.length && (Object.keys(c.keys).forEach(function (a) {\n          delete c.keys[a];\n        }), c.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (h) {\n          h.xIncrement = null;\n          if (!h.points || h.isDirtyData) a.max = Math.max(a.max, h.xData.length - 1), h.processData(), h.generatePoints();\n          h.data.forEach(function (c, b) {\n            var k;\n            c && c.options && void 0 !== c.name && (k = a.nameToX(c), void 0 !== k && k !== c.x && (c.x = k, h.xData[b] = k));\n          });\n        }));\n      },\n      setAxisTranslation: function setAxisTranslation(a) {\n        var h = this,\n            c = h.max - h.min,\n            b = h.axisPointRange || 0,\n            k,\n            d = 0,\n            l = 0,\n            x = h.linkedParent,\n            f = !!h.categories,\n            w = h.transA,\n            r = h.isXAxis;\n        if (r || f || b) k = h.getClosest(), x ? (d = x.minPointOffset, l = x.pointRangePadding) : h.series.forEach(function (a) {\n          var c = f ? 1 : r ? C(a.options.pointRange, k, 0) : h.axisPointRange || 0;\n          a = a.options.pointPlacement;\n          b = Math.max(b, c);\n          h.single || (d = Math.max(d, r && n(a) ? 0 : c / 2), l = Math.max(l, r && \"on\" === a ? 0 : c));\n        }), x = h.ordinalSlope && k ? h.ordinalSlope / k : 1, h.minPointOffset = d *= x, h.pointRangePadding = l *= x, h.pointRange = Math.min(b, c), r && (h.closestPointRange = k);\n        a && (h.oldTransA = w);\n        h.translationSlope = h.transA = w = h.staticScale || h.len / (c + l || 1);\n        h.transB = h.horiz ? h.left : h.bottom;\n        h.minPixelPadding = w * d;\n        e(this, \"afterSetAxisTranslation\");\n      },\n      minFromRange: function minFromRange() {\n        return this.max - this.range;\n      },\n      setTickInterval: function setTickInterval(h) {\n        var c = this,\n            b = c.chart,\n            k = c.options,\n            d = c.isLog,\n            x = c.isDatetimeAxis,\n            n = c.isXAxis,\n            f = c.isLinked,\n            p = k.maxPadding,\n            D = k.minPadding,\n            g,\n            q = k.tickInterval,\n            E = k.tickPixelInterval,\n            F = c.categories,\n            m = l(c.threshold) ? c.threshold : null,\n            y = c.softThreshold,\n            u,\n            A,\n            B;\n        x || F || f || this.getTickAmount();\n        A = C(c.userMin, k.min);\n        B = C(c.userMax, k.max);\n        f ? (c.linkedParent = b[c.coll][k.linkedTo], g = c.linkedParent.getExtremes(), c.min = C(g.min, g.dataMin), c.max = C(g.max, g.dataMax), k.type !== c.linkedParent.options.type && a.error(11, 1, b)) : (!y && v(m) && (c.dataMin >= m ? (g = m, D = 0) : c.dataMax <= m && (u = m, p = 0)), c.min = C(A, g, c.dataMin), c.max = C(B, u, c.dataMax));\n        d && (c.positiveValuesOnly && !h && 0 >= Math.min(c.min, C(c.dataMin, c.min)) && a.error(10, 1, b), c.min = t(c.log2lin(c.min), 15), c.max = t(c.log2lin(c.max), 15));\n        c.range && v(c.max) && (c.userMin = c.min = A = Math.max(c.dataMin, c.minFromRange()), c.userMax = B = c.max, c.range = null);\n        e(c, \"foundExtremes\");\n        c.beforePadding && c.beforePadding();\n        c.adjustForMinRange();\n        !(F || c.axisPointRange || c.usePercentage || f) && v(c.min) && v(c.max) && (b = c.max - c.min) && (!v(A) && D && (c.min -= b * D), !v(B) && p && (c.max += b * p));\n        l(k.softMin) && !l(c.userMin) && (c.min = Math.min(c.min, k.softMin));\n        l(k.softMax) && !l(c.userMax) && (c.max = Math.max(c.max, k.softMax));\n        l(k.floor) && (c.min = Math.min(Math.max(c.min, k.floor), Number.MAX_VALUE));\n        l(k.ceiling) && (c.max = Math.max(Math.min(c.max, k.ceiling), C(c.userMax, -Number.MAX_VALUE)));\n        y && v(c.dataMin) && (m = m || 0, !v(A) && c.min < m && c.dataMin >= m ? c.min = m : !v(B) && c.max > m && c.dataMax <= m && (c.max = m));\n        c.tickInterval = c.min === c.max || void 0 === c.min || void 0 === c.max ? 1 : f && !q && E === c.linkedParent.options.tickPixelInterval ? q = c.linkedParent.tickInterval : C(q, this.tickAmount ? (c.max - c.min) / Math.max(this.tickAmount - 1, 1) : void 0, F ? 1 : (c.max - c.min) * E / Math.max(c.len, E));\n        n && !h && c.series.forEach(function (a) {\n          a.processData(c.min !== c.oldMin || c.max !== c.oldMax);\n        });\n        c.setAxisTranslation(!0);\n        c.beforeSetTickPositions && c.beforeSetTickPositions();\n        c.postProcessTickInterval && (c.tickInterval = c.postProcessTickInterval(c.tickInterval));\n        c.pointRange && !q && (c.tickInterval = Math.max(c.pointRange, c.tickInterval));\n        h = C(k.minTickInterval, c.isDatetimeAxis && c.closestPointRange);\n        !q && c.tickInterval < h && (c.tickInterval = h);\n        x || d || q || (c.tickInterval = w(c.tickInterval, null, r(c.tickInterval), C(k.allowDecimals, !(.5 < c.tickInterval && 5 > c.tickInterval && 1E3 < c.max && 9999 > c.max)), !!this.tickAmount));\n        this.tickAmount || (c.tickInterval = c.unsquish());\n        this.setTickPositions();\n      },\n      setTickPositions: function setTickPositions() {\n        var c = this.options,\n            k,\n            b = c.tickPositions;\n        k = this.getMinorTickInterval();\n        var d = c.tickPositioner,\n            l = c.startOnTick,\n            x = c.endOnTick;\n        this.tickmarkOffset = this.categories && \"between\" === c.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;\n        this.minorTickInterval = \"auto\" === k && this.tickInterval ? this.tickInterval / 5 : k;\n        this.single = this.min === this.max && v(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== c.allowDecimals);\n        this.tickPositions = k = b && b.slice();\n        !k && (!this.ordinalPositions && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200) ? (k = [this.min, this.max], a.error(19, !1, this.chart)) : k = this.isDatetimeAxis ? this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, c.units), this.min, this.max, c.startOfWeek, this.ordinalPositions, this.closestPointRange, !0) : this.isLog ? this.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max), k.length > this.len && (k = [k[0], k.pop()], k[0] === k[1] && (k.length = 1)), this.tickPositions = k, d && (d = d.apply(this, [this.min, this.max]))) && (this.tickPositions = k = d);\n        this.paddedTicks = k.slice(0);\n        this.trimTicks(k, l, x);\n        this.isLinked || (this.single && 2 > k.length && (this.min -= .5, this.max += .5), b || d || this.adjustTickAmount());\n        e(this, \"afterSetTickPositions\");\n      },\n      trimTicks: function trimTicks(a, c, k) {\n        var h = a[0],\n            b = a[a.length - 1],\n            d = this.minPointOffset || 0;\n        e(this, \"trimTicks\");\n\n        if (!this.isLinked) {\n          if (c && -Infinity !== h) this.min = h;else for (; this.min - d > a[0];) {\n            a.shift();\n          }\n          if (k) this.max = b;else for (; this.max + d < a[a.length - 1];) {\n            a.pop();\n          }\n          0 === a.length && v(h) && !this.options.tickPositions && a.push((b + h) / 2);\n        }\n      },\n      alignToOthers: function alignToOthers() {\n        var a = {},\n            c,\n            k = this.options;\n        !1 === this.chart.options.chart.alignTicks || !1 === k.alignTicks || !1 === k.startOnTick || !1 === k.endOnTick || this.isLog || this.chart[this.coll].forEach(function (h) {\n          var k = h.options,\n              k = [h.horiz ? k.left : k.top, k.width, k.height, k.pane].join();\n          h.series.length && (a[k] ? c = !0 : a[k] = 1);\n        });\n        return c;\n      },\n      getTickAmount: function getTickAmount() {\n        var a = this.options,\n            c = a.tickAmount,\n            k = a.tickPixelInterval;\n        !v(a.tickInterval) && this.len < k && !this.isRadial && !this.isLog && a.startOnTick && a.endOnTick && (c = 2);\n        !c && this.alignToOthers() && (c = Math.ceil(this.len / k) + 1);\n        4 > c && (this.finalTickAmt = c, c = 5);\n        this.tickAmount = c;\n      },\n      adjustTickAmount: function adjustTickAmount() {\n        var a = this.options,\n            c = this.tickInterval,\n            k = this.tickPositions,\n            b = this.tickAmount,\n            d = this.finalTickAmt,\n            l = k && k.length,\n            x = C(this.threshold, this.softThreshold ? 0 : null),\n            n;\n\n        if (this.hasData()) {\n          if (l < b) {\n            for (n = this.min; k.length < b;) {\n              k.length % 2 || n === x ? k.push(t(k[k.length - 1] + c)) : k.unshift(t(k[0] - c));\n            }\n\n            this.transA *= (l - 1) / (b - 1);\n            this.min = a.startOnTick ? k[0] : Math.min(this.min, k[0]);\n            this.max = a.endOnTick ? k[k.length - 1] : Math.max(this.max, k[k.length - 1]);\n          } else l > b && (this.tickInterval *= 2, this.setTickPositions());\n\n          if (v(d)) {\n            for (c = a = k.length; c--;) {\n              (3 === d && 1 === c % 2 || 2 >= d && 0 < c && c < a - 1) && k.splice(c, 1);\n            }\n\n            this.finalTickAmt = void 0;\n          }\n        }\n      },\n      setScale: function setScale() {\n        var a = this.series.some(function (a) {\n          return a.isDirtyData || a.isDirty || a.xAxis.isDirty;\n        }),\n            c;\n        this.oldMin = this.min;\n        this.oldMax = this.max;\n        this.oldAxisLength = this.len;\n        this.setAxisSize();\n        (c = this.len !== this.oldAxisLength) || a || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers() ? (this.resetStacks && this.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin = this.userMin, this.oldUserMax = this.userMax, this.isDirty || (this.isDirty = c || this.min !== this.oldMin || this.max !== this.oldMax)) : this.cleanStacks && this.cleanStacks();\n        e(this, \"afterSetScale\");\n      },\n      setExtremes: function setExtremes(a, c, k, b, d) {\n        var h = this,\n            l = h.chart;\n        k = C(k, !0);\n        h.series.forEach(function (a) {\n          delete a.kdTree;\n        });\n        d = f(d, {\n          min: a,\n          max: c\n        });\n        e(h, \"setExtremes\", d, function () {\n          h.userMin = a;\n          h.userMax = c;\n          h.eventArgs = d;\n          k && l.redraw(b);\n        });\n      },\n      zoom: function zoom(a, c) {\n        var h = this.dataMin,\n            k = this.dataMax,\n            b = this.options,\n            d = Math.min(h, C(b.min, h)),\n            l = Math.max(k, C(b.max, k));\n        a = {\n          newMin: a,\n          newMax: c\n        };\n        e(this, \"zoom\", a, function (a) {\n          var c = a.newMin,\n              b = a.newMax;\n          if (c !== this.min || b !== this.max) this.allowZoomOutside || (v(h) && (c < d && (c = d), c > l && (c = l)), v(k) && (b < d && (b = d), b > l && (b = l))), this.displayBtn = void 0 !== c || void 0 !== b, this.setExtremes(c, b, !1, void 0, {\n            trigger: \"zoom\"\n          });\n          a.zoomed = !0;\n        });\n        return a.zoomed;\n      },\n      setAxisSize: function setAxisSize() {\n        var c = this.chart,\n            k = this.options,\n            b = k.offsets || [0, 0, 0, 0],\n            d = this.horiz,\n            l = this.width = Math.round(a.relativeLength(C(k.width, c.plotWidth - b[3] + b[1]), c.plotWidth)),\n            x = this.height = Math.round(a.relativeLength(C(k.height, c.plotHeight - b[0] + b[2]), c.plotHeight)),\n            n = this.top = Math.round(a.relativeLength(C(k.top, c.plotTop + b[0]), c.plotHeight, c.plotTop)),\n            k = this.left = Math.round(a.relativeLength(C(k.left, c.plotLeft + b[3]), c.plotWidth, c.plotLeft));\n        this.bottom = c.chartHeight - x - n;\n        this.right = c.chartWidth - l - k;\n        this.len = Math.max(d ? l : x, 0);\n        this.pos = d ? k : n;\n      },\n      getExtremes: function getExtremes() {\n        var a = this.isLog;\n        return {\n          min: a ? t(this.lin2log(this.min)) : this.min,\n          max: a ? t(this.lin2log(this.max)) : this.max,\n          dataMin: this.dataMin,\n          dataMax: this.dataMax,\n          userMin: this.userMin,\n          userMax: this.userMax\n        };\n      },\n      getThreshold: function getThreshold(a) {\n        var c = this.isLog,\n            h = c ? this.lin2log(this.min) : this.min,\n            c = c ? this.lin2log(this.max) : this.max;\n        null === a || -Infinity === a ? a = h : Infinity === a ? a = c : h > a ? a = h : c < a && (a = c);\n        return this.translate(a, 0, 1, 0, 1);\n      },\n      autoLabelAlign: function autoLabelAlign(a) {\n        var c = (C(a, 0) - 90 * this.side + 720) % 360;\n        a = {\n          align: \"center\"\n        };\n        e(this, \"autoLabelAlign\", a, function (a) {\n          15 < c && 165 > c ? a.align = \"right\" : 195 < c && 345 > c && (a.align = \"left\");\n        });\n        return a.align;\n      },\n      tickSize: function tickSize(a) {\n        var c = this.options,\n            h = c[a + \"Length\"],\n            k = C(c[a + \"Width\"], \"tick\" === a && this.isXAxis ? 1 : 0),\n            b;\n        k && h && (\"inside\" === c[a + \"Position\"] && (h = -h), b = [h, k]);\n        a = {\n          tickSize: b\n        };\n        e(this, \"afterTickSize\", a);\n        return a.tickSize;\n      },\n      labelMetrics: function labelMetrics() {\n        var a = this.tickPositions && this.tickPositions[0] || 0;\n        return this.chart.renderer.fontMetrics(this.options.labels.style && this.options.labels.style.fontSize, this.ticks[a] && this.ticks[a].label);\n      },\n      unsquish: function unsquish() {\n        var a = this.options.labels,\n            c = this.horiz,\n            k = this.tickInterval,\n            b = k,\n            d = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / k),\n            l,\n            x = a.rotation,\n            n = this.labelMetrics(),\n            e,\n            f = Number.MAX_VALUE,\n            w,\n            r = this.max - this.min,\n            p = function p(a) {\n          var c = a / (d || 1),\n              c = 1 < c ? Math.ceil(c) : 1;\n          c * k > r && Infinity !== a && Infinity !== d && (c = Math.ceil(r / k));\n          return t(c * k);\n        };\n\n        c ? (w = !a.staggerLines && !a.step && (v(x) ? [x] : d < C(a.autoRotationLimit, 80) && a.autoRotation)) && w.forEach(function (a) {\n          var c;\n          if (a === x || a && -90 <= a && 90 >= a) e = p(Math.abs(n.h / Math.sin(y * a))), c = e + Math.abs(a / 360), c < f && (f = c, l = a, b = e);\n        }) : a.step || (b = p(n.h));\n        this.autoRotation = w;\n        this.labelRotation = C(l, x);\n        return b;\n      },\n      getSlotWidth: function getSlotWidth(a) {\n        var c = this.chart,\n            h = this.horiz,\n            k = this.options.labels,\n            b = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n            d = c.margin[3];\n        return a && a.slotWidth || h && 2 > (k.step || 0) && !k.rotation && (this.staggerLines || 1) * this.len / b || !h && (k.style && parseInt(k.style.width, 10) || d && d - c.spacing[3] || .33 * c.chartWidth);\n      },\n      renderUnsquish: function renderUnsquish() {\n        var a = this.chart,\n            c = a.renderer,\n            k = this.tickPositions,\n            b = this.ticks,\n            d = this.options.labels,\n            l = d && d.style || {},\n            x = this.horiz,\n            e = this.getSlotWidth(),\n            f = Math.max(1, Math.round(e - 2 * (d.padding || 5))),\n            w = {},\n            r = this.labelMetrics(),\n            p = d.style && d.style.textOverflow,\n            D,\n            g,\n            q = 0,\n            E;\n        n(d.rotation) || (w.rotation = d.rotation || 0);\n        k.forEach(function (a) {\n          (a = b[a]) && a.label && a.label.textPxLength > q && (q = a.label.textPxLength);\n        });\n        this.maxLabelLength = q;\n        if (this.autoRotation) q > f && q > r.h ? w.rotation = this.labelRotation : this.labelRotation = 0;else if (e && (D = f, !p)) for (g = \"clip\", f = k.length; !x && f--;) {\n          if (E = k[f], E = b[E].label) E.styles && \"ellipsis\" === E.styles.textOverflow ? E.css({\n            textOverflow: \"clip\"\n          }) : E.textPxLength > e && E.css({\n            width: e + \"px\"\n          }), E.getBBox().height > this.len / k.length - (r.h - r.f) && (E.specificTextOverflow = \"ellipsis\");\n        }\n        w.rotation && (D = q > .5 * a.chartHeight ? .33 * a.chartHeight : q, p || (g = \"ellipsis\"));\n        if (this.labelAlign = d.align || this.autoLabelAlign(this.labelRotation)) w.align = this.labelAlign;\n        k.forEach(function (a) {\n          var c = (a = b[a]) && a.label,\n              h = l.width,\n              k = {};\n          c && (c.attr(w), a.shortenLabel ? a.shortenLabel() : D && !h && \"nowrap\" !== l.whiteSpace && (D < c.textPxLength || \"SPAN\" === c.element.tagName) ? (k.width = D, p || (k.textOverflow = c.specificTextOverflow || g), c.css(k)) : c.styles && c.styles.width && !k.width && !h && c.css({\n            width: null\n          }), delete c.specificTextOverflow, a.rotation = w.rotation);\n        }, this);\n        this.tickRotCorr = c.rotCorr(r.b, this.labelRotation || 0, 0 !== this.side);\n      },\n      hasData: function hasData() {\n        return this.hasVisibleSeries || v(this.min) && v(this.max) && this.tickPositions && 0 < this.tickPositions.length;\n      },\n      addTitle: function addTitle(a) {\n        var c = this.chart.renderer,\n            h = this.horiz,\n            k = this.opposite,\n            b = this.options.title,\n            l,\n            x = this.chart.styledMode;\n        this.axisTitle || ((l = b.textAlign) || (l = (h ? {\n          low: \"left\",\n          middle: \"center\",\n          high: \"right\"\n        } : {\n          low: k ? \"right\" : \"left\",\n          middle: \"center\",\n          high: k ? \"left\" : \"right\"\n        })[b.align]), this.axisTitle = c.text(b.text, 0, 0, b.useHTML).attr({\n          zIndex: 7,\n          rotation: b.rotation || 0,\n          align: l\n        }).addClass(\"highcharts-axis-title\"), x || this.axisTitle.css(d(b.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);\n        x || b.style.width || this.isRadial || this.axisTitle.css({\n          width: this.len\n        });\n        this.axisTitle[a ? \"show\" : \"hide\"](!0);\n      },\n      generateTick: function generateTick(a) {\n        var c = this.ticks;\n        c[a] ? c[a].addLabel() : c[a] = new x(this, a);\n      },\n      getOffset: function getOffset() {\n        var a = this,\n            c = a.chart,\n            k = c.renderer,\n            b = a.options,\n            d = a.tickPositions,\n            l = a.ticks,\n            x = a.horiz,\n            n = a.side,\n            f = c.inverted && !a.isZAxis ? [1, 0, 3, 2][n] : n,\n            w,\n            r,\n            p = 0,\n            D,\n            q = 0,\n            g = b.title,\n            F = b.labels,\n            m = 0,\n            t = c.axisOffset,\n            c = c.clipOffset,\n            y = [-1, 1, 1, -1][n],\n            u = b.className,\n            A = a.axisParent;\n        w = a.hasData();\n        a.showAxis = r = w || C(b.showEmpty, !0);\n        a.staggerLines = a.horiz && F.staggerLines;\n        a.axisGroup || (a.gridGroup = k.g(\"grid\").attr({\n          zIndex: b.gridZIndex || 1\n        }).addClass(\"highcharts-\" + this.coll.toLowerCase() + \"-grid \" + (u || \"\")).add(A), a.axisGroup = k.g(\"axis\").attr({\n          zIndex: b.zIndex || 2\n        }).addClass(\"highcharts-\" + this.coll.toLowerCase() + \" \" + (u || \"\")).add(A), a.labelGroup = k.g(\"axis-labels\").attr({\n          zIndex: F.zIndex || 7\n        }).addClass(\"highcharts-\" + a.coll.toLowerCase() + \"-labels \" + (u || \"\")).add(A));\n        w || a.isLinked ? (d.forEach(function (c, k) {\n          a.generateTick(c, k);\n        }), a.renderUnsquish(), a.reserveSpaceDefault = 0 === n || 2 === n || {\n          1: \"left\",\n          3: \"right\"\n        }[n] === a.labelAlign, C(F.reserveSpace, \"center\" === a.labelAlign ? !0 : null, a.reserveSpaceDefault) && d.forEach(function (a) {\n          m = Math.max(l[a].getLabelSize(), m);\n        }), a.staggerLines && (m *= a.staggerLines), a.labelOffset = m * (a.opposite ? -1 : 1)) : E(l, function (a, c) {\n          a.destroy();\n          delete l[c];\n        });\n        g && g.text && !1 !== g.enabled && (a.addTitle(r), r && !1 !== g.reserveSpace && (a.titleOffset = p = a.axisTitle.getBBox()[x ? \"height\" : \"width\"], D = g.offset, q = v(D) ? 0 : C(g.margin, x ? 5 : 10)));\n        a.renderLine();\n        a.offset = y * C(b.offset, t[n] ? t[n] + (b.margin || 0) : 0);\n        a.tickRotCorr = a.tickRotCorr || {\n          x: 0,\n          y: 0\n        };\n        k = 0 === n ? -a.labelMetrics().h : 2 === n ? a.tickRotCorr.y : 0;\n        q = Math.abs(m) + q;\n        m && (q = q - k + y * (x ? C(F.y, a.tickRotCorr.y + 8 * y) : F.x));\n        a.axisTitleMargin = C(D, q);\n        a.getMaxLabelDimensions && (a.maxLabelDimensions = a.getMaxLabelDimensions(l, d));\n        x = this.tickSize(\"tick\");\n        t[n] = Math.max(t[n], a.axisTitleMargin + p + y * a.offset, q, w && d.length && x ? x[0] + y * a.offset : 0);\n        b = b.offset ? 0 : 2 * Math.floor(a.axisLine.strokeWidth() / 2);\n        c[f] = Math.max(c[f], b);\n        e(this, \"afterGetOffset\");\n      },\n      getLinePath: function getLinePath(a) {\n        var c = this.chart,\n            k = this.opposite,\n            h = this.offset,\n            b = this.horiz,\n            d = this.left + (k ? this.width : 0) + h,\n            h = c.chartHeight - this.bottom - (k ? this.height : 0) + h;\n        k && (a *= -1);\n        return c.renderer.crispLine([\"M\", b ? this.left : d, b ? h : this.top, \"L\", b ? c.chartWidth - this.right : d, b ? h : c.chartHeight - this.bottom], a);\n      },\n      renderLine: function renderLine() {\n        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass(\"highcharts-axis-line\").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({\n          stroke: this.options.lineColor,\n          \"stroke-width\": this.options.lineWidth,\n          zIndex: 7\n        }));\n      },\n      getTitlePosition: function getTitlePosition() {\n        var a = this.horiz,\n            c = this.left,\n            k = this.top,\n            b = this.len,\n            d = this.options.title,\n            l = a ? c : k,\n            x = this.opposite,\n            n = this.offset,\n            f = d.x || 0,\n            w = d.y || 0,\n            r = this.axisTitle,\n            p = this.chart.renderer.fontMetrics(d.style && d.style.fontSize, r),\n            r = Math.max(r.getBBox(null, 0).height - p.h - 1, 0),\n            b = {\n          low: l + (a ? 0 : b),\n          middle: l + b / 2,\n          high: l + (a ? b : 0)\n        }[d.align],\n            c = (a ? k + this.height : c) + (a ? 1 : -1) * (x ? -1 : 1) * this.axisTitleMargin + [-r, r, p.f, -r][this.side],\n            a = {\n          x: a ? b + f : c + (x ? this.width : 0) + n + f,\n          y: a ? c + w - (x ? this.height : 0) + n : b + w\n        };\n        e(this, \"afterGetTitlePosition\", {\n          titlePosition: a\n        });\n        return a;\n      },\n      renderMinorTick: function renderMinorTick(a) {\n        var c = this.chart.hasRendered && l(this.oldMin),\n            k = this.minorTicks;\n        k[a] || (k[a] = new x(this, a, \"minor\"));\n        c && k[a].isNew && k[a].render(null, !0);\n        k[a].render(null, !1, 1);\n      },\n      renderTick: function renderTick(a, c) {\n        var k = this.isLinked,\n            b = this.ticks,\n            h = this.chart.hasRendered && l(this.oldMin);\n        if (!k || a >= this.min && a <= this.max) b[a] || (b[a] = new x(this, a)), h && b[a].isNew && b[a].render(c, !0, -1), b[a].render(c);\n      },\n      render: function render() {\n        var c = this,\n            b = c.chart,\n            d = c.options,\n            n = c.isLog,\n            f = c.isLinked,\n            w = c.tickPositions,\n            r = c.axisTitle,\n            p = c.ticks,\n            D = c.minorTicks,\n            q = c.alternateBands,\n            g = d.stackLabels,\n            C = d.alternateGridColor,\n            F = c.tickmarkOffset,\n            m = c.axisLine,\n            t = c.showAxis,\n            y = A(b.renderer.globalAnimation),\n            v,\n            u;\n        c.labelEdge.length = 0;\n        c.overlap = !1;\n        [p, D, q].forEach(function (a) {\n          E(a, function (a) {\n            a.isActive = !1;\n          });\n        });\n        if (c.hasData() || f) c.minorTickInterval && !c.categories && c.getMinorTickPositions().forEach(function (a) {\n          c.renderMinorTick(a);\n        }), w.length && (w.forEach(function (a, k) {\n          c.renderTick(a, k);\n        }), F && (0 === c.min || c.single) && (p[-1] || (p[-1] = new x(c, -1, null, !0)), p[-1].render(-1))), C && w.forEach(function (k, h) {\n          u = void 0 !== w[h + 1] ? w[h + 1] + F : c.max - F;\n          0 === h % 2 && k < c.max && u <= c.max + (b.polar ? -F : F) && (q[k] || (q[k] = new a.PlotLineOrBand(c)), v = k + F, q[k].options = {\n            from: n ? c.lin2log(v) : v,\n            to: n ? c.lin2log(u) : u,\n            color: C\n          }, q[k].render(), q[k].isActive = !0);\n        }), c._addedPlotLB || ((d.plotLines || []).concat(d.plotBands || []).forEach(function (a) {\n          c.addPlotBandOrLine(a);\n        }), c._addedPlotLB = !0);\n        [p, D, q].forEach(function (a) {\n          var c,\n              h = [],\n              d = y.duration;\n          E(a, function (a, c) {\n            a.isActive || (a.render(c, !1, 0), a.isActive = !1, h.push(c));\n          });\n          k(function () {\n            for (c = h.length; c--;) {\n              a[h[c]] && !a[h[c]].isActive && (a[h[c]].destroy(), delete a[h[c]]);\n            }\n          }, a !== q && b.hasRendered && d ? d : 0);\n        });\n        m && (m[m.isPlaced ? \"animate\" : \"attr\"]({\n          d: this.getLinePath(m.strokeWidth())\n        }), m.isPlaced = !0, m[t ? \"show\" : \"hide\"](!0));\n        r && t && (d = c.getTitlePosition(), l(d.y) ? (r[r.isNew ? \"attr\" : \"animate\"](d), r.isNew = !1) : (r.attr(\"y\", -9999), r.isNew = !0));\n        g && g.enabled && c.renderStackTotals();\n        c.isDirty = !1;\n        e(this, \"afterRender\");\n      },\n      redraw: function redraw() {\n        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (a) {\n          a.render();\n        }));\n        this.series.forEach(function (a) {\n          a.isDirty = !0;\n        });\n      },\n      keepProps: \"extKey hcEvents names series userMax userMin\".split(\" \"),\n      destroy: function destroy(a) {\n        var c = this,\n            k = c.stacks,\n            b = c.plotLinesAndBands,\n            h;\n        e(this, \"destroy\", {\n          keepEvents: a\n        });\n        a || F(c);\n        E(k, function (a, c) {\n          q(a);\n          k[c] = null;\n        });\n        [c.ticks, c.minorTicks, c.alternateBands].forEach(function (a) {\n          q(a);\n        });\n        if (b) for (a = b.length; a--;) {\n          b[a].destroy();\n        }\n        \"stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar\".split(\" \").forEach(function (a) {\n          c[a] && (c[a] = c[a].destroy());\n        });\n\n        for (h in c.plotLinesAndBandsGroups) {\n          c.plotLinesAndBandsGroups[h] = c.plotLinesAndBandsGroups[h].destroy();\n        }\n\n        E(c, function (a, k) {\n          -1 === c.keepProps.indexOf(k) && delete c[k];\n        });\n      },\n      drawCrosshair: function drawCrosshair(a, c) {\n        var k,\n            b = this.crosshair,\n            h = C(b.snap, !0),\n            d,\n            l = this.cross;\n        e(this, \"drawCrosshair\", {\n          e: a,\n          point: c\n        });\n        a || (a = this.cross && this.cross.e);\n\n        if (this.crosshair && !1 !== (v(c) || !h)) {\n          h ? v(c) && (d = C(c.crosshairPos, this.isXAxis ? c.plotX : this.len - c.plotY)) : d = a && (this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos);\n          v(d) && (k = this.getPlotLinePath(c && (this.isXAxis ? c.x : C(c.stackY, c.y)), null, null, null, d) || null);\n\n          if (!v(k)) {\n            this.hideCrosshair();\n            return;\n          }\n\n          h = this.categories && !this.isRadial;\n          l || (this.cross = l = this.chart.renderer.path().addClass(\"highcharts-crosshair highcharts-crosshair-\" + (h ? \"category \" : \"thin \") + b.className).attr({\n            zIndex: C(b.zIndex, 2)\n          }).add(), this.chart.styledMode || (l.attr({\n            stroke: b.color || (h ? g(\"#ccd6eb\").setOpacity(.25).get() : \"#cccccc\"),\n            \"stroke-width\": C(b.width, 1)\n          }).css({\n            \"pointer-events\": \"none\"\n          }), b.dashStyle && l.attr({\n            dashstyle: b.dashStyle\n          })));\n          l.show().attr({\n            d: k\n          });\n          h && !b.width && l.attr({\n            \"stroke-width\": this.transA\n          });\n          this.cross.e = a;\n        } else this.hideCrosshair();\n\n        e(this, \"afterDrawCrosshair\", {\n          e: a,\n          point: c\n        });\n      },\n      hideCrosshair: function hideCrosshair() {\n        this.cross && this.cross.hide();\n        e(this, \"afterHideCrosshair\");\n      }\n    });\n    return a.Axis = D;\n  }(H);\n\n  (function (a) {\n    var B = a.Axis,\n        A = a.getMagnitude,\n        G = a.normalizeTickInterval,\n        m = a.timeUnits;\n\n    B.prototype.getTimeTicks = function () {\n      return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);\n    };\n\n    B.prototype.normalizeTimeTickInterval = function (a, t) {\n      var g = t || [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2]], [\"week\", [1, 2]], [\"month\", [1, 2, 3, 4, 6]], [\"year\", null]];\n      t = g[g.length - 1];\n      var v = m[t[0]],\n          y = t[1],\n          q;\n\n      for (q = 0; q < g.length && !(t = g[q], v = m[t[0]], y = t[1], g[q + 1] && a <= (v * y[y.length - 1] + m[g[q + 1][0]]) / 2); q++) {\n        ;\n      }\n\n      v === m.year && a < 5 * v && (y = [1, 2, 5]);\n      a = G(a / v, y, \"year\" === t[0] ? Math.max(A(a / v), 1) : 1);\n      return {\n        unitRange: v,\n        count: a,\n        unitName: t[0]\n      };\n    };\n  })(H);\n\n  (function (a) {\n    var B = a.Axis,\n        A = a.getMagnitude,\n        G = a.normalizeTickInterval,\n        m = a.pick;\n\n    B.prototype.getLogTickPositions = function (a, t, u, v) {\n      var g = this.options,\n          q = this.len,\n          f = [];\n      v || (this._minorAutoInterval = null);\n      if (.5 <= a) a = Math.round(a), f = this.getLinearTickPositions(a, t, u);else if (.08 <= a) for (var q = Math.floor(t), e, p, r, b, l, g = .3 < a ? [1, 2, 4] : .15 < a ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; q < u + 1 && !l; q++) {\n        for (p = g.length, e = 0; e < p && !l; e++) {\n          r = this.log2lin(this.lin2log(q) * g[e]), r > t && (!v || b <= u) && void 0 !== b && f.push(b), b > u && (l = !0), b = r;\n        }\n      } else t = this.lin2log(t), u = this.lin2log(u), a = v ? this.getMinorTickInterval() : g.tickInterval, a = m(\"auto\" === a ? null : a, this._minorAutoInterval, g.tickPixelInterval / (v ? 5 : 1) * (u - t) / ((v ? q / this.tickPositions.length : q) || 1)), a = G(a, null, A(a)), f = this.getLinearTickPositions(a, t, u).map(this.log2lin), v || (this._minorAutoInterval = a / 5);\n      v || (this.tickInterval = a);\n      return f;\n    };\n\n    B.prototype.log2lin = function (a) {\n      return Math.log(a) / Math.LN10;\n    };\n\n    B.prototype.lin2log = function (a) {\n      return Math.pow(10, a);\n    };\n  })(H);\n\n  (function (a, B) {\n    var A = a.arrayMax,\n        G = a.arrayMin,\n        m = a.defined,\n        g = a.destroyObjectProperties,\n        t = a.erase,\n        u = a.merge,\n        v = a.pick;\n\n    a.PlotLineOrBand = function (a, q) {\n      this.axis = a;\n      q && (this.options = q, this.id = q.id);\n    };\n\n    a.PlotLineOrBand.prototype = {\n      render: function render() {\n        a.fireEvent(this, \"render\");\n        var g = this,\n            q = g.axis,\n            f = q.horiz,\n            e = g.options,\n            p = e.label,\n            r = g.label,\n            b = e.to,\n            l = e.from,\n            n = e.value,\n            d = m(l) && m(b),\n            w = m(n),\n            E = g.svgElem,\n            C = !E,\n            F = [],\n            c = e.color,\n            k = v(e.zIndex, 0),\n            x = e.events,\n            F = {\n          \"class\": \"highcharts-plot-\" + (d ? \"band \" : \"line \") + (e.className || \"\")\n        },\n            D = {},\n            h = q.chart.renderer,\n            z = d ? \"bands\" : \"lines\";\n        q.isLog && (l = q.log2lin(l), b = q.log2lin(b), n = q.log2lin(n));\n        q.chart.styledMode || (w ? (F.stroke = c, F[\"stroke-width\"] = e.width, e.dashStyle && (F.dashstyle = e.dashStyle)) : d && (c && (F.fill = c), e.borderWidth && (F.stroke = e.borderColor, F[\"stroke-width\"] = e.borderWidth)));\n        D.zIndex = k;\n        z += \"-\" + k;\n        (c = q.plotLinesAndBandsGroups[z]) || (q.plotLinesAndBandsGroups[z] = c = h.g(\"plot-\" + z).attr(D).add());\n        C && (g.svgElem = E = h.path().attr(F).add(c));\n        if (w) F = q.getPlotLinePath(n, E.strokeWidth());else if (d) F = q.getPlotBandPath(l, b, e);else return;\n        C && F && F.length ? (E.attr({\n          d: F\n        }), x && a.objectEach(x, function (a, c) {\n          E.on(c, function (a) {\n            x[c].apply(g, [a]);\n          });\n        })) : E && (F ? (E.show(), E.animate({\n          d: F\n        })) : (E.hide(), r && (g.label = r = r.destroy())));\n        p && m(p.text) && F && F.length && 0 < q.width && 0 < q.height && !F.isFlat ? (p = u({\n          align: f && d && \"center\",\n          x: f ? !d && 4 : 10,\n          verticalAlign: !f && d && \"middle\",\n          y: f ? d ? 16 : 10 : d ? 6 : -4,\n          rotation: f && !d && 90\n        }, p), this.renderLabel(p, F, d, k)) : r && r.hide();\n        return g;\n      },\n      renderLabel: function renderLabel(a, q, f, e) {\n        var p = this.label,\n            r = this.axis.chart.renderer;\n        p || (p = {\n          align: a.textAlign || a.align,\n          rotation: a.rotation,\n          \"class\": \"highcharts-plot-\" + (f ? \"band\" : \"line\") + \"-label \" + (a.className || \"\")\n        }, p.zIndex = e, this.label = p = r.text(a.text, 0, 0, a.useHTML).attr(p).add(), this.axis.chart.styledMode || p.css(a.style));\n        e = q.xBounds || [q[1], q[4], f ? q[6] : q[1]];\n        q = q.yBounds || [q[2], q[5], f ? q[7] : q[2]];\n        f = G(e);\n        r = G(q);\n        p.align(a, !1, {\n          x: f,\n          y: r,\n          width: A(e) - f,\n          height: A(q) - r\n        });\n        p.show();\n      },\n      destroy: function destroy() {\n        t(this.axis.plotLinesAndBands, this);\n        delete this.axis;\n        g(this);\n      }\n    };\n    a.extend(B.prototype, {\n      getPlotBandPath: function getPlotBandPath(a, q) {\n        var f = this.getPlotLinePath(q, null, null, !0),\n            e = this.getPlotLinePath(a, null, null, !0),\n            p = [],\n            r = this.horiz,\n            b = 1,\n            l;\n        a = a < this.min && q < this.min || a > this.max && q > this.max;\n        if (e && f) for (a && (l = e.toString() === f.toString(), b = 0), a = 0; a < e.length; a += 6) {\n          r && f[a + 1] === e[a + 1] ? (f[a + 1] += b, f[a + 4] += b) : r || f[a + 2] !== e[a + 2] || (f[a + 2] += b, f[a + 5] += b), p.push(\"M\", e[a + 1], e[a + 2], \"L\", e[a + 4], e[a + 5], f[a + 4], f[a + 5], f[a + 1], f[a + 2], \"z\"), p.isFlat = l;\n        }\n        return p;\n      },\n      addPlotBand: function addPlotBand(a) {\n        return this.addPlotBandOrLine(a, \"plotBands\");\n      },\n      addPlotLine: function addPlotLine(a) {\n        return this.addPlotBandOrLine(a, \"plotLines\");\n      },\n      addPlotBandOrLine: function addPlotBandOrLine(g, q) {\n        var f = new a.PlotLineOrBand(this, g).render(),\n            e = this.userOptions;\n        f && (q && (e[q] = e[q] || [], e[q].push(g)), this.plotLinesAndBands.push(f));\n        return f;\n      },\n      removePlotBandOrLine: function removePlotBandOrLine(a) {\n        for (var q = this.plotLinesAndBands, f = this.options, e = this.userOptions, p = q.length; p--;) {\n          q[p].id === a && q[p].destroy();\n        }\n\n        [f.plotLines || [], e.plotLines || [], f.plotBands || [], e.plotBands || []].forEach(function (e) {\n          for (p = e.length; p--;) {\n            e[p].id === a && t(e, e[p]);\n          }\n        });\n      },\n      removePlotBand: function removePlotBand(a) {\n        this.removePlotBandOrLine(a);\n      },\n      removePlotLine: function removePlotLine(a) {\n        this.removePlotBandOrLine(a);\n      }\n    });\n  })(H, da);\n\n  (function (a) {\n    var B = a.doc,\n        A = a.extend,\n        G = a.format,\n        m = a.isNumber,\n        g = a.merge,\n        t = a.pick,\n        u = a.splat,\n        v = a.syncTimeout,\n        y = a.timeUnits;\n\n    a.Tooltip = function () {\n      this.init.apply(this, arguments);\n    };\n\n    a.Tooltip.prototype = {\n      init: function init(a, f) {\n        this.chart = a;\n        this.options = f;\n        this.crosshairs = [];\n        this.now = {\n          x: 0,\n          y: 0\n        };\n        this.isHidden = !0;\n        this.split = f.split && !a.inverted;\n        this.shared = f.shared || this.split;\n        this.outside = f.outside && !this.split;\n      },\n      cleanSplit: function cleanSplit(a) {\n        this.chart.series.forEach(function (f) {\n          var e = f && f.tt;\n          e && (!e.isActive || a ? f.tt = e.destroy() : e.isActive = !1);\n        });\n      },\n      applyFilter: function applyFilter() {\n        var a = this.chart;\n        a.renderer.definition({\n          tagName: \"filter\",\n          id: \"drop-shadow-\" + a.index,\n          opacity: .5,\n          children: [{\n            tagName: \"feGaussianBlur\",\n            \"in\": \"SourceAlpha\",\n            stdDeviation: 1\n          }, {\n            tagName: \"feOffset\",\n            dx: 1,\n            dy: 1\n          }, {\n            tagName: \"feComponentTransfer\",\n            children: [{\n              tagName: \"feFuncA\",\n              type: \"linear\",\n              slope: .3\n            }]\n          }, {\n            tagName: \"feMerge\",\n            children: [{\n              tagName: \"feMergeNode\"\n            }, {\n              tagName: \"feMergeNode\",\n              \"in\": \"SourceGraphic\"\n            }]\n          }]\n        });\n        a.renderer.definition({\n          tagName: \"style\",\n          textContent: \".highcharts-tooltip-\" + a.index + \"{filter:url(#drop-shadow-\" + a.index + \")}\"\n        });\n      },\n      getLabel: function getLabel() {\n        var q = this,\n            f = this.chart.renderer,\n            e = this.chart.styledMode,\n            p = this.options,\n            r,\n            b;\n        this.label || (this.outside && (this.container = r = a.doc.createElement(\"div\"), r.className = \"highcharts-tooltip-container\", a.css(r, {\n          position: \"absolute\",\n          top: \"1px\",\n          pointerEvents: p.style && p.style.pointerEvents\n        }), a.doc.body.appendChild(r), this.renderer = f = new a.Renderer(r, 0, 0)), this.split ? this.label = f.g(\"tooltip\") : (this.label = f.label(\"\", 0, 0, p.shape || \"callout\", null, null, p.useHTML, null, \"tooltip\").attr({\n          padding: p.padding,\n          r: p.borderRadius\n        }), e || this.label.attr({\n          fill: p.backgroundColor,\n          \"stroke-width\": p.borderWidth\n        }).css(p.style).shadow(p.shadow)), e && (this.applyFilter(), this.label.addClass(\"highcharts-tooltip-\" + this.chart.index)), this.outside && (b = {\n          x: this.label.xSetter,\n          y: this.label.ySetter\n        }, this.label.xSetter = function (a, n) {\n          b[n].call(this.label, q.distance);\n          r.style.left = a + \"px\";\n        }, this.label.ySetter = function (a, n) {\n          b[n].call(this.label, q.distance);\n          r.style.top = a + \"px\";\n        }), this.label.attr({\n          zIndex: 8\n        }).add());\n        return this.label;\n      },\n      update: function update(a) {\n        this.destroy();\n        g(!0, this.chart.options.tooltip.userOptions, a);\n        this.init(this.chart, g(!0, this.options, a));\n      },\n      destroy: function destroy() {\n        this.label && (this.label = this.label.destroy());\n        this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy());\n        this.renderer && (this.renderer = this.renderer.destroy(), a.discardElement(this.container));\n        a.clearTimeout(this.hideTimer);\n        a.clearTimeout(this.tooltipTimeout);\n      },\n      move: function move(g, f, e, p) {\n        var r = this,\n            b = r.now,\n            l = !1 !== r.options.animation && !r.isHidden && (1 < Math.abs(g - b.x) || 1 < Math.abs(f - b.y)),\n            n = r.followPointer || 1 < r.len;\n        A(b, {\n          x: l ? (2 * b.x + g) / 3 : g,\n          y: l ? (b.y + f) / 2 : f,\n          anchorX: n ? void 0 : l ? (2 * b.anchorX + e) / 3 : e,\n          anchorY: n ? void 0 : l ? (b.anchorY + p) / 2 : p\n        });\n        r.getLabel().attr(b);\n        l && (a.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {\n          r && r.move(g, f, e, p);\n        }, 32));\n      },\n      hide: function hide(g) {\n        var f = this;\n        a.clearTimeout(this.hideTimer);\n        g = t(g, this.options.hideDelay, 500);\n        this.isHidden || (this.hideTimer = v(function () {\n          f.getLabel()[g ? \"fadeOut\" : \"hide\"]();\n          f.isHidden = !0;\n        }, g));\n      },\n      getAnchor: function getAnchor(a, f) {\n        var e = this.chart,\n            p = e.pointer,\n            r = e.inverted,\n            b = e.plotTop,\n            l = e.plotLeft,\n            n = 0,\n            d = 0,\n            w,\n            g;\n        a = u(a);\n        this.followPointer && f ? (void 0 === f.chartX && (f = p.normalize(f)), a = [f.chartX - e.plotLeft, f.chartY - b]) : a[0].tooltipPos ? a = a[0].tooltipPos : (a.forEach(function (a) {\n          w = a.series.yAxis;\n          g = a.series.xAxis;\n          n += a.plotX + (!r && g ? g.left - l : 0);\n          d += (a.plotLow ? (a.plotLow + a.plotHigh) / 2 : a.plotY) + (!r && w ? w.top - b : 0);\n        }), n /= a.length, d /= a.length, a = [r ? e.plotWidth - d : n, this.shared && !r && 1 < a.length && f ? f.chartY - b : r ? e.plotHeight - n : d]);\n        return a.map(Math.round);\n      },\n      getPosition: function getPosition(a, f, e) {\n        var p = this.chart,\n            r = this.distance,\n            b = {},\n            l = p.inverted && e.h || 0,\n            n,\n            d = this.outside,\n            w = d ? B.documentElement.clientWidth - 2 * r : p.chartWidth,\n            g = d ? Math.max(B.body.scrollHeight, B.documentElement.scrollHeight, B.body.offsetHeight, B.documentElement.offsetHeight, B.documentElement.clientHeight) : p.chartHeight,\n            q = p.pointer.chartPosition,\n            F = [\"y\", g, f, (d ? q.top - r : 0) + e.plotY + p.plotTop, d ? 0 : p.plotTop, d ? g : p.plotTop + p.plotHeight],\n            c = [\"x\", w, a, (d ? q.left - r : 0) + e.plotX + p.plotLeft, d ? 0 : p.plotLeft, d ? w : p.plotLeft + p.plotWidth],\n            k = !this.followPointer && t(e.ttBelow, !p.inverted === !!e.negative),\n            x = function x(a, c, h, d, _x, n) {\n          var e = h < d - r,\n              f = d + r + h < c,\n              w = d - r - h;\n          d += r;\n          if (k && f) b[a] = d;else if (!k && e) b[a] = w;else if (e) b[a] = Math.min(n - h, 0 > w - l ? w : w - l);else if (f) b[a] = Math.max(_x, d + l + h > c ? d : d + l);else return !1;\n        },\n            D = function D(a, c, k, h) {\n          var d;\n          h < r || h > c - r ? d = !1 : b[a] = h < k / 2 ? 1 : h > c - k / 2 ? c - k - 2 : h - k / 2;\n          return d;\n        },\n            h = function h(a) {\n          var k = F;\n          F = c;\n          c = k;\n          n = a;\n        },\n            z = function z() {\n          !1 !== x.apply(0, F) ? !1 !== D.apply(0, c) || n || (h(!0), z()) : n ? b.x = b.y = 0 : (h(!0), z());\n        };\n\n        (p.inverted || 1 < this.len) && h();\n        z();\n        return b;\n      },\n      defaultFormatter: function defaultFormatter(a) {\n        var f = this.points || u(this),\n            e;\n        e = [a.tooltipFooterHeaderFormatter(f[0])];\n        e = e.concat(a.bodyFormatter(f));\n        e.push(a.tooltipFooterHeaderFormatter(f[0], !0));\n        return e;\n      },\n      refresh: function refresh(g, f) {\n        var e,\n            p = this.options,\n            r,\n            b = g,\n            l,\n            n = {},\n            d = [];\n        e = p.formatter || this.defaultFormatter;\n        var n = this.shared,\n            w,\n            q = this.chart.styledMode;\n        p.enabled && (a.clearTimeout(this.hideTimer), this.followPointer = u(b)[0].series.tooltipOptions.followPointer, l = this.getAnchor(b, f), f = l[0], r = l[1], !n || b.series && b.series.noSharedTooltip ? n = b.getLabelConfig() : (b.forEach(function (a) {\n          a.setState(\"hover\");\n          d.push(a.getLabelConfig());\n        }), n = {\n          x: b[0].category,\n          y: b[0].y\n        }, n.points = d, b = b[0]), this.len = d.length, n = e.call(n, this), w = b.series, this.distance = t(w.tooltipOptions.distance, 16), !1 === n ? this.hide() : (e = this.getLabel(), this.isHidden && e.attr({\n          opacity: 1\n        }).show(), this.split ? this.renderSplit(n, u(g)) : (p.style.width && !q || e.css({\n          width: this.chart.spacingBox.width\n        }), e.attr({\n          text: n && n.join ? n.join(\"\") : n\n        }), e.removeClass(/highcharts-color-[\\d]+/g).addClass(\"highcharts-color-\" + t(b.colorIndex, w.colorIndex)), q || e.attr({\n          stroke: p.borderColor || b.color || w.color || \"#666666\"\n        }), this.updatePosition({\n          plotX: f,\n          plotY: r,\n          negative: b.negative,\n          ttBelow: b.ttBelow,\n          h: l[2] || 0\n        })), this.isHidden = !1));\n      },\n      renderSplit: function renderSplit(g, f) {\n        var e = this,\n            p = [],\n            r = this.chart,\n            b = r.renderer,\n            l = !0,\n            n = this.options,\n            d = 0,\n            w,\n            q = this.getLabel(),\n            C = r.plotTop;\n        a.isString(g) && (g = [!1, g]);\n        g.slice(0, f.length + 1).forEach(function (a, c) {\n          if (!1 !== a && \"\" !== a) {\n            c = f[c - 1] || {\n              isHeader: !0,\n              plotX: f[0].plotX,\n              plotY: r.plotHeight\n            };\n            var k = c.series || e,\n                x = k.tt,\n                g = c.series || {},\n                h = \"highcharts-color-\" + t(c.colorIndex, g.colorIndex, \"none\");\n            x || (x = {\n              padding: n.padding,\n              r: n.borderRadius\n            }, r.styledMode || (x.fill = n.backgroundColor, x.stroke = n.borderColor || c.color || g.color || \"#333333\", x[\"stroke-width\"] = n.borderWidth), k.tt = x = b.label(null, null, null, (c.isHeader ? n.headerShape : n.shape) || \"callout\", null, null, n.useHTML).addClass(\"highcharts-tooltip-box \" + h).attr(x).add(q));\n            x.isActive = !0;\n            x.attr({\n              text: a\n            });\n            r.styledMode || x.css(n.style).shadow(n.shadow);\n            a = x.getBBox();\n            g = a.width + x.strokeWidth();\n            c.isHeader ? (d = a.height, r.xAxis[0].opposite && (w = !0, C -= d), g = Math.max(0, Math.min(c.plotX + r.plotLeft - g / 2, r.chartWidth + (r.scrollablePixels ? r.scrollablePixels - r.marginRight : 0) - g))) : g = c.plotX + r.plotLeft - t(n.distance, 16) - g;\n            0 > g && (l = !1);\n            a = (c.series && c.series.yAxis && c.series.yAxis.pos) + (c.plotY || 0);\n            a -= C;\n            c.isHeader && (a = w ? -d : r.plotHeight + d);\n            p.push({\n              target: a,\n              rank: c.isHeader ? 1 : 0,\n              size: k.tt.getBBox().height + 1,\n              point: c,\n              x: g,\n              tt: x\n            });\n          }\n        });\n        this.cleanSplit();\n        n.positioner && p.forEach(function (a) {\n          var c = n.positioner.call(e, a.tt.getBBox().width, a.size, a.point);\n          a.x = c.x;\n          a.align = 0;\n          a.target = c.y;\n          a.rank = t(c.rank, a.rank);\n        });\n        a.distribute(p, r.plotHeight + d);\n        p.forEach(function (a) {\n          var c = a.point,\n              k = c.series;\n          a.tt.attr({\n            visibility: void 0 === a.pos ? \"hidden\" : \"inherit\",\n            x: l || c.isHeader || n.positioner ? a.x : c.plotX + r.plotLeft + e.distance,\n            y: a.pos + C,\n            anchorX: c.isHeader ? c.plotX + r.plotLeft : c.plotX + k.xAxis.pos,\n            anchorY: c.isHeader ? r.plotTop + r.plotHeight / 2 : c.plotY + k.yAxis.pos\n          });\n        });\n      },\n      updatePosition: function updatePosition(a) {\n        var f = this.chart,\n            e = this.getLabel(),\n            p = (this.options.positioner || this.getPosition).call(this, e.width, e.height, a),\n            r = a.plotX + f.plotLeft;\n        a = a.plotY + f.plotTop;\n        var b;\n        this.outside && (b = (this.options.borderWidth || 0) + 2 * this.distance, this.renderer.setSize(e.width + b, e.height + b, !1), r += f.pointer.chartPosition.left - p.x, a += f.pointer.chartPosition.top - p.y);\n        this.move(Math.round(p.x), Math.round(p.y || 0), r, a);\n      },\n      getDateFormat: function getDateFormat(a, f, e, p) {\n        var r = this.chart.time,\n            b = r.dateFormat(\"%m-%d %H:%M:%S.%L\", f),\n            l,\n            n,\n            d = {\n          millisecond: 15,\n          second: 12,\n          minute: 9,\n          hour: 6,\n          day: 3\n        },\n            w = \"millisecond\";\n\n        for (n in y) {\n          if (a === y.week && +r.dateFormat(\"%w\", f) === e && \"00:00:00.000\" === b.substr(6)) {\n            n = \"week\";\n            break;\n          }\n\n          if (y[n] > a) {\n            n = w;\n            break;\n          }\n\n          if (d[n] && b.substr(d[n]) !== \"01-01 00:00:00.000\".substr(d[n])) break;\n          \"week\" !== n && (w = n);\n        }\n\n        n && (l = r.resolveDTLFormat(p[n]).main);\n        return l;\n      },\n      getXDateFormat: function getXDateFormat(a, f, e) {\n        f = f.dateTimeLabelFormats;\n        var p = e && e.closestPointRange;\n        return (p ? this.getDateFormat(p, a.x, e.options.startOfWeek, f) : f.day) || f.year;\n      },\n      tooltipFooterHeaderFormatter: function tooltipFooterHeaderFormatter(g, f) {\n        var e = f ? \"footer\" : \"header\",\n            p = g.series,\n            r = p.tooltipOptions,\n            b = r.xDateFormat,\n            l = p.xAxis,\n            n = l && \"datetime\" === l.options.type && m(g.key),\n            d = r[e + \"Format\"];\n        f = {\n          isFooter: f,\n          labelConfig: g\n        };\n        a.fireEvent(this, \"headerFormatter\", f, function (a) {\n          n && !b && (b = this.getXDateFormat(g, r, l));\n          n && b && (g.point && g.point.tooltipDateKeys || [\"key\"]).forEach(function (a) {\n            d = d.replace(\"{point.\" + a + \"}\", \"{point.\" + a + \":\" + b + \"}\");\n          });\n          p.chart.styledMode && (d = this.styledModeFormat(d));\n          a.text = G(d, {\n            point: g,\n            series: p\n          }, this.chart.time);\n        });\n        return f.text;\n      },\n      bodyFormatter: function bodyFormatter(a) {\n        return a.map(function (a) {\n          var e = a.series.tooltipOptions;\n          return (e[(a.point.formatPrefix || \"point\") + \"Formatter\"] || a.point.tooltipFormatter).call(a.point, e[(a.point.formatPrefix || \"point\") + \"Format\"] || \"\");\n        });\n      },\n      styledModeFormat: function styledModeFormat(a) {\n        return a.replace('style\\x3d\"font-size: 10px\"', 'class\\x3d\"highcharts-header\"').replace(/style=\"color:{(point|series)\\.color}\"/g, 'class\\x3d\"highcharts-color-{$1.colorIndex}\"');\n      }\n    };\n  })(H);\n\n  (function (a) {\n    var B = a.addEvent,\n        A = a.attr,\n        G = a.charts,\n        m = a.color,\n        g = a.css,\n        t = a.defined,\n        u = a.extend,\n        v = a.find,\n        y = a.fireEvent,\n        q = a.isNumber,\n        f = a.isObject,\n        e = a.offset,\n        p = a.pick,\n        r = a.splat,\n        b = a.Tooltip;\n\n    a.Pointer = function (a, b) {\n      this.init(a, b);\n    };\n\n    a.Pointer.prototype = {\n      init: function init(a, n) {\n        this.options = n;\n        this.chart = a;\n        this.runChartClick = n.chart.events && !!n.chart.events.click;\n        this.pinchDown = [];\n        this.lastValidTouch = {};\n        b && (a.tooltip = new b(a, n.tooltip), this.followTouchMove = p(n.tooltip.followTouchMove, !0));\n        this.setDOMEvents();\n      },\n      zoomOption: function zoomOption(a) {\n        var b = this.chart,\n            d = b.options.chart,\n            l = d.zoomType || \"\",\n            b = b.inverted;\n        /touch/.test(a.type) && (l = p(d.pinchType, l));\n        this.zoomX = a = /x/.test(l);\n        this.zoomY = l = /y/.test(l);\n        this.zoomHor = a && !b || l && b;\n        this.zoomVert = l && !b || a && b;\n        this.hasZoom = a || l;\n      },\n      normalize: function normalize(a, b) {\n        var d;\n        d = a.touches ? a.touches.length ? a.touches.item(0) : a.changedTouches[0] : a;\n        b || (this.chartPosition = b = e(this.chart.container));\n        return u(a, {\n          chartX: Math.round(d.pageX - b.left),\n          chartY: Math.round(d.pageY - b.top)\n        });\n      },\n      getCoordinates: function getCoordinates(a) {\n        var b = {\n          xAxis: [],\n          yAxis: []\n        };\n        this.chart.axes.forEach(function (d) {\n          b[d.isXAxis ? \"xAxis\" : \"yAxis\"].push({\n            axis: d,\n            value: d.toValue(a[d.horiz ? \"chartX\" : \"chartY\"])\n          });\n        });\n        return b;\n      },\n      findNearestKDPoint: function findNearestKDPoint(a, b, d) {\n        var l;\n        a.forEach(function (a) {\n          var n = !(a.noSharedTooltip && b) && 0 > a.options.findNearestPointBy.indexOf(\"y\");\n          a = a.searchPoint(d, n);\n          if ((n = f(a, !0)) && !(n = !f(l, !0))) var n = l.distX - a.distX,\n              e = l.dist - a.dist,\n              c = (a.series.group && a.series.group.zIndex) - (l.series.group && l.series.group.zIndex),\n              n = 0 < (0 !== n && b ? n : 0 !== e ? e : 0 !== c ? c : l.series.index > a.series.index ? -1 : 1);\n          n && (l = a);\n        });\n        return l;\n      },\n      getPointFromEvent: function getPointFromEvent(a) {\n        a = a.target;\n\n        for (var b; a && !b;) {\n          b = a.point, a = a.parentNode;\n        }\n\n        return b;\n      },\n      getChartCoordinatesFromPoint: function getChartCoordinatesFromPoint(a, b) {\n        var d = a.series,\n            l = d.xAxis,\n            d = d.yAxis,\n            n = p(a.clientX, a.plotX),\n            e = a.shapeArgs;\n        if (l && d) return b ? {\n          chartX: l.len + l.pos - n,\n          chartY: d.len + d.pos - a.plotY\n        } : {\n          chartX: n + l.pos,\n          chartY: a.plotY + d.pos\n        };\n        if (e && e.x && e.y) return {\n          chartX: e.x,\n          chartY: e.y\n        };\n      },\n      getHoverData: function getHoverData(a, b, d, e, r, g) {\n        var l,\n            c = [];\n        e = !(!e || !a);\n        var k = b && !b.stickyTracking ? [b] : d.filter(function (a) {\n          return a.visible && !(!r && a.directTouch) && p(a.options.enableMouseTracking, !0) && a.stickyTracking;\n        });\n        b = (l = e ? a : this.findNearestKDPoint(k, r, g)) && l.series;\n        l && (r && !b.noSharedTooltip ? (k = d.filter(function (a) {\n          return a.visible && !(!r && a.directTouch) && p(a.options.enableMouseTracking, !0) && !a.noSharedTooltip;\n        }), k.forEach(function (a) {\n          var k = v(a.points, function (a) {\n            return a.x === l.x && !a.isNull;\n          });\n          f(k) && (a.chart.isBoosting && (k = a.getPoint(k)), c.push(k));\n        })) : c.push(l));\n        return {\n          hoverPoint: l,\n          hoverSeries: b,\n          hoverPoints: c\n        };\n      },\n      runPointActions: function runPointActions(b, e) {\n        var d = this.chart,\n            l = d.tooltip && d.tooltip.options.enabled ? d.tooltip : void 0,\n            n = l ? l.shared : !1,\n            f = e || d.hoverPoint,\n            r = f && f.series || d.hoverSeries,\n            r = this.getHoverData(f, r, d.series, \"touchmove\" !== b.type && (!!e || r && r.directTouch && this.isDirectTouch), n, b),\n            c,\n            f = r.hoverPoint;\n        c = r.hoverPoints;\n        e = (r = r.hoverSeries) && r.tooltipOptions.followPointer;\n        n = n && r && !r.noSharedTooltip;\n\n        if (f && (f !== d.hoverPoint || l && l.isHidden)) {\n          (d.hoverPoints || []).forEach(function (a) {\n            -1 === c.indexOf(a) && a.setState();\n          });\n          (c || []).forEach(function (a) {\n            a.setState(\"hover\");\n          });\n          if (d.hoverSeries !== r) r.onMouseOver();\n          d.hoverPoint && d.hoverPoint.firePointEvent(\"mouseOut\");\n          if (!f.series) return;\n          f.firePointEvent(\"mouseOver\");\n          d.hoverPoints = c;\n          d.hoverPoint = f;\n          l && l.refresh(n ? c : f, b);\n        } else e && l && !l.isHidden && (f = l.getAnchor([{}], b), l.updatePosition({\n          plotX: f[0],\n          plotY: f[1]\n        }));\n\n        this.unDocMouseMove || (this.unDocMouseMove = B(d.container.ownerDocument, \"mousemove\", function (c) {\n          var k = G[a.hoverChartIndex];\n          if (k) k.pointer.onDocumentMouseMove(c);\n        }));\n        d.axes.forEach(function (k) {\n          var d = p(k.crosshair.snap, !0),\n              l = d ? a.find(c, function (a) {\n            return a.series[k.coll] === k;\n          }) : void 0;\n          l || !d ? k.drawCrosshair(b, l) : k.hideCrosshair();\n        });\n      },\n      reset: function reset(a, b) {\n        var d = this.chart,\n            l = d.hoverSeries,\n            e = d.hoverPoint,\n            n = d.hoverPoints,\n            f = d.tooltip,\n            c = f && f.shared ? n : e;\n        a && c && r(c).forEach(function (c) {\n          c.series.isCartesian && void 0 === c.plotX && (a = !1);\n        });\n        if (a) f && c && r(c).length && (f.refresh(c), f.shared && n ? n.forEach(function (a) {\n          a.setState(a.state, !0);\n          a.series.isCartesian && (a.series.xAxis.crosshair && a.series.xAxis.drawCrosshair(null, a), a.series.yAxis.crosshair && a.series.yAxis.drawCrosshair(null, a));\n        }) : e && (e.setState(e.state, !0), d.axes.forEach(function (a) {\n          a.crosshair && a.drawCrosshair(null, e);\n        })));else {\n          if (e) e.onMouseOut();\n          n && n.forEach(function (a) {\n            a.setState();\n          });\n          if (l) l.onMouseOut();\n          f && f.hide(b);\n          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());\n          d.axes.forEach(function (a) {\n            a.hideCrosshair();\n          });\n          this.hoverX = d.hoverPoints = d.hoverPoint = null;\n        }\n      },\n      scaleGroups: function scaleGroups(a, b) {\n        var d = this.chart,\n            l;\n        d.series.forEach(function (e) {\n          l = a || e.getPlotBox();\n          e.xAxis && e.xAxis.zoomEnabled && e.group && (e.group.attr(l), e.markerGroup && (e.markerGroup.attr(l), e.markerGroup.clip(b ? d.clipRect : null)), e.dataLabelsGroup && e.dataLabelsGroup.attr(l));\n        });\n        d.clipRect.attr(b || d.clipBox);\n      },\n      dragStart: function dragStart(a) {\n        var b = this.chart;\n        b.mouseIsDown = a.type;\n        b.cancelClick = !1;\n        b.mouseDownX = this.mouseDownX = a.chartX;\n        b.mouseDownY = this.mouseDownY = a.chartY;\n      },\n      drag: function drag(a) {\n        var b = this.chart,\n            d = b.options.chart,\n            l = a.chartX,\n            e = a.chartY,\n            f = this.zoomHor,\n            r = this.zoomVert,\n            c = b.plotLeft,\n            k = b.plotTop,\n            x = b.plotWidth,\n            g = b.plotHeight,\n            h,\n            p = this.selectionMarker,\n            q = this.mouseDownX,\n            t = this.mouseDownY,\n            v = d.panKey && a[d.panKey + \"Key\"];\n        p && p.touch || (l < c ? l = c : l > c + x && (l = c + x), e < k ? e = k : e > k + g && (e = k + g), this.hasDragged = Math.sqrt(Math.pow(q - l, 2) + Math.pow(t - e, 2)), 10 < this.hasDragged && (h = b.isInsidePlot(q - c, t - k), b.hasCartesianSeries && (this.zoomX || this.zoomY) && h && !v && !p && (this.selectionMarker = p = b.renderer.rect(c, k, f ? 1 : x, r ? 1 : g, 0).attr({\n          \"class\": \"highcharts-selection-marker\",\n          zIndex: 7\n        }).add(), b.styledMode || p.attr({\n          fill: d.selectionMarkerFill || m(\"#335cad\").setOpacity(.25).get()\n        })), p && f && (l -= q, p.attr({\n          width: Math.abs(l),\n          x: (0 < l ? 0 : l) + q\n        })), p && r && (l = e - t, p.attr({\n          height: Math.abs(l),\n          y: (0 < l ? 0 : l) + t\n        })), h && !p && d.panning && b.pan(a, d.panning)));\n      },\n      drop: function drop(a) {\n        var b = this,\n            d = this.chart,\n            l = this.hasPinched;\n\n        if (this.selectionMarker) {\n          var e = {\n            originalEvent: a,\n            xAxis: [],\n            yAxis: []\n          },\n              f = this.selectionMarker,\n              r = f.attr ? f.attr(\"x\") : f.x,\n              c = f.attr ? f.attr(\"y\") : f.y,\n              k = f.attr ? f.attr(\"width\") : f.width,\n              x = f.attr ? f.attr(\"height\") : f.height,\n              p;\n          if (this.hasDragged || l) d.axes.forEach(function (h) {\n            if (h.zoomEnabled && t(h.min) && (l || b[{\n              xAxis: \"zoomX\",\n              yAxis: \"zoomY\"\n            }[h.coll]])) {\n              var d = h.horiz,\n                  n = \"touchend\" === a.type ? h.minPixelPadding : 0,\n                  f = h.toValue((d ? r : c) + n),\n                  d = h.toValue((d ? r + k : c + x) - n);\n              e[h.coll].push({\n                axis: h,\n                min: Math.min(f, d),\n                max: Math.max(f, d)\n              });\n              p = !0;\n            }\n          }), p && y(d, \"selection\", e, function (a) {\n            d.zoom(u(a, l ? {\n              animation: !1\n            } : null));\n          });\n          q(d.index) && (this.selectionMarker = this.selectionMarker.destroy());\n          l && this.scaleGroups();\n        }\n\n        d && q(d.index) && (g(d.container, {\n          cursor: d._cursor\n        }), d.cancelClick = 10 < this.hasDragged, d.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);\n      },\n      onContainerMouseDown: function onContainerMouseDown(a) {\n        a = this.normalize(a);\n        2 !== a.button && (this.zoomOption(a), a.preventDefault && a.preventDefault(), this.dragStart(a));\n      },\n      onDocumentMouseUp: function onDocumentMouseUp(b) {\n        G[a.hoverChartIndex] && G[a.hoverChartIndex].pointer.drop(b);\n      },\n      onDocumentMouseMove: function onDocumentMouseMove(a) {\n        var b = this.chart,\n            d = this.chartPosition;\n        a = this.normalize(a, d);\n        !d || this.inClass(a.target, \"highcharts-tracker\") || b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) || this.reset();\n      },\n      onContainerMouseLeave: function onContainerMouseLeave(b) {\n        var l = G[a.hoverChartIndex];\n        l && (b.relatedTarget || b.toElement) && (l.pointer.reset(), l.pointer.chartPosition = null);\n      },\n      onContainerMouseMove: function onContainerMouseMove(b) {\n        var l = this.chart;\n        t(a.hoverChartIndex) && G[a.hoverChartIndex] && G[a.hoverChartIndex].mouseIsDown || (a.hoverChartIndex = l.index);\n        b = this.normalize(b);\n        b.preventDefault || (b.returnValue = !1);\n        \"mousedown\" === l.mouseIsDown && this.drag(b);\n        !this.inClass(b.target, \"highcharts-tracker\") && !l.isInsidePlot(b.chartX - l.plotLeft, b.chartY - l.plotTop) || l.openMenu || this.runPointActions(b);\n      },\n      inClass: function inClass(a, b) {\n        for (var d; a;) {\n          if (d = A(a, \"class\")) {\n            if (-1 !== d.indexOf(b)) return !0;\n            if (-1 !== d.indexOf(\"highcharts-container\")) return !1;\n          }\n\n          a = a.parentNode;\n        }\n      },\n      onTrackerMouseOut: function onTrackerMouseOut(a) {\n        var b = this.chart.hoverSeries;\n        a = a.relatedTarget || a.toElement;\n        this.isDirectTouch = !1;\n        if (!(!b || !a || b.stickyTracking || this.inClass(a, \"highcharts-tooltip\") || this.inClass(a, \"highcharts-series-\" + b.index) && this.inClass(a, \"highcharts-tracker\"))) b.onMouseOut();\n      },\n      onContainerClick: function onContainerClick(a) {\n        var b = this.chart,\n            d = b.hoverPoint,\n            l = b.plotLeft,\n            e = b.plotTop;\n        a = this.normalize(a);\n        b.cancelClick || (d && this.inClass(a.target, \"highcharts-tracker\") ? (y(d.series, \"click\", u(a, {\n          point: d\n        })), b.hoverPoint && d.firePointEvent(\"click\", a)) : (u(a, this.getCoordinates(a)), b.isInsidePlot(a.chartX - l, a.chartY - e) && y(b, \"click\", a)));\n      },\n      setDOMEvents: function setDOMEvents() {\n        var b = this,\n            e = b.chart.container,\n            d = e.ownerDocument;\n\n        e.onmousedown = function (a) {\n          b.onContainerMouseDown(a);\n        };\n\n        e.onmousemove = function (a) {\n          b.onContainerMouseMove(a);\n        };\n\n        e.onclick = function (a) {\n          b.onContainerClick(a);\n        };\n\n        this.unbindContainerMouseLeave = B(e, \"mouseleave\", b.onContainerMouseLeave);\n        a.unbindDocumentMouseUp || (a.unbindDocumentMouseUp = B(d, \"mouseup\", b.onDocumentMouseUp));\n        a.hasTouch && (e.ontouchstart = function (a) {\n          b.onContainerTouchStart(a);\n        }, e.ontouchmove = function (a) {\n          b.onContainerTouchMove(a);\n        }, a.unbindDocumentTouchEnd || (a.unbindDocumentTouchEnd = B(d, \"touchend\", b.onDocumentTouchEnd)));\n      },\n      destroy: function destroy() {\n        var b = this;\n        b.unDocMouseMove && b.unDocMouseMove();\n        this.unbindContainerMouseLeave();\n        a.chartCount || (a.unbindDocumentMouseUp && (a.unbindDocumentMouseUp = a.unbindDocumentMouseUp()), a.unbindDocumentTouchEnd && (a.unbindDocumentTouchEnd = a.unbindDocumentTouchEnd()));\n        clearInterval(b.tooltipTimeout);\n        a.objectEach(b, function (a, d) {\n          b[d] = null;\n        });\n      }\n    };\n  })(H);\n\n  (function (a) {\n    var B = a.charts,\n        A = a.extend,\n        G = a.noop,\n        m = a.pick;\n    A(a.Pointer.prototype, {\n      pinchTranslate: function pinchTranslate(a, m, u, v, y, q) {\n        this.zoomHor && this.pinchTranslateDirection(!0, a, m, u, v, y, q);\n        this.zoomVert && this.pinchTranslateDirection(!1, a, m, u, v, y, q);\n      },\n      pinchTranslateDirection: function pinchTranslateDirection(a, m, u, v, y, q, f, e) {\n        var p = this.chart,\n            r = a ? \"x\" : \"y\",\n            b = a ? \"X\" : \"Y\",\n            l = \"chart\" + b,\n            n = a ? \"width\" : \"height\",\n            d = p[\"plot\" + (a ? \"Left\" : \"Top\")],\n            w,\n            g,\n            C = e || 1,\n            F = p.inverted,\n            c = p.bounds[a ? \"h\" : \"v\"],\n            k = 1 === m.length,\n            x = m[0][l],\n            D = u[0][l],\n            h = !k && m[1][l],\n            z = !k && u[1][l],\n            t;\n\n        u = function u() {\n          !k && 20 < Math.abs(x - h) && (C = e || Math.abs(D - z) / Math.abs(x - h));\n          g = (d - D) / C + x;\n          w = p[\"plot\" + (a ? \"Width\" : \"Height\")] / C;\n        };\n\n        u();\n        m = g;\n        m < c.min ? (m = c.min, t = !0) : m + w > c.max && (m = c.max - w, t = !0);\n        t ? (D -= .8 * (D - f[r][0]), k || (z -= .8 * (z - f[r][1])), u()) : f[r] = [D, z];\n        F || (q[r] = g - d, q[n] = w);\n        q = F ? 1 / C : C;\n        y[n] = w;\n        y[r] = m;\n        v[F ? a ? \"scaleY\" : \"scaleX\" : \"scale\" + b] = C;\n        v[\"translate\" + b] = q * d + (D - q * x);\n      },\n      pinch: function pinch(a) {\n        var g = this,\n            u = g.chart,\n            v = g.pinchDown,\n            y = a.touches,\n            q = y.length,\n            f = g.lastValidTouch,\n            e = g.hasZoom,\n            p = g.selectionMarker,\n            r = {},\n            b = 1 === q && (g.inClass(a.target, \"highcharts-tracker\") && u.runTrackerClick || g.runChartClick),\n            l = {};\n        1 < q && (g.initiated = !0);\n        e && g.initiated && !b && a.preventDefault();\n        [].map.call(y, function (a) {\n          return g.normalize(a);\n        });\n        \"touchstart\" === a.type ? ([].forEach.call(y, function (a, b) {\n          v[b] = {\n            chartX: a.chartX,\n            chartY: a.chartY\n          };\n        }), f.x = [v[0].chartX, v[1] && v[1].chartX], f.y = [v[0].chartY, v[1] && v[1].chartY], u.axes.forEach(function (a) {\n          if (a.zoomEnabled) {\n            var b = u.bounds[a.horiz ? \"h\" : \"v\"],\n                l = a.minPixelPadding,\n                e = a.toPixels(m(a.options.min, a.dataMin)),\n                f = a.toPixels(m(a.options.max, a.dataMax)),\n                n = Math.max(e, f);\n            b.min = Math.min(a.pos, Math.min(e, f) - l);\n            b.max = Math.max(a.pos + a.len, n + l);\n          }\n        }), g.res = !0) : g.followTouchMove && 1 === q ? this.runPointActions(g.normalize(a)) : v.length && (p || (g.selectionMarker = p = A({\n          destroy: G,\n          touch: !0\n        }, u.plotBox)), g.pinchTranslate(v, y, r, p, l, f), g.hasPinched = e, g.scaleGroups(r, l), g.res && (g.res = !1, this.reset(!1, 0)));\n      },\n      touch: function touch(g, t) {\n        var u = this.chart,\n            v,\n            y;\n        if (u.index !== a.hoverChartIndex) this.onContainerMouseLeave({\n          relatedTarget: !0\n        });\n        a.hoverChartIndex = u.index;\n        1 === g.touches.length ? (g = this.normalize(g), (y = u.isInsidePlot(g.chartX - u.plotLeft, g.chartY - u.plotTop)) && !u.openMenu ? (t && this.runPointActions(g), \"touchmove\" === g.type && (t = this.pinchDown, v = t[0] ? 4 <= Math.sqrt(Math.pow(t[0].chartX - g.chartX, 2) + Math.pow(t[0].chartY - g.chartY, 2)) : !1), m(v, !0) && this.pinch(g)) : t && this.reset()) : 2 === g.touches.length && this.pinch(g);\n      },\n      onContainerTouchStart: function onContainerTouchStart(a) {\n        this.zoomOption(a);\n        this.touch(a, !0);\n      },\n      onContainerTouchMove: function onContainerTouchMove(a) {\n        this.touch(a);\n      },\n      onDocumentTouchEnd: function onDocumentTouchEnd(g) {\n        B[a.hoverChartIndex] && B[a.hoverChartIndex].pointer.drop(g);\n      }\n    });\n  })(H);\n\n  (function (a) {\n    var B = a.addEvent,\n        A = a.charts,\n        G = a.css,\n        m = a.doc,\n        g = a.extend,\n        t = a.noop,\n        u = a.Pointer,\n        v = a.removeEvent,\n        y = a.win,\n        q = a.wrap;\n\n    if (!a.hasTouch && (y.PointerEvent || y.MSPointerEvent)) {\n      var f = {},\n          e = !!y.PointerEvent,\n          p = function p() {\n        var b = [];\n\n        b.item = function (a) {\n          return this[a];\n        };\n\n        a.objectEach(f, function (a) {\n          b.push({\n            pageX: a.pageX,\n            pageY: a.pageY,\n            target: a.target\n          });\n        });\n        return b;\n      },\n          r = function r(b, l, e, d) {\n        \"touch\" !== b.pointerType && b.pointerType !== b.MSPOINTER_TYPE_TOUCH || !A[a.hoverChartIndex] || (d(b), d = A[a.hoverChartIndex].pointer, d[l]({\n          type: e,\n          target: b.currentTarget,\n          preventDefault: t,\n          touches: p()\n        }));\n      };\n\n      g(u.prototype, {\n        onContainerPointerDown: function onContainerPointerDown(a) {\n          r(a, \"onContainerTouchStart\", \"touchstart\", function (a) {\n            f[a.pointerId] = {\n              pageX: a.pageX,\n              pageY: a.pageY,\n              target: a.currentTarget\n            };\n          });\n        },\n        onContainerPointerMove: function onContainerPointerMove(a) {\n          r(a, \"onContainerTouchMove\", \"touchmove\", function (a) {\n            f[a.pointerId] = {\n              pageX: a.pageX,\n              pageY: a.pageY\n            };\n            f[a.pointerId].target || (f[a.pointerId].target = a.currentTarget);\n          });\n        },\n        onDocumentPointerUp: function onDocumentPointerUp(a) {\n          r(a, \"onDocumentTouchEnd\", \"touchend\", function (a) {\n            delete f[a.pointerId];\n          });\n        },\n        batchMSEvents: function batchMSEvents(a) {\n          a(this.chart.container, e ? \"pointerdown\" : \"MSPointerDown\", this.onContainerPointerDown);\n          a(this.chart.container, e ? \"pointermove\" : \"MSPointerMove\", this.onContainerPointerMove);\n          a(m, e ? \"pointerup\" : \"MSPointerUp\", this.onDocumentPointerUp);\n        }\n      });\n      q(u.prototype, \"init\", function (a, l, e) {\n        a.call(this, l, e);\n        this.hasZoom && G(l.container, {\n          \"-ms-touch-action\": \"none\",\n          \"touch-action\": \"none\"\n        });\n      });\n      q(u.prototype, \"setDOMEvents\", function (a) {\n        a.apply(this);\n        (this.hasZoom || this.followTouchMove) && this.batchMSEvents(B);\n      });\n      q(u.prototype, \"destroy\", function (a) {\n        this.batchMSEvents(v);\n        a.call(this);\n      });\n    }\n  })(H);\n\n  (function (a) {\n    var B = a.addEvent,\n        A = a.css,\n        G = a.discardElement,\n        m = a.defined,\n        g = a.fireEvent,\n        t = a.isFirefox,\n        u = a.marginNames,\n        v = a.merge,\n        y = a.pick,\n        q = a.setAnimation,\n        f = a.stableSort,\n        e = a.win,\n        p = a.wrap;\n\n    a.Legend = function (a, b) {\n      this.init(a, b);\n    };\n\n    a.Legend.prototype = {\n      init: function init(a, b) {\n        this.chart = a;\n        this.setOptions(b);\n        b.enabled && (this.render(), B(this.chart, \"endResize\", function () {\n          this.legend.positionCheckboxes();\n        }), this.proximate ? this.unchartrender = B(this.chart, \"render\", function () {\n          this.legend.proximatePositions();\n          this.legend.positionItems();\n        }) : this.unchartrender && this.unchartrender());\n      },\n      setOptions: function setOptions(a) {\n        var b = y(a.padding, 8);\n        this.options = a;\n        this.chart.styledMode || (this.itemStyle = a.itemStyle, this.itemHiddenStyle = v(this.itemStyle, a.itemHiddenStyle));\n        this.itemMarginTop = a.itemMarginTop || 0;\n        this.padding = b;\n        this.initialItemY = b - 5;\n        this.symbolWidth = y(a.symbolWidth, 16);\n        this.pages = [];\n        this.proximate = \"proximate\" === a.layout && !this.chart.inverted;\n      },\n      update: function update(a, b) {\n        var e = this.chart;\n        this.setOptions(v(!0, this.options, a));\n        this.destroy();\n        e.isDirtyLegend = e.isDirtyBox = !0;\n        y(b, !0) && e.redraw();\n        g(this, \"afterUpdate\");\n      },\n      colorizeItem: function colorizeItem(a, b) {\n        a.legendGroup[b ? \"removeClass\" : \"addClass\"](\"highcharts-legend-item-hidden\");\n\n        if (!this.chart.styledMode) {\n          var e = this.options,\n              f = a.legendItem,\n              d = a.legendLine,\n              r = a.legendSymbol,\n              p = this.itemHiddenStyle.color,\n              e = b ? e.itemStyle.color : p,\n              q = b ? a.color || p : p,\n              m = a.options && a.options.marker,\n              c = {\n            fill: q\n          };\n          f && f.css({\n            fill: e,\n            color: e\n          });\n          d && d.attr({\n            stroke: q\n          });\n          r && (m && r.isMarker && (c = a.pointAttribs(), b || (c.stroke = c.fill = p)), r.attr(c));\n        }\n\n        g(this, \"afterColorizeItem\", {\n          item: a,\n          visible: b\n        });\n      },\n      positionItems: function positionItems() {\n        this.allItems.forEach(this.positionItem, this);\n        this.chart.isResizing || this.positionCheckboxes();\n      },\n      positionItem: function positionItem(a) {\n        var b = this.options,\n            e = b.symbolPadding,\n            b = !b.rtl,\n            f = a._legendItemPos,\n            d = f[0],\n            f = f[1],\n            r = a.checkbox;\n        if ((a = a.legendGroup) && a.element) a[m(a.translateY) ? \"animate\" : \"attr\"]({\n          translateX: b ? d : this.legendWidth - d - 2 * e - 4,\n          translateY: f\n        });\n        r && (r.x = d, r.y = f);\n      },\n      destroyItem: function destroyItem(a) {\n        var b = a.checkbox;\n        [\"legendItem\", \"legendLine\", \"legendSymbol\", \"legendGroup\"].forEach(function (b) {\n          a[b] && (a[b] = a[b].destroy());\n        });\n        b && G(a.checkbox);\n      },\n      destroy: function destroy() {\n        function a(a) {\n          this[a] && (this[a] = this[a].destroy());\n        }\n\n        this.getAllItems().forEach(function (b) {\n          [\"legendItem\", \"legendGroup\"].forEach(a, b);\n        });\n        \"clipRect up down pager nav box title group\".split(\" \").forEach(a, this);\n        this.display = null;\n      },\n      positionCheckboxes: function positionCheckboxes() {\n        var a = this.group && this.group.alignAttr,\n            b,\n            e = this.clipHeight || this.legendHeight,\n            f = this.titleHeight;\n        a && (b = a.translateY, this.allItems.forEach(function (d) {\n          var l = d.checkbox,\n              n;\n          l && (n = b + f + l.y + (this.scrollOffset || 0) + 3, A(l, {\n            left: a.translateX + d.checkboxOffset + l.x - 20 + \"px\",\n            top: n + \"px\",\n            display: this.proximate || n > b - 6 && n < b + e - 6 ? \"\" : \"none\"\n          }));\n        }, this));\n      },\n      renderTitle: function renderTitle() {\n        var a = this.options,\n            b = this.padding,\n            e = a.title,\n            f = 0;\n        e.text && (this.title || (this.title = this.chart.renderer.label(e.text, b - 3, b - 4, null, null, null, a.useHTML, null, \"legend-title\").attr({\n          zIndex: 1\n        }), this.chart.styledMode || this.title.css(e.style), this.title.add(this.group)), e.width || this.title.css({\n          width: this.maxLegendWidth + \"px\"\n        }), a = this.title.getBBox(), f = a.height, this.offsetWidth = a.width, this.contentGroup.attr({\n          translateY: f\n        }));\n        this.titleHeight = f;\n      },\n      setText: function setText(e) {\n        var b = this.options;\n        e.legendItem.attr({\n          text: b.labelFormat ? a.format(b.labelFormat, e, this.chart.time) : b.labelFormatter.call(e)\n        });\n      },\n      renderItem: function renderItem(a) {\n        var b = this.chart,\n            e = b.renderer,\n            f = this.options,\n            d = this.symbolWidth,\n            p = f.symbolPadding,\n            g = this.itemStyle,\n            r = this.itemHiddenStyle,\n            q = \"horizontal\" === f.layout ? y(f.itemDistance, 20) : 0,\n            c = !f.rtl,\n            k = a.legendItem,\n            x = !a.series,\n            D = !x && a.series.drawLegendSymbol ? a.series : a,\n            h = D.options,\n            h = this.createCheckboxForItem && h && h.showCheckbox,\n            q = d + p + q + (h ? 20 : 0),\n            z = f.useHTML,\n            m = a.options.className;\n        k || (a.legendGroup = e.g(\"legend-item\").addClass(\"highcharts-\" + D.type + \"-series highcharts-color-\" + a.colorIndex + (m ? \" \" + m : \"\") + (x ? \" highcharts-series-\" + a.index : \"\")).attr({\n          zIndex: 1\n        }).add(this.scrollGroup), a.legendItem = k = e.text(\"\", c ? d + p : -p, this.baseline || 0, z), b.styledMode || k.css(v(a.visible ? g : r)), k.attr({\n          align: c ? \"left\" : \"right\",\n          zIndex: 2\n        }).add(a.legendGroup), this.baseline || (this.fontMetrics = e.fontMetrics(b.styledMode ? 12 : g.fontSize, k), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, k.attr(\"y\", this.baseline)), this.symbolHeight = f.symbolHeight || this.fontMetrics.f, D.drawLegendSymbol(this, a), this.setItemEvents && this.setItemEvents(a, k, z), h && this.createCheckboxForItem(a));\n        this.colorizeItem(a, a.visible);\n        !b.styledMode && g.width || k.css({\n          width: (f.itemWidth || this.widthOption || b.spacingBox.width) - q\n        });\n        this.setText(a);\n        b = k.getBBox();\n        a.itemWidth = a.checkboxOffset = f.itemWidth || a.legendItemWidth || b.width + q;\n        this.maxItemWidth = Math.max(this.maxItemWidth, a.itemWidth);\n        this.totalItemWidth += a.itemWidth;\n        this.itemHeight = a.itemHeight = Math.round(a.legendItemHeight || b.height || this.symbolHeight);\n      },\n      layoutItem: function layoutItem(a) {\n        var b = this.options,\n            e = this.padding,\n            f = \"horizontal\" === b.layout,\n            d = a.itemHeight,\n            p = b.itemMarginBottom || 0,\n            g = this.itemMarginTop,\n            r = f ? y(b.itemDistance, 20) : 0,\n            q = this.maxLegendWidth,\n            b = b.alignColumns && this.totalItemWidth > q ? this.maxItemWidth : a.itemWidth;\n        f && this.itemX - e + b > q && (this.itemX = e, this.itemY += g + this.lastLineHeight + p, this.lastLineHeight = 0);\n        this.lastItemY = g + this.itemY + p;\n        this.lastLineHeight = Math.max(d, this.lastLineHeight);\n        a._legendItemPos = [this.itemX, this.itemY];\n        f ? this.itemX += b : (this.itemY += g + d + p, this.lastLineHeight = d);\n        this.offsetWidth = this.widthOption || Math.max((f ? this.itemX - e - (a.checkbox ? 0 : r) : b) + e, this.offsetWidth);\n      },\n      getAllItems: function getAllItems() {\n        var a = [];\n        this.chart.series.forEach(function (b) {\n          var e = b && b.options;\n          b && y(e.showInLegend, m(e.linkedTo) ? !1 : void 0, !0) && (a = a.concat(b.legendItems || (\"point\" === e.legendType ? b.data : b)));\n        });\n        g(this, \"afterGetAllItems\", {\n          allItems: a\n        });\n        return a;\n      },\n      getAlignment: function getAlignment() {\n        var a = this.options;\n        return this.proximate ? a.align.charAt(0) + \"tv\" : a.floating ? \"\" : a.align.charAt(0) + a.verticalAlign.charAt(0) + a.layout.charAt(0);\n      },\n      adjustMargins: function adjustMargins(a, b) {\n        var e = this.chart,\n            f = this.options,\n            d = this.getAlignment(),\n            p = void 0 !== e.options.title.margin ? e.titleOffset + e.options.title.margin : 0;\n        d && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (l, n) {\n          l.test(d) && !m(a[n]) && (e[u[n]] = Math.max(e[u[n]], e.legend[(n + 1) % 2 ? \"legendHeight\" : \"legendWidth\"] + [1, -1, -1, 1][n] * f[n % 2 ? \"x\" : \"y\"] + y(f.margin, 12) + b[n] + (0 === n && (0 === e.titleOffset ? 0 : p))));\n        });\n      },\n      proximatePositions: function proximatePositions() {\n        var e = this.chart,\n            b = [],\n            l = \"left\" === this.options.align;\n        this.allItems.forEach(function (f) {\n          var d, n;\n          d = l;\n          f.xAxis && f.points && (f.xAxis.options.reversed && (d = !d), d = a.find(d ? f.points : f.points.slice(0).reverse(), function (b) {\n            return a.isNumber(b.plotY);\n          }), n = f.legendGroup.getBBox().height, b.push({\n            target: f.visible ? (d ? d.plotY : f.xAxis.height) - .3 * n : e.plotHeight,\n            size: n,\n            item: f\n          }));\n        }, this);\n        a.distribute(b, e.plotHeight);\n        b.forEach(function (a) {\n          a.item._legendItemPos[1] = e.plotTop - e.spacing[0] + a.pos;\n        });\n      },\n      render: function render() {\n        var e = this.chart,\n            b = e.renderer,\n            l = this.group,\n            n,\n            d,\n            p,\n            q = this.box,\n            m = this.options,\n            F = this.padding;\n        this.itemX = F;\n        this.itemY = this.initialItemY;\n        this.lastItemY = this.offsetWidth = 0;\n        this.widthOption = a.relativeLength(m.width, e.spacingBox.width - F);\n        n = e.spacingBox.width - 2 * F - m.x;\n        -1 < [\"rm\", \"lm\"].indexOf(this.getAlignment().substring(0, 2)) && (n /= 2);\n        this.maxLegendWidth = this.widthOption || n;\n        l || (this.group = l = b.g(\"legend\").attr({\n          zIndex: 7\n        }).add(), this.contentGroup = b.g().attr({\n          zIndex: 1\n        }).add(l), this.scrollGroup = b.g().add(this.contentGroup));\n        this.renderTitle();\n        n = this.getAllItems();\n        f(n, function (a, b) {\n          return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);\n        });\n        m.reversed && n.reverse();\n        this.allItems = n;\n        this.display = d = !!n.length;\n        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;\n        n.forEach(this.renderItem, this);\n        n.forEach(this.layoutItem, this);\n        n = (this.widthOption || this.offsetWidth) + F;\n        p = this.lastItemY + this.lastLineHeight + this.titleHeight;\n        p = this.handleOverflow(p);\n        p += F;\n        q || (this.box = q = b.rect().addClass(\"highcharts-legend-box\").attr({\n          r: m.borderRadius\n        }).add(l), q.isNew = !0);\n        e.styledMode || q.attr({\n          stroke: m.borderColor,\n          \"stroke-width\": m.borderWidth || 0,\n          fill: m.backgroundColor || \"none\"\n        }).shadow(m.shadow);\n        0 < n && 0 < p && (q[q.isNew ? \"attr\" : \"animate\"](q.crisp.call({}, {\n          x: 0,\n          y: 0,\n          width: n,\n          height: p\n        }, q.strokeWidth())), q.isNew = !1);\n        q[d ? \"show\" : \"hide\"]();\n        e.styledMode && \"none\" === l.getStyle(\"display\") && (n = p = 0);\n        this.legendWidth = n;\n        this.legendHeight = p;\n        d && (b = e.spacingBox, /(lth|ct|rth)/.test(this.getAlignment()) && (q = b.y + e.titleOffset, b = v(b, {\n          y: 0 < e.titleOffset ? q += e.options.title.margin : q\n        })), l.align(v(m, {\n          width: n,\n          height: p,\n          verticalAlign: this.proximate ? \"top\" : m.verticalAlign\n        }), !0, b));\n        this.proximate || this.positionItems();\n        g(this, \"afterRender\");\n      },\n      handleOverflow: function handleOverflow(a) {\n        var b = this,\n            e = this.chart,\n            f = e.renderer,\n            d = this.options,\n            p = d.y,\n            g = this.padding,\n            p = e.spacingBox.height + (\"top\" === d.verticalAlign ? -p : p) - g,\n            r = d.maxHeight,\n            q,\n            c = this.clipRect,\n            k = d.navigation,\n            x = y(k.animation, !0),\n            D = k.arrowSize || 12,\n            h = this.nav,\n            z = this.pages,\n            m,\n            t = this.allItems,\n            v = function v(a) {\n          \"number\" === typeof a ? c.attr({\n            height: a\n          }) : c && (b.clipRect = c.destroy(), b.contentGroup.clip());\n          b.contentGroup.div && (b.contentGroup.div.style.clip = a ? \"rect(\" + g + \"px,9999px,\" + (g + a) + \"px,0)\" : \"auto\");\n        };\n\n        \"horizontal\" !== d.layout || \"middle\" === d.verticalAlign || d.floating || (p /= 2);\n        r && (p = Math.min(p, r));\n        z.length = 0;\n        a > p && !1 !== k.enabled ? (this.clipHeight = q = Math.max(p - 20 - this.titleHeight - g, 0), this.currentPage = y(this.currentPage, 1), this.fullHeight = a, t.forEach(function (a, c) {\n          var b = a._legendItemPos[1],\n              k = Math.round(a.legendItem.getBBox().height),\n              h = z.length;\n          if (!h || b - z[h - 1] > q && (m || b) !== z[h - 1]) z.push(m || b), h++;\n          a.pageIx = h - 1;\n          m && (t[c - 1].pageIx = h - 1);\n          c === t.length - 1 && b + k - z[h - 1] > q && b !== m && (z.push(b), a.pageIx = h);\n          b !== m && (m = b);\n        }), c || (c = b.clipRect = f.clipRect(0, g, 9999, 0), b.contentGroup.clip(c)), v(q), h || (this.nav = h = f.g().attr({\n          zIndex: 1\n        }).add(this.group), this.up = f.symbol(\"triangle\", 0, 0, D, D).on(\"click\", function () {\n          b.scroll(-1, x);\n        }).add(h), this.pager = f.text(\"\", 15, 10).addClass(\"highcharts-legend-navigation\"), e.styledMode || this.pager.css(k.style), this.pager.add(h), this.down = f.symbol(\"triangle-down\", 0, 0, D, D).on(\"click\", function () {\n          b.scroll(1, x);\n        }).add(h)), b.scroll(0), a = p) : h && (v(), this.nav = h.destroy(), this.scrollGroup.attr({\n          translateY: 1\n        }), this.clipHeight = 0);\n        return a;\n      },\n      scroll: function scroll(a, b) {\n        var e = this.pages,\n            f = e.length;\n        a = this.currentPage + a;\n        var d = this.clipHeight,\n            p = this.options.navigation,\n            g = this.pager,\n            r = this.padding;\n        a > f && (a = f);\n        0 < a && (void 0 !== b && q(b, this.chart), this.nav.attr({\n          translateX: r,\n          translateY: d + this.padding + 7 + this.titleHeight,\n          visibility: \"visible\"\n        }), this.up.attr({\n          \"class\": 1 === a ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n        }), g.attr({\n          text: a + \"/\" + f\n        }), this.down.attr({\n          x: 18 + this.pager.getBBox().width,\n          \"class\": a === f ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n        }), this.chart.styledMode || (this.up.attr({\n          fill: 1 === a ? p.inactiveColor : p.activeColor\n        }).css({\n          cursor: 1 === a ? \"default\" : \"pointer\"\n        }), this.down.attr({\n          fill: a === f ? p.inactiveColor : p.activeColor\n        }).css({\n          cursor: a === f ? \"default\" : \"pointer\"\n        })), this.scrollOffset = -e[a - 1] + this.initialItemY, this.scrollGroup.animate({\n          translateY: this.scrollOffset\n        }), this.currentPage = a, this.positionCheckboxes());\n      }\n    };\n    a.LegendSymbolMixin = {\n      drawRectangle: function drawRectangle(a, b) {\n        var e = a.symbolHeight,\n            f = a.options.squareSymbol;\n        b.legendSymbol = this.chart.renderer.rect(f ? (a.symbolWidth - e) / 2 : 0, a.baseline - e + 1, f ? e : a.symbolWidth, e, y(a.options.symbolRadius, e / 2)).addClass(\"highcharts-point\").attr({\n          zIndex: 3\n        }).add(b.legendGroup);\n      },\n      drawLineMarker: function drawLineMarker(a) {\n        var b = this.options,\n            e = b.marker,\n            f = a.symbolWidth,\n            d = a.symbolHeight,\n            p = d / 2,\n            g = this.chart.renderer,\n            r = this.legendGroup;\n        a = a.baseline - Math.round(.3 * a.fontMetrics.b);\n        var q = {};\n        this.chart.styledMode || (q = {\n          \"stroke-width\": b.lineWidth || 0\n        }, b.dashStyle && (q.dashstyle = b.dashStyle));\n        this.legendLine = g.path([\"M\", 0, a, \"L\", f, a]).addClass(\"highcharts-graph\").attr(q).add(r);\n        e && !1 !== e.enabled && f && (b = Math.min(y(e.radius, p), p), 0 === this.symbol.indexOf(\"url\") && (e = v(e, {\n          width: d,\n          height: d\n        }), b = 0), this.legendSymbol = e = g.symbol(this.symbol, f / 2 - b, a - b, 2 * b, 2 * b, e).addClass(\"highcharts-point\").add(r), e.isMarker = !0);\n      }\n    };\n    (/Trident\\/7\\.0/.test(e.navigator && e.navigator.userAgent) || t) && p(a.Legend.prototype, \"positionItem\", function (a, b) {\n      var e = this,\n          f = function f() {\n        b._legendItemPos && a.call(e, b);\n      };\n\n      f();\n      e.bubbleLegend || setTimeout(f);\n    });\n  })(H);\n\n  (function (a) {\n    var B = a.addEvent,\n        A = a.animate,\n        G = a.animObject,\n        m = a.attr,\n        g = a.doc,\n        t = a.Axis,\n        u = a.createElement,\n        v = a.defaultOptions,\n        y = a.discardElement,\n        q = a.charts,\n        f = a.css,\n        e = a.defined,\n        p = a.extend,\n        r = a.find,\n        b = a.fireEvent,\n        l = a.isNumber,\n        n = a.isObject,\n        d = a.isString,\n        w = a.Legend,\n        E = a.marginNames,\n        C = a.merge,\n        F = a.objectEach,\n        c = a.Pointer,\n        k = a.pick,\n        x = a.pInt,\n        D = a.removeEvent,\n        h = a.seriesTypes,\n        z = a.splat,\n        L = a.syncTimeout,\n        J = a.win,\n        W = a.Chart = function () {\n      this.getArgs.apply(this, arguments);\n    };\n\n    a.chart = function (a, c, b) {\n      return new W(a, c, b);\n    };\n\n    p(W.prototype, {\n      callbacks: [],\n      getArgs: function getArgs() {\n        var a = [].slice.call(arguments);\n        if (d(a[0]) || a[0].nodeName) this.renderTo = a.shift();\n        this.init(a[0], a[1]);\n      },\n      init: function init(c, k) {\n        var h,\n            d,\n            e = c.series,\n            x = c.plotOptions || {};\n        b(this, \"init\", {\n          args: arguments\n        }, function () {\n          c.series = null;\n          h = C(v, c);\n\n          for (d in h.plotOptions) {\n            h.plotOptions[d].tooltip = x[d] && C(x[d].tooltip) || void 0;\n          }\n\n          h.tooltip.userOptions = c.chart && c.chart.forExport && c.tooltip.userOptions || c.tooltip;\n          h.series = c.series = e;\n          this.userOptions = c;\n          var f = h.chart,\n              l = f.events;\n          this.margin = [];\n          this.spacing = [];\n          this.bounds = {\n            h: {},\n            v: {}\n          };\n          this.labelCollectors = [];\n          this.callback = k;\n          this.isResizing = 0;\n          this.options = h;\n          this.axes = [];\n          this.series = [];\n          this.time = c.time && Object.keys(c.time).length ? new a.Time(c.time) : a.time;\n          this.styledMode = f.styledMode;\n          this.hasCartesianSeries = f.showAxes;\n          var p = this;\n          p.index = q.length;\n          q.push(p);\n          a.chartCount++;\n          l && F(l, function (a, c) {\n            B(p, c, a);\n          });\n          p.xAxis = [];\n          p.yAxis = [];\n          p.pointCount = p.colorCounter = p.symbolCounter = 0;\n          b(p, \"afterInit\");\n          p.firstRender();\n        });\n      },\n      initSeries: function initSeries(c) {\n        var b = this.options.chart;\n        (b = h[c.type || b.type || b.defaultSeriesType]) || a.error(17, !0, this);\n        b = new b();\n        b.init(this, c);\n        return b;\n      },\n      orderSeries: function orderSeries(a) {\n        var c = this.series;\n\n        for (a = a || 0; a < c.length; a++) {\n          c[a] && (c[a].index = a, c[a].name = c[a].getName());\n        }\n      },\n      isInsidePlot: function isInsidePlot(a, c, b) {\n        var k = b ? c : a;\n        a = b ? a : c;\n        return 0 <= k && k <= this.plotWidth && 0 <= a && a <= this.plotHeight;\n      },\n      redraw: function redraw(c) {\n        b(this, \"beforeRedraw\");\n        var k = this.axes,\n            h = this.series,\n            d = this.pointer,\n            e = this.legend,\n            x = this.userOptions.legend,\n            f = this.isDirtyLegend,\n            l,\n            n,\n            g = this.hasCartesianSeries,\n            z = this.isDirtyBox,\n            r,\n            D = this.renderer,\n            q = D.isHidden(),\n            w = [];\n        this.setResponsive && this.setResponsive(!1);\n        a.setAnimation(c, this);\n        q && this.temporaryDisplay();\n        this.layOutTitles();\n\n        for (c = h.length; c--;) {\n          if (r = h[c], r.options.stacking && (l = !0, r.isDirty)) {\n            n = !0;\n            break;\n          }\n        }\n\n        if (n) for (c = h.length; c--;) {\n          r = h[c], r.options.stacking && (r.isDirty = !0);\n        }\n        h.forEach(function (a) {\n          a.isDirty && (\"point\" === a.options.legendType ? (a.updateTotals && a.updateTotals(), f = !0) : x && (x.labelFormatter || x.labelFormat) && (f = !0));\n          a.isDirtyData && b(a, \"updatedData\");\n        });\n        f && e && e.options.enabled && (e.render(), this.isDirtyLegend = !1);\n        l && this.getStacks();\n        g && k.forEach(function (a) {\n          a.updateNames();\n          a.setScale();\n        });\n        this.getMargins();\n        g && (k.forEach(function (a) {\n          a.isDirty && (z = !0);\n        }), k.forEach(function (a) {\n          var c = a.min + \",\" + a.max;\n          a.extKey !== c && (a.extKey = c, w.push(function () {\n            b(a, \"afterSetExtremes\", p(a.eventArgs, a.getExtremes()));\n            delete a.eventArgs;\n          }));\n          (z || l) && a.redraw();\n        }));\n        z && this.drawChartBox();\n        b(this, \"predraw\");\n        h.forEach(function (a) {\n          (z || a.isDirty) && a.visible && a.redraw();\n          a.isDirtyData = !1;\n        });\n        d && d.reset(!0);\n        D.draw();\n        b(this, \"redraw\");\n        b(this, \"render\");\n        q && this.temporaryDisplay(!0);\n        w.forEach(function (a) {\n          a.call();\n        });\n      },\n      get: function get(a) {\n        function c(c) {\n          return c.id === a || c.options && c.options.id === a;\n        }\n\n        var b,\n            k = this.series,\n            h;\n        b = r(this.axes, c) || r(this.series, c);\n\n        for (h = 0; !b && h < k.length; h++) {\n          b = r(k[h].points || [], c);\n        }\n\n        return b;\n      },\n      getAxes: function getAxes() {\n        var a = this,\n            c = this.options,\n            k = c.xAxis = z(c.xAxis || {}),\n            c = c.yAxis = z(c.yAxis || {});\n        b(this, \"getAxes\");\n        k.forEach(function (a, c) {\n          a.index = c;\n          a.isX = !0;\n        });\n        c.forEach(function (a, c) {\n          a.index = c;\n        });\n        k.concat(c).forEach(function (c) {\n          new t(a, c);\n        });\n        b(this, \"afterGetAxes\");\n      },\n      getSelectedPoints: function getSelectedPoints() {\n        var a = [];\n        this.series.forEach(function (c) {\n          a = a.concat((c[c.hasGroupedData ? \"points\" : \"data\"] || []).filter(function (a) {\n            return a.selected;\n          }));\n        });\n        return a;\n      },\n      getSelectedSeries: function getSelectedSeries() {\n        return this.series.filter(function (a) {\n          return a.selected;\n        });\n      },\n      setTitle: function setTitle(a, c, b) {\n        var k = this,\n            h = k.options,\n            d = k.styledMode,\n            e;\n        e = h.title = C(!d && {\n          style: {\n            color: \"#333333\",\n            fontSize: h.isStock ? \"16px\" : \"18px\"\n          }\n        }, h.title, a);\n        h = h.subtitle = C(!d && {\n          style: {\n            color: \"#666666\"\n          }\n        }, h.subtitle, c);\n        [[\"title\", a, e], [\"subtitle\", c, h]].forEach(function (a, c) {\n          var b = a[0],\n              h = k[b],\n              e = a[1];\n          a = a[2];\n          h && e && (k[b] = h = h.destroy());\n          a && !h && (k[b] = k.renderer.text(a.text, 0, 0, a.useHTML).attr({\n            align: a.align,\n            \"class\": \"highcharts-\" + b,\n            zIndex: a.zIndex || 4\n          }).add(), k[b].update = function (a) {\n            k.setTitle(!c && a, c && a);\n          }, d || k[b].css(a.style));\n        });\n        k.layOutTitles(b);\n      },\n      layOutTitles: function layOutTitles(a) {\n        var c = 0,\n            b,\n            h = this.renderer,\n            d = this.spacingBox;\n        [\"title\", \"subtitle\"].forEach(function (a) {\n          var b = this[a],\n              k = this.options[a];\n          a = \"title\" === a ? -3 : k.verticalAlign ? 0 : c + 2;\n          var e;\n          b && (this.styledMode || (e = k.style.fontSize), e = h.fontMetrics(e, b).b, b.css({\n            width: (k.width || d.width + k.widthAdjust) + \"px\"\n          }).align(p({\n            y: a + e\n          }, k), !1, \"spacingBox\"), k.floating || k.verticalAlign || (c = Math.ceil(c + b.getBBox(k.useHTML).height)));\n        }, this);\n        b = this.titleOffset !== c;\n        this.titleOffset = c;\n        !this.isDirtyBox && b && (this.isDirtyBox = this.isDirtyLegend = b, this.hasRendered && k(a, !0) && this.isDirtyBox && this.redraw());\n      },\n      getChartSize: function getChartSize() {\n        var c = this.options.chart,\n            b = c.width,\n            c = c.height,\n            k = this.renderTo;\n        e(b) || (this.containerWidth = a.getStyle(k, \"width\"));\n        e(c) || (this.containerHeight = a.getStyle(k, \"height\"));\n        this.chartWidth = Math.max(0, b || this.containerWidth || 600);\n        this.chartHeight = Math.max(0, a.relativeLength(c, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));\n      },\n      temporaryDisplay: function temporaryDisplay(c) {\n        var b = this.renderTo;\n        if (c) for (; b && b.style;) {\n          b.hcOrigStyle && (a.css(b, b.hcOrigStyle), delete b.hcOrigStyle), b.hcOrigDetached && (g.body.removeChild(b), b.hcOrigDetached = !1), b = b.parentNode;\n        } else for (; b && b.style;) {\n          g.body.contains(b) || b.parentNode || (b.hcOrigDetached = !0, g.body.appendChild(b));\n          if (\"none\" === a.getStyle(b, \"display\", !1) || b.hcOricDetached) b.hcOrigStyle = {\n            display: b.style.display,\n            height: b.style.height,\n            overflow: b.style.overflow\n          }, c = {\n            display: \"block\",\n            overflow: \"hidden\"\n          }, b !== this.renderTo && (c.height = 0), a.css(b, c), b.offsetWidth || b.style.setProperty(\"display\", \"block\", \"important\");\n          b = b.parentNode;\n          if (b === g.body) break;\n        }\n      },\n      setClassName: function setClassName(a) {\n        this.container.className = \"highcharts-container \" + (a || \"\");\n      },\n      getContainer: function getContainer() {\n        var c,\n            k = this.options,\n            h = k.chart,\n            e,\n            n;\n        c = this.renderTo;\n        var r = a.uniqueKey(),\n            z,\n            D;\n        c || (this.renderTo = c = h.renderTo);\n        d(c) && (this.renderTo = c = g.getElementById(c));\n        c || a.error(13, !0, this);\n        e = x(m(c, \"data-highcharts-chart\"));\n        l(e) && q[e] && q[e].hasRendered && q[e].destroy();\n        m(c, \"data-highcharts-chart\", this.index);\n        c.innerHTML = \"\";\n        h.skipClone || c.offsetWidth || this.temporaryDisplay();\n        this.getChartSize();\n        e = this.chartWidth;\n        n = this.chartHeight;\n        f(c, {\n          overflow: \"hidden\"\n        });\n        this.styledMode || (z = p({\n          position: \"relative\",\n          overflow: \"hidden\",\n          width: e + \"px\",\n          height: n + \"px\",\n          textAlign: \"left\",\n          lineHeight: \"normal\",\n          zIndex: 0,\n          \"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\"\n        }, h.style));\n        this.container = c = u(\"div\", {\n          id: r\n        }, z, c);\n        this._cursor = c.style.cursor;\n        this.renderer = new (a[h.renderer] || a.Renderer)(c, e, n, null, h.forExport, k.exporting && k.exporting.allowHTML, this.styledMode);\n        this.setClassName(h.className);\n        if (this.styledMode) for (D in k.defs) {\n          this.renderer.definition(k.defs[D]);\n        } else this.renderer.setStyle(h.style);\n        this.renderer.chartIndex = this.index;\n        b(this, \"afterGetContainer\");\n      },\n      getMargins: function getMargins(a) {\n        var c = this.spacing,\n            k = this.margin,\n            h = this.titleOffset;\n        this.resetMargins();\n        h && !e(k[0]) && (this.plotTop = Math.max(this.plotTop, h + this.options.title.margin + c[0]));\n        this.legend && this.legend.display && this.legend.adjustMargins(k, c);\n        b(this, \"getMargins\");\n        a || this.getAxisMargins();\n      },\n      getAxisMargins: function getAxisMargins() {\n        var a = this,\n            c = a.axisOffset = [0, 0, 0, 0],\n            b = a.margin;\n        a.hasCartesianSeries && a.axes.forEach(function (a) {\n          a.visible && a.getOffset();\n        });\n        E.forEach(function (k, h) {\n          e(b[h]) || (a[k] += c[h]);\n        });\n        a.setChartSize();\n      },\n      reflow: function reflow(c) {\n        var b = this,\n            k = b.options.chart,\n            h = b.renderTo,\n            d = e(k.width) && e(k.height),\n            x = k.width || a.getStyle(h, \"width\"),\n            k = k.height || a.getStyle(h, \"height\"),\n            h = c ? c.target : J;\n\n        if (!d && !b.isPrinting && x && k && (h === J || h === g)) {\n          if (x !== b.containerWidth || k !== b.containerHeight) a.clearTimeout(b.reflowTimeout), b.reflowTimeout = L(function () {\n            b.container && b.setSize(void 0, void 0, !1);\n          }, c ? 100 : 0);\n          b.containerWidth = x;\n          b.containerHeight = k;\n        }\n      },\n      setReflow: function setReflow(a) {\n        var c = this;\n        !1 === a || this.unbindReflow ? !1 === a && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = B(J, \"resize\", function (a) {\n          c.reflow(a);\n        }), B(this, \"destroy\", this.unbindReflow));\n      },\n      setSize: function setSize(c, k, h) {\n        var d = this,\n            e = d.renderer,\n            x;\n        d.isResizing += 1;\n        a.setAnimation(h, d);\n        d.oldChartHeight = d.chartHeight;\n        d.oldChartWidth = d.chartWidth;\n        void 0 !== c && (d.options.chart.width = c);\n        void 0 !== k && (d.options.chart.height = k);\n        d.getChartSize();\n        d.styledMode || (x = e.globalAnimation, (x ? A : f)(d.container, {\n          width: d.chartWidth + \"px\",\n          height: d.chartHeight + \"px\"\n        }, x));\n        d.setChartSize(!0);\n        e.setSize(d.chartWidth, d.chartHeight, h);\n        d.axes.forEach(function (a) {\n          a.isDirty = !0;\n          a.setScale();\n        });\n        d.isDirtyLegend = !0;\n        d.isDirtyBox = !0;\n        d.layOutTitles();\n        d.getMargins();\n        d.redraw(h);\n        d.oldChartHeight = null;\n        b(d, \"resize\");\n        L(function () {\n          d && b(d, \"endResize\", null, function () {\n            --d.isResizing;\n          });\n        }, G(x).duration);\n      },\n      setChartSize: function setChartSize(a) {\n        var c = this.inverted,\n            k = this.renderer,\n            h = this.chartWidth,\n            d = this.chartHeight,\n            e = this.options.chart,\n            x = this.spacing,\n            f = this.clipOffset,\n            l,\n            p,\n            n,\n            g;\n        this.plotLeft = l = Math.round(this.plotLeft);\n        this.plotTop = p = Math.round(this.plotTop);\n        this.plotWidth = n = Math.max(0, Math.round(h - l - this.marginRight));\n        this.plotHeight = g = Math.max(0, Math.round(d - p - this.marginBottom));\n        this.plotSizeX = c ? g : n;\n        this.plotSizeY = c ? n : g;\n        this.plotBorderWidth = e.plotBorderWidth || 0;\n        this.spacingBox = k.spacingBox = {\n          x: x[3],\n          y: x[0],\n          width: h - x[3] - x[1],\n          height: d - x[0] - x[2]\n        };\n        this.plotBox = k.plotBox = {\n          x: l,\n          y: p,\n          width: n,\n          height: g\n        };\n        h = 2 * Math.floor(this.plotBorderWidth / 2);\n        c = Math.ceil(Math.max(h, f[3]) / 2);\n        k = Math.ceil(Math.max(h, f[0]) / 2);\n        this.clipBox = {\n          x: c,\n          y: k,\n          width: Math.floor(this.plotSizeX - Math.max(h, f[1]) / 2 - c),\n          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(h, f[2]) / 2 - k))\n        };\n        a || this.axes.forEach(function (a) {\n          a.setAxisSize();\n          a.setAxisTranslation();\n        });\n        b(this, \"afterSetChartSize\", {\n          skipAxes: a\n        });\n      },\n      resetMargins: function resetMargins() {\n        b(this, \"resetMargins\");\n        var a = this,\n            c = a.options.chart;\n        [\"margin\", \"spacing\"].forEach(function (b) {\n          var h = c[b],\n              d = n(h) ? h : [h, h, h, h];\n          [\"Top\", \"Right\", \"Bottom\", \"Left\"].forEach(function (h, e) {\n            a[b][e] = k(c[b + h], d[e]);\n          });\n        });\n        E.forEach(function (c, b) {\n          a[c] = k(a.margin[b], a.spacing[b]);\n        });\n        a.axisOffset = [0, 0, 0, 0];\n        a.clipOffset = [0, 0, 0, 0];\n      },\n      drawChartBox: function drawChartBox() {\n        var a = this.options.chart,\n            c = this.renderer,\n            k = this.chartWidth,\n            h = this.chartHeight,\n            d = this.chartBackground,\n            e = this.plotBackground,\n            x = this.plotBorder,\n            f,\n            l = this.styledMode,\n            p = this.plotBGImage,\n            n = a.backgroundColor,\n            g = a.plotBackgroundColor,\n            z = a.plotBackgroundImage,\n            r,\n            D = this.plotLeft,\n            q = this.plotTop,\n            w = this.plotWidth,\n            m = this.plotHeight,\n            E = this.plotBox,\n            F = this.clipRect,\n            C = this.clipBox,\n            t = \"animate\";\n        d || (this.chartBackground = d = c.rect().addClass(\"highcharts-background\").add(), t = \"attr\");\n        if (l) f = r = d.strokeWidth();else {\n          f = a.borderWidth || 0;\n          r = f + (a.shadow ? 8 : 0);\n          n = {\n            fill: n || \"none\"\n          };\n          if (f || d[\"stroke-width\"]) n.stroke = a.borderColor, n[\"stroke-width\"] = f;\n          d.attr(n).shadow(a.shadow);\n        }\n        d[t]({\n          x: r / 2,\n          y: r / 2,\n          width: k - r - f % 2,\n          height: h - r - f % 2,\n          r: a.borderRadius\n        });\n        t = \"animate\";\n        e || (t = \"attr\", this.plotBackground = e = c.rect().addClass(\"highcharts-plot-background\").add());\n        e[t](E);\n        l || (e.attr({\n          fill: g || \"none\"\n        }).shadow(a.plotShadow), z && (p ? p.animate(E) : this.plotBGImage = c.image(z, D, q, w, m).add()));\n        F ? F.animate({\n          width: C.width,\n          height: C.height\n        }) : this.clipRect = c.clipRect(C);\n        t = \"animate\";\n        x || (t = \"attr\", this.plotBorder = x = c.rect().addClass(\"highcharts-plot-border\").attr({\n          zIndex: 1\n        }).add());\n        l || x.attr({\n          stroke: a.plotBorderColor,\n          \"stroke-width\": a.plotBorderWidth || 0,\n          fill: \"none\"\n        });\n        x[t](x.crisp({\n          x: D,\n          y: q,\n          width: w,\n          height: m\n        }, -x.strokeWidth()));\n        this.isDirtyBox = !1;\n        b(this, \"afterDrawChartBox\");\n      },\n      propFromSeries: function propFromSeries() {\n        var a = this,\n            c = a.options.chart,\n            b,\n            k = a.options.series,\n            d,\n            e;\n        [\"inverted\", \"angular\", \"polar\"].forEach(function (x) {\n          b = h[c.type || c.defaultSeriesType];\n          e = c[x] || b && b.prototype[x];\n\n          for (d = k && k.length; !e && d--;) {\n            (b = h[k[d].type]) && b.prototype[x] && (e = !0);\n          }\n\n          a[x] = e;\n        });\n      },\n      linkSeries: function linkSeries() {\n        var a = this,\n            c = a.series;\n        c.forEach(function (a) {\n          a.linkedSeries.length = 0;\n        });\n        c.forEach(function (c) {\n          var b = c.options.linkedTo;\n          d(b) && (b = \":previous\" === b ? a.series[c.index - 1] : a.get(b)) && b.linkedParent !== c && (b.linkedSeries.push(c), c.linkedParent = b, c.visible = k(c.options.visible, b.options.visible, c.visible));\n        });\n        b(this, \"afterLinkSeries\");\n      },\n      renderSeries: function renderSeries() {\n        this.series.forEach(function (a) {\n          a.translate();\n          a.render();\n        });\n      },\n      renderLabels: function renderLabels() {\n        var a = this,\n            c = a.options.labels;\n        c.items && c.items.forEach(function (b) {\n          var k = p(c.style, b.style),\n              h = x(k.left) + a.plotLeft,\n              d = x(k.top) + a.plotTop + 12;\n          delete k.left;\n          delete k.top;\n          a.renderer.text(b.html, h, d).attr({\n            zIndex: 2\n          }).css(k).add();\n        });\n      },\n      render: function render() {\n        var a = this.axes,\n            c = this.renderer,\n            b = this.options,\n            k = 0,\n            h,\n            d,\n            e;\n        this.setTitle();\n        this.legend = new w(this, b.legend);\n        this.getStacks && this.getStacks();\n        this.getMargins(!0);\n        this.setChartSize();\n        b = this.plotWidth;\n        a.some(function (a) {\n          if (a.horiz && a.visible && a.options.labels.enabled && a.series.length) return k = 21, !0;\n        });\n        h = this.plotHeight = Math.max(this.plotHeight - k, 0);\n        a.forEach(function (a) {\n          a.setScale();\n        });\n        this.getAxisMargins();\n        d = 1.1 < b / this.plotWidth;\n        e = 1.05 < h / this.plotHeight;\n        if (d || e) a.forEach(function (a) {\n          (a.horiz && d || !a.horiz && e) && a.setTickInterval(!0);\n        }), this.getMargins();\n        this.drawChartBox();\n        this.hasCartesianSeries && a.forEach(function (a) {\n          a.visible && a.render();\n        });\n        this.seriesGroup || (this.seriesGroup = c.g(\"series-group\").attr({\n          zIndex: 3\n        }).add());\n        this.renderSeries();\n        this.renderLabels();\n        this.addCredits();\n        this.setResponsive && this.setResponsive();\n        this.hasRendered = !0;\n      },\n      addCredits: function addCredits(a) {\n        var c = this;\n        a = C(!0, this.options.credits, a);\n        a.enabled && !this.credits && (this.credits = this.renderer.text(a.text + (this.mapCredits || \"\"), 0, 0).addClass(\"highcharts-credits\").on(\"click\", function () {\n          a.href && (J.location.href = a.href);\n        }).attr({\n          align: a.position.align,\n          zIndex: 8\n        }), c.styledMode || this.credits.css(a.style), this.credits.add().align(a.position), this.credits.update = function (a) {\n          c.credits = c.credits.destroy();\n          c.addCredits(a);\n        });\n      },\n      destroy: function destroy() {\n        var c = this,\n            k = c.axes,\n            h = c.series,\n            d = c.container,\n            e,\n            x = d && d.parentNode;\n        b(c, \"destroy\");\n        c.renderer.forExport ? a.erase(q, c) : q[c.index] = void 0;\n        a.chartCount--;\n        c.renderTo.removeAttribute(\"data-highcharts-chart\");\n        D(c);\n\n        for (e = k.length; e--;) {\n          k[e] = k[e].destroy();\n        }\n\n        this.scroller && this.scroller.destroy && this.scroller.destroy();\n\n        for (e = h.length; e--;) {\n          h[e] = h[e].destroy();\n        }\n\n        \"title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer\".split(\" \").forEach(function (a) {\n          var b = c[a];\n          b && b.destroy && (c[a] = b.destroy());\n        });\n        d && (d.innerHTML = \"\", D(d), x && y(d));\n        F(c, function (a, b) {\n          delete c[b];\n        });\n      },\n      firstRender: function firstRender() {\n        var k = this,\n            h = k.options;\n\n        if (!k.isReadyToRender || k.isReadyToRender()) {\n          k.getContainer();\n          k.resetMargins();\n          k.setChartSize();\n          k.propFromSeries();\n          k.getAxes();\n          (a.isArray(h.series) ? h.series : []).forEach(function (a) {\n            k.initSeries(a);\n          });\n          k.linkSeries();\n          b(k, \"beforeRender\");\n          c && (k.pointer = new c(k, h));\n          k.render();\n          if (!k.renderer.imgCount && k.onload) k.onload();\n          k.temporaryDisplay(!0);\n        }\n      },\n      onload: function onload() {\n        [this.callback].concat(this.callbacks).forEach(function (a) {\n          a && void 0 !== this.index && a.apply(this, [this]);\n        }, this);\n        b(this, \"load\");\n        b(this, \"render\");\n        e(this.index) && this.setReflow(this.options.chart.reflow);\n        this.onload = null;\n      }\n    });\n  })(H);\n\n  (function (a) {\n    var B = a.addEvent,\n        A = a.Chart;\n    B(A, \"afterSetChartSize\", function (A) {\n      var m = this.options.chart.scrollablePlotArea;\n      (m = m && m.minWidth) && !this.renderer.forExport && (this.scrollablePixels = m = Math.max(0, m - this.chartWidth)) && (this.plotWidth += m, this.clipBox.width += m, A.skipAxes || this.axes.forEach(function (g) {\n        1 === g.side ? g.getPlotLinePath = function () {\n          var m = this.right,\n              u;\n          this.right = m - g.chart.scrollablePixels;\n          u = a.Axis.prototype.getPlotLinePath.apply(this, arguments);\n          this.right = m;\n          return u;\n        } : (g.setAxisSize(), g.setAxisTranslation());\n      }));\n    });\n    B(A, \"render\", function () {\n      this.scrollablePixels ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();\n    });\n\n    A.prototype.setUpScrolling = function () {\n      this.scrollingContainer = a.createElement(\"div\", {\n        className: \"highcharts-scrolling\"\n      }, {\n        overflowX: \"auto\",\n        WebkitOverflowScrolling: \"touch\"\n      }, this.renderTo);\n      this.innerContainer = a.createElement(\"div\", {\n        className: \"highcharts-inner-container\"\n      }, null, this.scrollingContainer);\n      this.innerContainer.appendChild(this.container);\n      this.setUpScrolling = null;\n    };\n\n    A.prototype.applyFixed = function () {\n      var A = this.container,\n          m,\n          g,\n          t = !this.fixedDiv;\n      t && (this.fixedDiv = a.createElement(\"div\", {\n        className: \"highcharts-fixed\"\n      }, {\n        position: \"absolute\",\n        overflow: \"hidden\",\n        pointerEvents: \"none\",\n        zIndex: 2\n      }, null, !0), this.renderTo.insertBefore(this.fixedDiv, this.renderTo.firstChild), this.renderTo.style.overflow = \"visible\", this.fixedRenderer = m = new a.Renderer(this.fixedDiv, 0, 0), this.scrollableMask = m.path().attr({\n        fill: a.color(this.options.chart.backgroundColor || \"#fff\").setOpacity(.85).get(),\n        zIndex: -1\n      }).addClass(\"highcharts-scrollable-mask\").add(), [this.inverted ? \".highcharts-xaxis\" : \".highcharts-yaxis\", this.inverted ? \".highcharts-xaxis-labels\" : \".highcharts-yaxis-labels\", \".highcharts-contextbutton\", \".highcharts-credits\", \".highcharts-legend\", \".highcharts-subtitle\", \".highcharts-title\", \".highcharts-legend-checkbox\"].forEach(function (a) {\n        [].forEach.call(A.querySelectorAll(a), function (a) {\n          (a.namespaceURI === m.SVG_NS ? m.box : m.box.parentNode).appendChild(a);\n          a.style.pointerEvents = \"auto\";\n        });\n      }));\n      this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);\n      g = this.chartWidth + this.scrollablePixels;\n      a.stop(this.container);\n      this.container.style.width = g + \"px\";\n      this.renderer.boxWrapper.attr({\n        width: g,\n        height: this.chartHeight,\n        viewBox: [0, 0, g, this.chartHeight].join(\" \")\n      });\n      this.chartBackground.attr({\n        width: g\n      });\n      t && (g = this.options.chart.scrollablePlotArea, g.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixels * g.scrollPositionX));\n      t = this.axisOffset;\n      g = this.plotTop - t[0] - 1;\n      var t = this.plotTop + this.plotHeight + t[2],\n          u = this.plotLeft + this.plotWidth - this.scrollablePixels;\n      this.scrollableMask.attr({\n        d: this.scrollablePixels ? [\"M\", 0, g, \"L\", this.plotLeft - 1, g, \"L\", this.plotLeft - 1, t, \"L\", 0, t, \"Z\", \"M\", u, g, \"L\", this.chartWidth, g, \"L\", this.chartWidth, t, \"L\", u, t, \"Z\"] : [\"M\", 0, 0]\n      });\n    };\n  })(H);\n\n  (function (a) {\n    var B,\n        A = a.extend,\n        G = a.erase,\n        m = a.fireEvent,\n        g = a.format,\n        t = a.isArray,\n        u = a.isNumber,\n        v = a.pick,\n        y = a.uniqueKey,\n        q = a.defined,\n        f = a.removeEvent;\n\n    a.Point = B = function B() {};\n\n    a.Point.prototype = {\n      init: function init(a, f, g) {\n        var b;\n        b = a.chart.options.chart.colorCount;\n        var e = a.chart.styledMode;\n        this.series = a;\n        e || (this.color = a.color);\n        this.applyOptions(f, g);\n        this.id = q(this.id) ? this.id : y();\n        a.options.colorByPoint ? (e || (b = a.options.colors || a.chart.options.colors, this.color = this.color || b[a.colorCounter], b = b.length), f = a.colorCounter, a.colorCounter++, a.colorCounter === b && (a.colorCounter = 0)) : f = a.colorIndex;\n        this.colorIndex = v(this.colorIndex, f);\n        a.chart.pointCount++;\n        m(this, \"afterInit\");\n        return this;\n      },\n      applyOptions: function applyOptions(a, f) {\n        var e = this.series,\n            b = e.options.pointValKey || e.pointValKey;\n        a = B.prototype.optionsToObject.call(this, a);\n        A(this, a);\n        this.options = this.options ? A(this.options, a) : a;\n        a.group && delete this.group;\n        a.dataLabels && delete this.dataLabels;\n        b && (this.y = this[b]);\n        this.isNull = v(this.isValid && !this.isValid(), null === this.x || !u(this.y, !0));\n        this.selected && (this.state = \"select\");\n        \"name\" in this && void 0 === f && e.xAxis && e.xAxis.hasNames && (this.x = e.xAxis.nameToX(this));\n        void 0 === this.x && e && (this.x = void 0 === f ? e.autoIncrement(this) : f);\n        return this;\n      },\n      setNestedProperty: function setNestedProperty(e, f, g) {\n        g.split(\".\").reduce(function (b, e, p, d) {\n          b[e] = d.length - 1 === p ? f : a.isObject(b[e], !0) ? b[e] : {};\n          return b[e];\n        }, e);\n        return e;\n      },\n      optionsToObject: function optionsToObject(e) {\n        var f = {},\n            g = this.series,\n            b = g.options.keys,\n            l = b || g.pointArrayMap || [\"y\"],\n            n = l.length,\n            d = 0,\n            q = 0;\n        if (u(e) || null === e) f[l[0]] = e;else if (t(e)) for (!b && e.length > n && (g = typeof e[0], \"string\" === g ? f.name = e[0] : \"number\" === g && (f.x = e[0]), d++); q < n;) {\n          b && void 0 === e[d] || (0 < l[q].indexOf(\".\") ? a.Point.prototype.setNestedProperty(f, e[d], l[q]) : f[l[q]] = e[d]), d++, q++;\n        } else \"object\" === typeof e && (f = e, e.dataLabels && (g._hasPointLabels = !0), e.marker && (g._hasPointMarkers = !0));\n        return f;\n      },\n      getClassName: function getClassName() {\n        return \"highcharts-point\" + (this.selected ? \" highcharts-point-select\" : \"\") + (this.negative ? \" highcharts-negative\" : \"\") + (this.isNull ? \" highcharts-null-point\" : \"\") + (void 0 !== this.colorIndex ? \" highcharts-color-\" + this.colorIndex : \"\") + (this.options.className ? \" \" + this.options.className : \"\") + (this.zone && this.zone.className ? \" \" + this.zone.className.replace(\"highcharts-negative\", \"\") : \"\");\n      },\n      getZone: function getZone() {\n        var a = this.series,\n            f = a.zones,\n            a = a.zoneAxis || \"y\",\n            g = 0,\n            b;\n\n        for (b = f[g]; this[a] >= b.value;) {\n          b = f[++g];\n        }\n\n        this.nonZonedColor || (this.nonZonedColor = this.color);\n        this.color = b && b.color && !this.options.color ? b.color : this.nonZonedColor;\n        return b;\n      },\n      destroy: function destroy() {\n        var a = this.series.chart,\n            p = a.hoverPoints,\n            g;\n        a.pointCount--;\n        p && (this.setState(), G(p, this), p.length || (a.hoverPoints = null));\n        if (this === a.hoverPoint) this.onMouseOut();\n        if (this.graphic || this.dataLabel || this.dataLabels) f(this), this.destroyElements();\n        this.legendItem && a.legend.destroyItem(this);\n\n        for (g in this) {\n          this[g] = null;\n        }\n      },\n      destroyElements: function destroyElements() {\n        for (var a = [\"graphic\", \"dataLabel\", \"dataLabelUpper\", \"connector\", \"shadowGroup\"], f, g = 6; g--;) {\n          f = a[g], this[f] && (this[f] = this[f].destroy());\n        }\n\n        this.dataLabels && (this.dataLabels.forEach(function (a) {\n          a.element && a.destroy();\n        }), delete this.dataLabels);\n        this.connectors && (this.connectors.forEach(function (a) {\n          a.element && a.destroy();\n        }), delete this.connectors);\n      },\n      getLabelConfig: function getLabelConfig() {\n        return {\n          x: this.category,\n          y: this.y,\n          color: this.color,\n          colorIndex: this.colorIndex,\n          key: this.name || this.category,\n          series: this.series,\n          point: this,\n          percentage: this.percentage,\n          total: this.total || this.stackTotal\n        };\n      },\n      tooltipFormatter: function tooltipFormatter(a) {\n        var e = this.series,\n            f = e.tooltipOptions,\n            b = v(f.valueDecimals, \"\"),\n            l = f.valuePrefix || \"\",\n            n = f.valueSuffix || \"\";\n        e.chart.styledMode && (a = e.chart.tooltip.styledModeFormat(a));\n        (e.pointArrayMap || [\"y\"]).forEach(function (d) {\n          d = \"{point.\" + d;\n          if (l || n) a = a.replace(RegExp(d + \"}\", \"g\"), l + d + \"}\" + n);\n          a = a.replace(RegExp(d + \"}\", \"g\"), d + \":,.\" + b + \"f}\");\n        });\n        return g(a, {\n          point: this,\n          series: this.series\n        }, e.chart.time);\n      },\n      firePointEvent: function firePointEvent(a, f, g) {\n        var b = this,\n            e = this.series.options;\n        (e.point.events[a] || b.options && b.options.events && b.options.events[a]) && this.importEvents();\n        \"click\" === a && e.allowPointSelect && (g = function g(a) {\n          b.select && b.select(null, a.ctrlKey || a.metaKey || a.shiftKey);\n        });\n        m(this, a, f, g);\n      },\n      visible: !0\n    };\n  })(H);\n\n  (function (a) {\n    var B = a.addEvent,\n        A = a.animObject,\n        G = a.arrayMax,\n        m = a.arrayMin,\n        g = a.correctFloat,\n        t = a.defaultOptions,\n        u = a.defaultPlotOptions,\n        v = a.defined,\n        y = a.erase,\n        q = a.extend,\n        f = a.fireEvent,\n        e = a.isArray,\n        p = a.isNumber,\n        r = a.isString,\n        b = a.merge,\n        l = a.objectEach,\n        n = a.pick,\n        d = a.removeEvent,\n        w = a.splat,\n        E = a.SVGElement,\n        C = a.syncTimeout,\n        F = a.win;\n    a.Series = a.seriesType(\"line\", null, {\n      lineWidth: 2,\n      allowPointSelect: !1,\n      showCheckbox: !1,\n      animation: {\n        duration: 1E3\n      },\n      events: {},\n      marker: {\n        lineWidth: 0,\n        lineColor: \"#ffffff\",\n        enabledThreshold: 2,\n        radius: 4,\n        states: {\n          normal: {\n            animation: !0\n          },\n          hover: {\n            animation: {\n              duration: 50\n            },\n            enabled: !0,\n            radiusPlus: 2,\n            lineWidthPlus: 1\n          },\n          select: {\n            fillColor: \"#cccccc\",\n            lineColor: \"#000000\",\n            lineWidth: 2\n          }\n        }\n      },\n      point: {\n        events: {}\n      },\n      dataLabels: {\n        align: \"center\",\n        formatter: function formatter() {\n          return null === this.y ? \"\" : a.numberFormat(this.y, -1);\n        },\n        style: {\n          fontSize: \"11px\",\n          fontWeight: \"bold\",\n          color: \"contrast\",\n          textOutline: \"1px contrast\"\n        },\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0,\n        padding: 5\n      },\n      cropThreshold: 300,\n      pointRange: 0,\n      softThreshold: !0,\n      states: {\n        normal: {\n          animation: !0\n        },\n        hover: {\n          animation: {\n            duration: 50\n          },\n          lineWidthPlus: 1,\n          marker: {},\n          halo: {\n            size: 10,\n            opacity: .25\n          }\n        },\n        select: {\n          animation: {\n            duration: 0\n          }\n        }\n      },\n      stickyTracking: !0,\n      turboThreshold: 1E3,\n      findNearestPointBy: \"x\"\n    }, {\n      isCartesian: !0,\n      pointClass: a.Point,\n      sorted: !0,\n      requireSorting: !0,\n      directTouch: !1,\n      axisTypes: [\"xAxis\", \"yAxis\"],\n      colorCounter: 0,\n      parallelArrays: [\"x\", \"y\"],\n      coll: \"series\",\n      cropShoulder: 1,\n      init: function init(a, b) {\n        f(this, \"init\", {\n          options: b\n        });\n        var c = this,\n            k,\n            h = a.series,\n            d;\n        c.chart = a;\n        c.options = b = c.setOptions(b);\n        c.linkedSeries = [];\n        c.bindAxes();\n        q(c, {\n          name: b.name,\n          state: \"\",\n          visible: !1 !== b.visible,\n          selected: !0 === b.selected\n        });\n        k = b.events;\n        l(k, function (a, b) {\n          c.hcEvents && c.hcEvents[b] && -1 !== c.hcEvents[b].indexOf(a) || B(c, b, a);\n        });\n        if (k && k.click || b.point && b.point.events && b.point.events.click || b.allowPointSelect) a.runTrackerClick = !0;\n        c.getColor();\n        c.getSymbol();\n        c.parallelArrays.forEach(function (a) {\n          c[a + \"Data\"] = [];\n        });\n        c.setData(b.data, !1);\n        c.isCartesian && (a.hasCartesianSeries = !0);\n        h.length && (d = h[h.length - 1]);\n        c._i = n(d && d._i, -1) + 1;\n        a.orderSeries(this.insert(h));\n        f(this, \"afterInit\");\n      },\n      insert: function insert(a) {\n        var c = this.options.index,\n            b;\n\n        if (p(c)) {\n          for (b = a.length; b--;) {\n            if (c >= n(a[b].options.index, a[b]._i)) {\n              a.splice(b + 1, 0, this);\n              break;\n            }\n          }\n\n          -1 === b && a.unshift(this);\n          b += 1;\n        } else a.push(this);\n\n        return n(b, a.length - 1);\n      },\n      bindAxes: function bindAxes() {\n        var c = this,\n            b = c.options,\n            d = c.chart,\n            e;\n        f(this, \"bindAxes\", null, function () {\n          (c.axisTypes || []).forEach(function (k) {\n            d[k].forEach(function (a) {\n              e = a.options;\n              if (b[k] === e.index || void 0 !== b[k] && b[k] === e.id || void 0 === b[k] && 0 === e.index) c.insert(a.series), c[k] = a, a.isDirty = !0;\n            });\n            c[k] || c.optionalAxis === k || a.error(18, !0, d);\n          });\n        });\n      },\n      updateParallelArrays: function updateParallelArrays(a, b) {\n        var c = a.series,\n            k = arguments,\n            h = p(b) ? function (k) {\n          var h = \"y\" === k && c.toYData ? c.toYData(a) : a[k];\n          c[k + \"Data\"][b] = h;\n        } : function (a) {\n          Array.prototype[b].apply(c[a + \"Data\"], Array.prototype.slice.call(k, 2));\n        };\n        c.parallelArrays.forEach(h);\n      },\n      autoIncrement: function autoIncrement() {\n        var a = this.options,\n            b = this.xIncrement,\n            d,\n            e = a.pointIntervalUnit,\n            h = this.chart.time,\n            b = n(b, a.pointStart, 0);\n        this.pointInterval = d = n(this.pointInterval, a.pointInterval, 1);\n        e && (a = new h.Date(b), \"day\" === e ? h.set(\"Date\", a, h.get(\"Date\", a) + d) : \"month\" === e ? h.set(\"Month\", a, h.get(\"Month\", a) + d) : \"year\" === e && h.set(\"FullYear\", a, h.get(\"FullYear\", a) + d), d = a.getTime() - b);\n        this.xIncrement = b + d;\n        return b;\n      },\n      setOptions: function setOptions(a) {\n        var c = this.chart,\n            d = c.options,\n            e = d.plotOptions,\n            h = (c.userOptions || {}).plotOptions || {},\n            l = e[this.type],\n            g = b(a);\n        a = c.styledMode;\n        f(this, \"setOptions\", {\n          userOptions: g\n        });\n        this.userOptions = g;\n        c = b(l, e.series, g);\n        this.tooltipOptions = b(t.tooltip, t.plotOptions.series && t.plotOptions.series.tooltip, t.plotOptions[this.type].tooltip, d.tooltip.userOptions, e.series && e.series.tooltip, e[this.type].tooltip, g.tooltip);\n        this.stickyTracking = n(g.stickyTracking, h[this.type] && h[this.type].stickyTracking, h.series && h.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : c.stickyTracking);\n        null === l.marker && delete c.marker;\n        this.zoneAxis = c.zoneAxis;\n        d = this.zones = (c.zones || []).slice();\n        !c.negativeColor && !c.negativeFillColor || c.zones || (e = {\n          value: c[this.zoneAxis + \"Threshold\"] || c.threshold || 0,\n          className: \"highcharts-negative\"\n        }, a || (e.color = c.negativeColor, e.fillColor = c.negativeFillColor), d.push(e));\n        d.length && v(d[d.length - 1].value) && d.push(a ? {} : {\n          color: this.color,\n          fillColor: this.fillColor\n        });\n        f(this, \"afterSetOptions\", {\n          options: c\n        });\n        return c;\n      },\n      getName: function getName() {\n        return n(this.options.name, \"Series \" + (this.index + 1));\n      },\n      getCyclic: function getCyclic(a, b, d) {\n        var c,\n            k = this.chart,\n            e = this.userOptions,\n            f = a + \"Index\",\n            x = a + \"Counter\",\n            l = d ? d.length : n(k.options.chart[a + \"Count\"], k[a + \"Count\"]);\n        b || (c = n(e[f], e[\"_\" + f]), v(c) || (k.series.length || (k[x] = 0), e[\"_\" + f] = c = k[x] % l, k[x] += 1), d && (b = d[c]));\n        void 0 !== c && (this[f] = c);\n        this[a] = b;\n      },\n      getColor: function getColor() {\n        this.chart.styledMode ? this.getCyclic(\"color\") : this.options.colorByPoint ? this.options.color = null : this.getCyclic(\"color\", this.options.color || u[this.type].color, this.chart.options.colors);\n      },\n      getSymbol: function getSymbol() {\n        this.getCyclic(\"symbol\", this.options.marker.symbol, this.chart.options.symbols);\n      },\n      drawLegendSymbol: a.LegendSymbolMixin.drawLineMarker,\n      updateData: function updateData(c) {\n        var b = this.options,\n            d = this.points,\n            e = [],\n            h,\n            f,\n            l,\n            g = this.requireSorting;\n        this.xIncrement = null;\n        c.forEach(function (c) {\n          var k, f, x;\n          k = a.defined(c) && this.pointClass.prototype.optionsToObject.call({\n            series: this\n          }, c) || {};\n          x = k.x;\n          if ((k = k.id) || p(x)) k && (f = (f = this.chart.get(k)) && f.index), void 0 === f && p(x) && (f = this.xData.indexOf(x, l)), -1 !== f && void 0 !== f && this.cropped && (f = f >= this.cropStart ? f - this.cropStart : f), -1 === f || void 0 === f || d[f] && d[f].touched ? e.push(c) : c !== b.data[f] ? (d[f].update(c, !1, null, !1), d[f].touched = !0, g && (l = f + 1)) : d[f] && (d[f].touched = !0), h = !0;\n        }, this);\n        if (h) for (c = d.length; c--;) {\n          f = d[c], f.touched || f.remove(!1), f.touched = !1;\n        } else if (c.length === d.length) c.forEach(function (a, c) {\n          d[c].update && a !== b.data[c] && d[c].update(a, !1, null, !1);\n        });else return !1;\n        e.forEach(function (a) {\n          this.addPoint(a, !1);\n        }, this);\n        return !0;\n      },\n      setData: function setData(c, b, d, f) {\n        var k = this,\n            l = k.points,\n            x = l && l.length || 0,\n            g,\n            q = k.options,\n            w = k.chart,\n            D = null,\n            m = k.xAxis,\n            E = q.turboThreshold,\n            F = this.xData,\n            C = this.yData,\n            t = (g = k.pointArrayMap) && g.length,\n            v = q.keys,\n            u = 0,\n            y = 1,\n            A;\n        c = c || [];\n        g = c.length;\n        b = n(b, !0);\n        !1 !== f && g && x && !k.cropped && !k.hasGroupedData && k.visible && !k.isSeriesBoosting && (A = this.updateData(c));\n\n        if (!A) {\n          k.xIncrement = null;\n          k.colorCounter = 0;\n          this.parallelArrays.forEach(function (a) {\n            k[a + \"Data\"].length = 0;\n          });\n\n          if (E && g > E) {\n            for (d = 0; null === D && d < g;) {\n              D = c[d], d++;\n            }\n\n            if (p(D)) for (d = 0; d < g; d++) {\n              F[d] = this.autoIncrement(), C[d] = c[d];\n            } else if (e(D)) {\n              if (t) for (d = 0; d < g; d++) {\n                D = c[d], F[d] = D[0], C[d] = D.slice(1, t + 1);\n              } else for (v && (u = v.indexOf(\"x\"), y = v.indexOf(\"y\"), u = 0 <= u ? u : 0, y = 0 <= y ? y : 1), d = 0; d < g; d++) {\n                D = c[d], F[d] = D[u], C[d] = D[y];\n              }\n            } else a.error(12, !1, w);\n          } else for (d = 0; d < g; d++) {\n            void 0 !== c[d] && (D = {\n              series: k\n            }, k.pointClass.prototype.applyOptions.apply(D, [c[d]]), k.updateParallelArrays(D, d));\n          }\n\n          C && r(C[0]) && a.error(14, !0, w);\n          k.data = [];\n          k.options.data = k.userOptions.data = c;\n\n          for (d = x; d--;) {\n            l[d] && l[d].destroy && l[d].destroy();\n          }\n\n          m && (m.minRange = m.userMinRange);\n          k.isDirty = w.isDirtyBox = !0;\n          k.isDirtyData = !!l;\n          d = !1;\n        }\n\n        \"point\" === q.legendType && (this.processData(), this.generatePoints());\n        b && w.redraw(d);\n      },\n      processData: function processData(c) {\n        var b = this.xData,\n            d = this.yData,\n            e = b.length,\n            h;\n        h = 0;\n        var f,\n            l,\n            g = this.xAxis,\n            n,\n            p = this.options;\n        n = p.cropThreshold;\n        var q = this.getExtremesFromAll || p.getExtremesFromAll,\n            w = this.isCartesian,\n            p = g && g.val2lin,\n            r = g && g.isLog,\n            m = this.requireSorting,\n            E,\n            F;\n        if (w && !this.isDirty && !g.isDirty && !this.yAxis.isDirty && !c) return !1;\n        g && (c = g.getExtremes(), E = c.min, F = c.max);\n        w && this.sorted && !q && (!n || e > n || this.forceCrop) && (b[e - 1] < E || b[0] > F ? (b = [], d = []) : this.yData && (b[0] < E || b[e - 1] > F) && (h = this.cropData(this.xData, this.yData, E, F), b = h.xData, d = h.yData, h = h.start, f = !0));\n\n        for (n = b.length || 1; --n;) {\n          e = r ? p(b[n]) - p(b[n - 1]) : b[n] - b[n - 1], 0 < e && (void 0 === l || e < l) ? l = e : 0 > e && m && (a.error(15, !1, this.chart), m = !1);\n        }\n\n        this.cropped = f;\n        this.cropStart = h;\n        this.processedXData = b;\n        this.processedYData = d;\n        this.closestPointRange = l;\n      },\n      cropData: function cropData(a, b, d, e, h) {\n        var c = a.length,\n            k = 0,\n            f = c,\n            l;\n        h = n(h, this.cropShoulder);\n\n        for (l = 0; l < c; l++) {\n          if (a[l] >= d) {\n            k = Math.max(0, l - h);\n            break;\n          }\n        }\n\n        for (d = l; d < c; d++) {\n          if (a[d] > e) {\n            f = d + h;\n            break;\n          }\n        }\n\n        return {\n          xData: a.slice(k, f),\n          yData: b.slice(k, f),\n          start: k,\n          end: f\n        };\n      },\n      generatePoints: function generatePoints() {\n        var a = this.options,\n            b = a.data,\n            d = this.data,\n            e,\n            h = this.processedXData,\n            l = this.processedYData,\n            g = this.pointClass,\n            n = h.length,\n            p = this.cropStart || 0,\n            r,\n            m = this.hasGroupedData,\n            a = a.keys,\n            E,\n            F = [],\n            C;\n        d || m || (d = [], d.length = b.length, d = this.data = d);\n        a && m && (this.options.keys = !1);\n\n        for (C = 0; C < n; C++) {\n          r = p + C, m ? (E = new g().init(this, [h[C]].concat(w(l[C]))), E.dataGroup = this.groupMap[C], E.dataGroup.options && (E.options = E.dataGroup.options, q(E, E.dataGroup.options), delete E.dataLabels)) : (E = d[r]) || void 0 === b[r] || (d[r] = E = new g().init(this, b[r], h[C])), E && (E.index = r, F[C] = E);\n        }\n\n        this.options.keys = a;\n        if (d && (n !== (e = d.length) || m)) for (C = 0; C < e; C++) {\n          C !== p || m || (C += n), d[C] && (d[C].destroyElements(), d[C].plotX = void 0);\n        }\n        this.data = d;\n        this.points = F;\n        f(this, \"afterGeneratePoints\");\n      },\n      getExtremes: function getExtremes(a) {\n        var c = this.yAxis,\n            b = this.processedXData,\n            d,\n            h = [],\n            l = 0;\n        d = this.xAxis.getExtremes();\n        var g = d.min,\n            n = d.max,\n            q,\n            w,\n            r = this.requireSorting ? this.cropShoulder : 0,\n            E,\n            F;\n        a = a || this.stackedYData || this.processedYData || [];\n        d = a.length;\n\n        for (F = 0; F < d; F++) {\n          if (w = b[F], E = a[F], q = (p(E, !0) || e(E)) && (!c.positiveValuesOnly || E.length || 0 < E), w = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || (b[F + r] || w) >= g && (b[F - r] || w) <= n, q && w) if (q = E.length) for (; q--;) {\n            \"number\" === typeof E[q] && (h[l++] = E[q]);\n          } else h[l++] = E;\n        }\n\n        this.dataMin = m(h);\n        this.dataMax = G(h);\n        f(this, \"afterGetExtremes\");\n      },\n      translate: function translate() {\n        this.processedXData || this.processData();\n        this.generatePoints();\n        var a = this.options,\n            b = a.stacking,\n            d = this.xAxis,\n            e = d.categories,\n            h = this.yAxis,\n            l = this.points,\n            q = l.length,\n            w = !!this.modifyValue,\n            r,\n            m = this.pointPlacementToXValue(),\n            E = p(m),\n            F = a.threshold,\n            C = a.startFromThreshold ? F : 0,\n            t,\n            u,\n            y,\n            A,\n            B = this.zoneAxis || \"y\",\n            G = Number.MAX_VALUE;\n\n        for (r = 0; r < q; r++) {\n          var M = l[r],\n              V = M.x,\n              N = M.y;\n          u = M.low;\n          var H = b && h.stacks[(this.negStacks && N < (C ? 0 : F) ? \"-\" : \"\") + this.stackKey],\n              X;\n          h.positiveValuesOnly && null !== N && 0 >= N && (M.isNull = !0);\n          M.plotX = t = g(Math.min(Math.max(-1E5, d.translate(V, 0, 0, 0, 1, m, \"flags\" === this.type)), 1E5));\n          b && this.visible && !M.isNull && H && H[V] && (A = this.getStackIndicator(A, V, this.index), X = H[V], N = X.points[A.key], u = N[0], N = N[1], u === C && A.key === H[V].base && (u = n(p(F) && F, h.min)), h.positiveValuesOnly && 0 >= u && (u = null), M.total = M.stackTotal = X.total, M.percentage = X.total && M.y / X.total * 100, M.stackY = N, X.setOffset(this.pointXOffset || 0, this.barW || 0));\n          M.yBottom = v(u) ? Math.min(Math.max(-1E5, h.translate(u, 0, 1, 0, 1)), 1E5) : null;\n          w && (N = this.modifyValue(N, M));\n          M.plotY = u = \"number\" === typeof N && Infinity !== N ? Math.min(Math.max(-1E5, h.translate(N, 0, 1, 0, 1)), 1E5) : void 0;\n          M.isInside = void 0 !== u && 0 <= u && u <= h.len && 0 <= t && t <= d.len;\n          M.clientX = E ? g(d.translate(V, 0, 0, 0, 1, m)) : t;\n          M.negative = M[B] < (a[B + \"Threshold\"] || F || 0);\n          M.category = e && void 0 !== e[M.x] ? e[M.x] : M.x;\n          M.isNull || (void 0 !== y && (G = Math.min(G, Math.abs(t - y))), y = t);\n          M.zone = this.zones.length && M.getZone();\n        }\n\n        this.closestPointRangePx = G;\n        f(this, \"afterTranslate\");\n      },\n      getValidPoints: function getValidPoints(a, b, d) {\n        var c = this.chart;\n        return (a || this.points || []).filter(function (a) {\n          return b && !c.isInsidePlot(a.plotX, a.plotY, c.inverted) ? !1 : d || !a.isNull;\n        });\n      },\n      setClip: function setClip(a) {\n        var c = this.chart,\n            b = this.options,\n            d = c.renderer,\n            h = c.inverted,\n            e = this.clipBox,\n            f = e || c.clipBox,\n            l = this.sharedClipKey || [\"_sharedClip\", a && a.duration, a && a.easing, f.height, b.xAxis, b.yAxis].join(),\n            g = c[l],\n            n = c[l + \"m\"];\n        g || (a && (f.width = 0, h && (f.x = c.plotSizeX), c[l + \"m\"] = n = d.clipRect(h ? c.plotSizeX + 99 : -99, h ? -c.plotLeft : -c.plotTop, 99, h ? c.chartWidth : c.chartHeight)), c[l] = g = d.clipRect(f), g.count = {\n          length: 0\n        });\n        a && !g.count[this.index] && (g.count[this.index] = !0, g.count.length += 1);\n        !1 !== b.clip && (this.group.clip(a || e ? g : c.clipRect), this.markerGroup.clip(n), this.sharedClipKey = l);\n        a || (g.count[this.index] && (delete g.count[this.index], --g.count.length), 0 === g.count.length && l && c[l] && (e || (c[l] = c[l].destroy()), c[l + \"m\"] && (c[l + \"m\"] = c[l + \"m\"].destroy())));\n      },\n      animate: function animate(a) {\n        var c = this.chart,\n            b = A(this.options.animation),\n            d;\n        a ? this.setClip(b) : (d = this.sharedClipKey, (a = c[d]) && a.animate({\n          width: c.plotSizeX,\n          x: 0\n        }, b), c[d + \"m\"] && c[d + \"m\"].animate({\n          width: c.plotSizeX + 99,\n          x: 0\n        }, b), this.animate = null);\n      },\n      afterAnimate: function afterAnimate() {\n        this.setClip();\n        f(this, \"afterAnimate\");\n        this.finishedAnimating = !0;\n      },\n      drawPoints: function drawPoints() {\n        var a = this.points,\n            b = this.chart,\n            d,\n            e,\n            h,\n            f,\n            l = this.options.marker,\n            g,\n            p,\n            q,\n            w = this[this.specialGroup] || this.markerGroup;\n        d = this.xAxis;\n        var r,\n            m = n(l.enabled, !d || d.isRadial ? !0 : null, this.closestPointRangePx >= l.enabledThreshold * l.radius);\n        if (!1 !== l.enabled || this._hasPointMarkers) for (d = 0; d < a.length; d++) {\n          e = a[d], f = e.graphic, g = e.marker || {}, p = !!e.marker, h = m && void 0 === g.enabled || g.enabled, q = !1 !== e.isInside, h && !e.isNull ? (h = n(g.symbol, this.symbol), r = this.markerAttribs(e, e.selected && \"select\"), f ? f[q ? \"show\" : \"hide\"](!0).animate(r) : q && (0 < r.width || e.hasImage) && (e.graphic = f = b.renderer.symbol(h, r.x, r.y, r.width, r.height, p ? g : l).add(w)), f && !b.styledMode && f.attr(this.pointAttribs(e, e.selected && \"select\")), f && f.addClass(e.getClassName(), !0)) : f && (e.graphic = f.destroy());\n        }\n      },\n      markerAttribs: function markerAttribs(a, b) {\n        var c = this.options.marker,\n            k = a.marker || {},\n            h = k.symbol || c.symbol,\n            d = n(k.radius, c.radius);\n        b && (c = c.states[b], b = k.states && k.states[b], d = n(b && b.radius, c && c.radius, d + (c && c.radiusPlus || 0)));\n        a.hasImage = h && 0 === h.indexOf(\"url\");\n        a.hasImage && (d = 0);\n        a = {\n          x: Math.floor(a.plotX) - d,\n          y: a.plotY - d\n        };\n        d && (a.width = a.height = 2 * d);\n        return a;\n      },\n      pointAttribs: function pointAttribs(a, b) {\n        var c = this.options.marker,\n            k = a && a.options,\n            h = k && k.marker || {},\n            d = this.color,\n            e = k && k.color,\n            f = a && a.color,\n            k = n(h.lineWidth, c.lineWidth);\n        a = a && a.zone && a.zone.color;\n        d = e || a || f || d;\n        a = h.fillColor || c.fillColor || d;\n        d = h.lineColor || c.lineColor || d;\n        b && (c = c.states[b], b = h.states && h.states[b] || {}, k = n(b.lineWidth, c.lineWidth, k + n(b.lineWidthPlus, c.lineWidthPlus, 0)), a = b.fillColor || c.fillColor || a, d = b.lineColor || c.lineColor || d);\n        return {\n          stroke: d,\n          \"stroke-width\": k,\n          fill: a\n        };\n      },\n      destroy: function destroy(c) {\n        var b = this,\n            e = b.chart,\n            g = /AppleWebKit\\/533/.test(F.navigator.userAgent),\n            h,\n            n,\n            p = b.data || [],\n            q,\n            w;\n        f(b, \"destroy\");\n        c || d(b);\n        (b.axisTypes || []).forEach(function (a) {\n          (w = b[a]) && w.series && (y(w.series, b), w.isDirty = w.forceRedraw = !0);\n        });\n        b.legendItem && b.chart.legend.destroyItem(b);\n\n        for (n = p.length; n--;) {\n          (q = p[n]) && q.destroy && q.destroy();\n        }\n\n        b.points = null;\n        a.clearTimeout(b.animationTimeout);\n        l(b, function (a, c) {\n          a instanceof E && !a.survive && (h = g && \"group\" === c ? \"hide\" : \"destroy\", a[h]());\n        });\n        e.hoverSeries === b && (e.hoverSeries = null);\n        y(e.series, b);\n        e.orderSeries();\n        l(b, function (a, k) {\n          c && \"hcEvents\" === k || delete b[k];\n        });\n      },\n      getGraphPath: function getGraphPath(a, b, d) {\n        var c = this,\n            k = c.options,\n            e = k.step,\n            f,\n            l = [],\n            g = [],\n            n;\n        a = a || c.points;\n        (f = a.reversed) && a.reverse();\n        (e = {\n          right: 1,\n          center: 2\n        }[e] || e && 3) && f && (e = 4 - e);\n        !k.connectNulls || b || d || (a = this.getValidPoints(a));\n        a.forEach(function (h, f) {\n          var x = h.plotX,\n              p = h.plotY,\n              q = a[f - 1];\n          (h.leftCliff || q && q.rightCliff) && !d && (n = !0);\n          h.isNull && !v(b) && 0 < f ? n = !k.connectNulls : h.isNull && !b ? n = !0 : (0 === f || n ? f = [\"M\", h.plotX, h.plotY] : c.getPointSpline ? f = c.getPointSpline(a, h, f) : e ? (f = 1 === e ? [\"L\", q.plotX, p] : 2 === e ? [\"L\", (q.plotX + x) / 2, q.plotY, \"L\", (q.plotX + x) / 2, p] : [\"L\", x, q.plotY], f.push(\"L\", x, p)) : f = [\"L\", x, p], g.push(h.x), e && (g.push(h.x), 2 === e && g.push(h.x)), l.push.apply(l, f), n = !1);\n        });\n        l.xMap = g;\n        return c.graphPath = l;\n      },\n      drawGraph: function drawGraph() {\n        var a = this,\n            b = this.options,\n            d = (this.gappedPath || this.getGraphPath).call(this),\n            e = this.chart.styledMode,\n            h = [[\"graph\", \"highcharts-graph\"]];\n        e || h[0].push(b.lineColor || this.color, b.dashStyle);\n        h = a.getZonesGraphs(h);\n        h.forEach(function (c, k) {\n          var h = c[0],\n              f = a[h];\n          f ? (f.endX = a.preventGraphAnimation ? null : d.xMap, f.animate({\n            d: d\n          })) : d.length && (a[h] = a.chart.renderer.path(d).addClass(c[1]).attr({\n            zIndex: 1\n          }).add(a.group), e || (f = {\n            stroke: c[2],\n            \"stroke-width\": b.lineWidth,\n            fill: a.fillGraph && a.color || \"none\"\n          }, c[3] ? f.dashstyle = c[3] : \"square\" !== b.linecap && (f[\"stroke-linecap\"] = f[\"stroke-linejoin\"] = \"round\"), f = a[h].attr(f).shadow(2 > k && b.shadow)));\n          f && (f.startX = d.xMap, f.isArea = d.isArea);\n        });\n      },\n      getZonesGraphs: function getZonesGraphs(a) {\n        this.zones.forEach(function (c, b) {\n          b = [\"zone-graph-\" + b, \"highcharts-graph highcharts-zone-graph-\" + b + \" \" + (c.className || \"\")];\n          this.chart.styledMode || b.push(c.color || this.color, c.dashStyle || this.options.dashStyle);\n          a.push(b);\n        }, this);\n        return a;\n      },\n      applyZones: function applyZones() {\n        var a = this,\n            b = this.chart,\n            d = b.renderer,\n            e = this.zones,\n            h,\n            f,\n            l = this.clips || [],\n            g,\n            p = this.graph,\n            q = this.area,\n            w = Math.max(b.chartWidth, b.chartHeight),\n            r = this[(this.zoneAxis || \"y\") + \"Axis\"],\n            m,\n            E,\n            F = b.inverted,\n            C,\n            t,\n            v,\n            u,\n            y = !1;\n        e.length && (p || q) && r && void 0 !== r.min && (E = r.reversed, C = r.horiz, p && !this.showLine && p.hide(), q && q.hide(), m = r.getExtremes(), e.forEach(function (c, k) {\n          h = E ? C ? b.plotWidth : 0 : C ? 0 : r.toPixels(m.min) || 0;\n          h = Math.min(Math.max(n(f, h), 0), w);\n          f = Math.min(Math.max(Math.round(r.toPixels(n(c.value, m.max), !0) || 0), 0), w);\n          y && (h = f = r.toPixels(m.max));\n          t = Math.abs(h - f);\n          v = Math.min(h, f);\n          u = Math.max(h, f);\n          r.isXAxis ? (g = {\n            x: F ? u : v,\n            y: 0,\n            width: t,\n            height: w\n          }, C || (g.x = b.plotHeight - g.x)) : (g = {\n            x: 0,\n            y: F ? u : v,\n            width: w,\n            height: t\n          }, C && (g.y = b.plotWidth - g.y));\n          F && d.isVML && (g = r.isXAxis ? {\n            x: 0,\n            y: E ? v : u,\n            height: g.width,\n            width: b.chartWidth\n          } : {\n            x: g.y - b.plotLeft - b.spacingBox.x,\n            y: 0,\n            width: g.height,\n            height: b.chartHeight\n          });\n          l[k] ? l[k].animate(g) : (l[k] = d.clipRect(g), p && a[\"zone-graph-\" + k].clip(l[k]), q && a[\"zone-area-\" + k].clip(l[k]));\n          y = c.value > m.max;\n          a.resetZones && 0 === f && (f = void 0);\n        }), this.clips = l);\n      },\n      invertGroups: function invertGroups(a) {\n        function c() {\n          [\"group\", \"markerGroup\"].forEach(function (c) {\n            b[c] && (d.renderer.isVML && b[c].attr({\n              width: b.yAxis.len,\n              height: b.xAxis.len\n            }), b[c].width = b.yAxis.len, b[c].height = b.xAxis.len, b[c].invert(a));\n          });\n        }\n\n        var b = this,\n            d = b.chart,\n            h;\n        b.xAxis && (h = B(d, \"resize\", c), B(b, \"destroy\", h), c(a), b.invertGroups = c);\n      },\n      plotGroup: function plotGroup(a, b, d, e, h) {\n        var c = this[a],\n            k = !c;\n        k && (this[a] = c = this.chart.renderer.g().attr({\n          zIndex: e || .1\n        }).add(h));\n        c.addClass(\"highcharts-\" + b + \" highcharts-series-\" + this.index + \" highcharts-\" + this.type + \"-series \" + (v(this.colorIndex) ? \"highcharts-color-\" + this.colorIndex + \" \" : \"\") + (this.options.className || \"\") + (c.hasClass(\"highcharts-tracker\") ? \" highcharts-tracker\" : \"\"), !0);\n        c.attr({\n          visibility: d\n        })[k ? \"attr\" : \"animate\"](this.getPlotBox());\n        return c;\n      },\n      getPlotBox: function getPlotBox() {\n        var a = this.chart,\n            b = this.xAxis,\n            d = this.yAxis;\n        a.inverted && (b = d, d = this.xAxis);\n        return {\n          translateX: b ? b.left : a.plotLeft,\n          translateY: d ? d.top : a.plotTop,\n          scaleX: 1,\n          scaleY: 1\n        };\n      },\n      render: function render() {\n        var a = this,\n            b = a.chart,\n            d,\n            e = a.options,\n            h = !!a.animate && b.renderer.isSVG && A(e.animation).duration,\n            l = a.visible ? \"inherit\" : \"hidden\",\n            g = e.zIndex,\n            n = a.hasRendered,\n            p = b.seriesGroup,\n            q = b.inverted;\n        f(this, \"render\");\n        d = a.plotGroup(\"group\", \"series\", l, g, p);\n        a.markerGroup = a.plotGroup(\"markerGroup\", \"markers\", l, g, p);\n        h && a.animate(!0);\n        d.inverted = a.isCartesian ? q : !1;\n        a.drawGraph && (a.drawGraph(), a.applyZones());\n        a.drawDataLabels && a.drawDataLabels();\n        a.visible && a.drawPoints();\n        a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();\n        a.invertGroups(q);\n        !1 === e.clip || a.sharedClipKey || n || d.clip(b.clipRect);\n        h && a.animate();\n        n || (a.animationTimeout = C(function () {\n          a.afterAnimate();\n        }, h));\n        a.isDirty = !1;\n        a.hasRendered = !0;\n        f(a, \"afterRender\");\n      },\n      redraw: function redraw() {\n        var a = this.chart,\n            b = this.isDirty || this.isDirtyData,\n            d = this.group,\n            e = this.xAxis,\n            h = this.yAxis;\n        d && (a.inverted && d.attr({\n          width: a.plotWidth,\n          height: a.plotHeight\n        }), d.animate({\n          translateX: n(e && e.left, a.plotLeft),\n          translateY: n(h && h.top, a.plotTop)\n        }));\n        this.translate();\n        this.render();\n        b && delete this.kdTree;\n      },\n      kdAxisArray: [\"clientX\", \"plotY\"],\n      searchPoint: function searchPoint(a, b) {\n        var c = this.xAxis,\n            k = this.yAxis,\n            h = this.chart.inverted;\n        return this.searchKDTree({\n          clientX: h ? c.len - a.chartY + c.pos : a.chartX - c.pos,\n          plotY: h ? k.len - a.chartX + k.pos : a.chartY - k.pos\n        }, b, a);\n      },\n      buildKDTree: function buildKDTree(a) {\n        function c(a, k, d) {\n          var h, e;\n          if (e = a && a.length) return h = b.kdAxisArray[k % d], a.sort(function (a, c) {\n            return a[h] - c[h];\n          }), e = Math.floor(e / 2), {\n            point: a[e],\n            left: c(a.slice(0, e), k + 1, d),\n            right: c(a.slice(e + 1), k + 1, d)\n          };\n        }\n\n        this.buildingKdTree = !0;\n        var b = this,\n            d = -1 < b.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        delete b.kdTree;\n        C(function () {\n          b.kdTree = c(b.getValidPoints(null, !b.directTouch), d, d);\n          b.buildingKdTree = !1;\n        }, b.options.kdNow || a && \"touchstart\" === a.type ? 0 : 1);\n      },\n      searchKDTree: function searchKDTree(a, b, d) {\n        function c(a, b, d, h) {\n          var g = b.point,\n              n = k.kdAxisArray[d % h],\n              p,\n              x,\n              q = g;\n          x = v(a[e]) && v(g[e]) ? Math.pow(a[e] - g[e], 2) : null;\n          p = v(a[f]) && v(g[f]) ? Math.pow(a[f] - g[f], 2) : null;\n          p = (x || 0) + (p || 0);\n          g.dist = v(p) ? Math.sqrt(p) : Number.MAX_VALUE;\n          g.distX = v(x) ? Math.sqrt(x) : Number.MAX_VALUE;\n          n = a[n] - g[n];\n          p = 0 > n ? \"left\" : \"right\";\n          x = 0 > n ? \"right\" : \"left\";\n          b[p] && (p = c(a, b[p], d + 1, h), q = p[l] < q[l] ? p : g);\n          b[x] && Math.sqrt(n * n) < q[l] && (a = c(a, b[x], d + 1, h), q = a[l] < q[l] ? a : q);\n          return q;\n        }\n\n        var k = this,\n            e = this.kdAxisArray[0],\n            f = this.kdAxisArray[1],\n            l = b ? \"distX\" : \"dist\";\n        b = -1 < k.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        this.kdTree || this.buildingKdTree || this.buildKDTree(d);\n        if (this.kdTree) return c(a, this.kdTree, b, b);\n      },\n      pointPlacementToXValue: function pointPlacementToXValue() {\n        var a = this.options.pointPlacement;\n        \"between\" === a && (a = .5);\n        p(a) && (a *= n(this.options.pointRange || this.xAxis.pointRange));\n        return a;\n      }\n    });\n  })(H);\n\n  (function (a) {\n    var B = a.Axis,\n        A = a.Chart,\n        G = a.correctFloat,\n        m = a.defined,\n        g = a.destroyObjectProperties,\n        t = a.format,\n        u = a.objectEach,\n        v = a.pick,\n        y = a.Series;\n\n    a.StackItem = function (a, f, e, g, r) {\n      var b = a.chart.inverted;\n      this.axis = a;\n      this.isNegative = e;\n      this.options = f;\n      this.x = g;\n      this.total = null;\n      this.points = {};\n      this.stack = r;\n      this.rightCliff = this.leftCliff = 0;\n      this.alignOptions = {\n        align: f.align || (b ? e ? \"left\" : \"right\" : \"center\"),\n        verticalAlign: f.verticalAlign || (b ? \"middle\" : e ? \"bottom\" : \"top\"),\n        y: v(f.y, b ? 4 : e ? 14 : -6),\n        x: v(f.x, b ? e ? -6 : 6 : 0)\n      };\n      this.textAlign = f.textAlign || (b ? e ? \"right\" : \"left\" : \"center\");\n    };\n\n    a.StackItem.prototype = {\n      destroy: function destroy() {\n        g(this, this.axis);\n      },\n      render: function render(a) {\n        var f = this.axis.chart,\n            e = this.options,\n            g = e.format,\n            g = g ? t(g, this, f.time) : e.formatter.call(this);\n        this.label ? this.label.attr({\n          text: g,\n          visibility: \"hidden\"\n        }) : this.label = f.renderer.text(g, null, null, e.useHTML).css(e.style).attr({\n          align: this.textAlign,\n          rotation: e.rotation,\n          visibility: \"hidden\"\n        }).add(a);\n        this.label.labelrank = f.plotHeight;\n      },\n      setOffset: function setOffset(a, f) {\n        var e = this.axis,\n            g = e.chart,\n            q = e.translate(e.usePercentage ? 100 : this.total, 0, 0, 0, 1),\n            b = e.translate(0),\n            b = m(q) && Math.abs(q - b);\n        a = g.xAxis[0].translate(this.x) + a;\n        e = m(q) && this.getStackBox(g, this, a, q, f, b, e);\n        (f = this.label) && e && (f.align(this.alignOptions, null, e), e = f.alignAttr, f[!1 === this.options.crop || g.isInsidePlot(e.x, e.y) ? \"show\" : \"hide\"](!0));\n      },\n      getStackBox: function getStackBox(a, f, e, g, r, b, l) {\n        var n = f.axis.reversed,\n            d = a.inverted;\n        a = l.height + l.pos - (d ? a.plotLeft : a.plotTop);\n        f = f.isNegative && !n || !f.isNegative && n;\n        return {\n          x: d ? f ? g : g - b : e,\n          y: d ? a - e - r : f ? a - g - b : a - g,\n          width: d ? b : r,\n          height: d ? r : b\n        };\n      }\n    };\n\n    A.prototype.getStacks = function () {\n      var a = this;\n      a.yAxis.forEach(function (a) {\n        a.stacks && a.hasVisibleSeries && (a.oldStacks = a.stacks);\n      });\n      a.series.forEach(function (f) {\n        !f.options.stacking || !0 !== f.visible && !1 !== a.options.chart.ignoreHiddenSeries || (f.stackKey = f.type + v(f.options.stack, \"\"));\n      });\n    };\n\n    B.prototype.buildStacks = function () {\n      var a = this.series,\n          f = v(this.options.reversedStacks, !0),\n          e = a.length,\n          g;\n\n      if (!this.isXAxis) {\n        this.usePercentage = !1;\n\n        for (g = e; g--;) {\n          a[f ? g : e - g - 1].setStackedPoints();\n        }\n\n        for (g = 0; g < e; g++) {\n          a[g].modifyStacks();\n        }\n      }\n    };\n\n    B.prototype.renderStackTotals = function () {\n      var a = this.chart,\n          f = a.renderer,\n          e = this.stacks,\n          g = this.stackTotalGroup;\n      g || (this.stackTotalGroup = g = f.g(\"stack-labels\").attr({\n        visibility: \"visible\",\n        zIndex: 6\n      }).add());\n      g.translate(a.plotLeft, a.plotTop);\n      u(e, function (a) {\n        u(a, function (a) {\n          a.render(g);\n        });\n      });\n    };\n\n    B.prototype.resetStacks = function () {\n      var a = this,\n          f = a.stacks;\n      a.isXAxis || u(f, function (e) {\n        u(e, function (f, g) {\n          f.touched < a.stacksTouched ? (f.destroy(), delete e[g]) : (f.total = null, f.cumulative = null);\n        });\n      });\n    };\n\n    B.prototype.cleanStacks = function () {\n      var a;\n      this.isXAxis || (this.oldStacks && (a = this.stacks = this.oldStacks), u(a, function (a) {\n        u(a, function (a) {\n          a.cumulative = a.total;\n        });\n      }));\n    };\n\n    y.prototype.setStackedPoints = function () {\n      if (this.options.stacking && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {\n        var g = this.processedXData,\n            f = this.processedYData,\n            e = [],\n            p = f.length,\n            r = this.options,\n            b = r.threshold,\n            l = v(r.startFromThreshold && b, 0),\n            n = r.stack,\n            r = r.stacking,\n            d = this.stackKey,\n            w = \"-\" + d,\n            E = this.negStacks,\n            C = this.yAxis,\n            F = C.stacks,\n            c = C.oldStacks,\n            k,\n            x,\n            D,\n            h,\n            z,\n            t,\n            u;\n        C.stacksTouched += 1;\n\n        for (z = 0; z < p; z++) {\n          t = g[z], u = f[z], k = this.getStackIndicator(k, t, this.index), h = k.key, D = (x = E && u < (l ? 0 : b)) ? w : d, F[D] || (F[D] = {}), F[D][t] || (c[D] && c[D][t] ? (F[D][t] = c[D][t], F[D][t].total = null) : F[D][t] = new a.StackItem(C, C.options.stackLabels, x, t, n)), D = F[D][t], null !== u ? (D.points[h] = D.points[this.index] = [v(D.cumulative, l)], m(D.cumulative) || (D.base = h), D.touched = C.stacksTouched, 0 < k.index && !1 === this.singleStacks && (D.points[h][0] = D.points[this.index + \",\" + t + \",0\"][0])) : D.points[h] = D.points[this.index] = null, \"percent\" === r ? (x = x ? d : w, E && F[x] && F[x][t] ? (x = F[x][t], D.total = x.total = Math.max(x.total, D.total) + Math.abs(u) || 0) : D.total = G(D.total + (Math.abs(u) || 0))) : D.total = G(D.total + (u || 0)), D.cumulative = v(D.cumulative, l) + (u || 0), null !== u && (D.points[h].push(D.cumulative), e[z] = D.cumulative);\n        }\n\n        \"percent\" === r && (C.usePercentage = !0);\n        this.stackedYData = e;\n        C.oldStacks = {};\n      }\n    };\n\n    y.prototype.modifyStacks = function () {\n      var a = this,\n          f = a.stackKey,\n          e = a.yAxis.stacks,\n          g = a.processedXData,\n          r,\n          b = a.options.stacking;\n      a[b + \"Stacker\"] && [f, \"-\" + f].forEach(function (f) {\n        for (var l = g.length, d, p; l--;) {\n          if (d = g[l], r = a.getStackIndicator(r, d, a.index, f), p = (d = e[f] && e[f][d]) && d.points[r.key]) a[b + \"Stacker\"](p, d, l);\n        }\n      });\n    };\n\n    y.prototype.percentStacker = function (a, f, e) {\n      f = f.total ? 100 / f.total : 0;\n      a[0] = G(a[0] * f);\n      a[1] = G(a[1] * f);\n      this.stackedYData[e] = a[1];\n    };\n\n    y.prototype.getStackIndicator = function (a, f, e, g) {\n      !m(a) || a.x !== f || g && a.key !== g ? a = {\n        x: f,\n        index: 0,\n        key: g\n      } : a.index++;\n      a.key = [e, f, a.index].join();\n      return a;\n    };\n  })(H);\n\n  (function (a) {\n    var B = a.addEvent,\n        A = a.animate,\n        G = a.Axis,\n        m = a.Chart,\n        g = a.createElement,\n        t = a.css,\n        u = a.defined,\n        v = a.erase,\n        y = a.extend,\n        q = a.fireEvent,\n        f = a.isNumber,\n        e = a.isObject,\n        p = a.isArray,\n        r = a.merge,\n        b = a.objectEach,\n        l = a.pick,\n        n = a.Point,\n        d = a.Series,\n        w = a.seriesTypes,\n        E = a.setAnimation,\n        C = a.splat;\n\n    a.cleanRecursively = function (d, c) {\n      var k = {};\n      b(d, function (b, f) {\n        if (e(d[f], !0) && c[f]) b = a.cleanRecursively(d[f], c[f]), Object.keys(b).length && (k[f] = b);else if (e(d[f]) || d[f] !== c[f]) k[f] = d[f];\n      });\n      return k;\n    };\n\n    y(m.prototype, {\n      addSeries: function addSeries(a, c, b) {\n        var k,\n            d = this;\n        a && (c = l(c, !0), q(d, \"addSeries\", {\n          options: a\n        }, function () {\n          k = d.initSeries(a);\n          d.isDirtyLegend = !0;\n          d.linkSeries();\n          q(d, \"afterAddSeries\");\n          c && d.redraw(b);\n        }));\n        return k;\n      },\n      addAxis: function addAxis(a, c, b, d) {\n        var k = c ? \"xAxis\" : \"yAxis\",\n            h = this.options;\n        a = r(a, {\n          index: this[k].length,\n          isX: c\n        });\n        c = new G(this, a);\n        h[k] = C(h[k] || {});\n        h[k].push(a);\n        l(b, !0) && this.redraw(d);\n        return c;\n      },\n      showLoading: function showLoading(a) {\n        var c = this,\n            b = c.options,\n            d = c.loadingDiv,\n            e = b.loading,\n            h = function h() {\n          d && t(d, {\n            left: c.plotLeft + \"px\",\n            top: c.plotTop + \"px\",\n            width: c.plotWidth + \"px\",\n            height: c.plotHeight + \"px\"\n          });\n        };\n\n        d || (c.loadingDiv = d = g(\"div\", {\n          className: \"highcharts-loading highcharts-loading-hidden\"\n        }, null, c.container), c.loadingSpan = g(\"span\", {\n          className: \"highcharts-loading-inner\"\n        }, null, d), B(c, \"redraw\", h));\n        d.className = \"highcharts-loading\";\n        c.loadingSpan.innerHTML = a || b.lang.loading;\n        c.styledMode || (t(d, y(e.style, {\n          zIndex: 10\n        })), t(c.loadingSpan, e.labelStyle), c.loadingShown || (t(d, {\n          opacity: 0,\n          display: \"\"\n        }), A(d, {\n          opacity: e.style.opacity || .5\n        }, {\n          duration: e.showDuration || 0\n        })));\n        c.loadingShown = !0;\n        h();\n      },\n      hideLoading: function hideLoading() {\n        var a = this.options,\n            c = this.loadingDiv;\n        c && (c.className = \"highcharts-loading highcharts-loading-hidden\", this.styledMode || A(c, {\n          opacity: 0\n        }, {\n          duration: a.loading.hideDuration || 100,\n          complete: function complete() {\n            t(c, {\n              display: \"none\"\n            });\n          }\n        }));\n        this.loadingShown = !1;\n      },\n      propsRequireDirtyBox: \"backgroundColor borderColor borderWidth margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow\".split(\" \"),\n      propsRequireUpdateSeries: \"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip\".split(\" \"),\n      collectionsWithUpdate: \"xAxis yAxis zAxis series colorAxis pane\".split(\" \"),\n      update: function update(d, c, k, e) {\n        var g = this,\n            h = {\n          credits: \"addCredits\",\n          title: \"setTitle\",\n          subtitle: \"setSubtitle\"\n        },\n            n,\n            p,\n            x,\n            w = [];\n        q(g, \"update\", {\n          options: d\n        });\n        d.isResponsiveOptions || g.setResponsive(!1, !0);\n        d = a.cleanRecursively(d, g.options);\n\n        if (n = d.chart) {\n          r(!0, g.options.chart, n);\n          \"className\" in n && g.setClassName(n.className);\n          \"reflow\" in n && g.setReflow(n.reflow);\n          if (\"inverted\" in n || \"polar\" in n || \"type\" in n) g.propFromSeries(), p = !0;\n          \"alignTicks\" in n && (p = !0);\n          b(n, function (a, c) {\n            -1 !== g.propsRequireUpdateSeries.indexOf(\"chart.\" + c) && (x = !0);\n            -1 !== g.propsRequireDirtyBox.indexOf(c) && (g.isDirtyBox = !0);\n          });\n          !g.styledMode && \"style\" in n && g.renderer.setStyle(n.style);\n        }\n\n        !g.styledMode && d.colors && (this.options.colors = d.colors);\n        d.plotOptions && r(!0, this.options.plotOptions, d.plotOptions);\n        b(d, function (a, c) {\n          if (g[c] && \"function\" === typeof g[c].update) g[c].update(a, !1);else if (\"function\" === typeof g[h[c]]) g[h[c]](a);\n          \"chart\" !== c && -1 !== g.propsRequireUpdateSeries.indexOf(c) && (x = !0);\n        });\n        this.collectionsWithUpdate.forEach(function (a) {\n          var c;\n          d[a] && (\"series\" === a && (c = [], g[a].forEach(function (a, b) {\n            a.options.isInternal || c.push(l(a.options.index, b));\n          })), C(d[a]).forEach(function (b, d) {\n            (d = u(b.id) && g.get(b.id) || g[a][c ? c[d] : d]) && d.coll === a && (d.update(b, !1), k && (d.touched = !0));\n            if (!d && k) if (\"series\" === a) g.addSeries(b, !1).touched = !0;else if (\"xAxis\" === a || \"yAxis\" === a) g.addAxis(b, \"xAxis\" === a, !1).touched = !0;\n          }), k && g[a].forEach(function (a) {\n            a.touched || a.options.isInternal ? delete a.touched : w.push(a);\n          }));\n        });\n        w.forEach(function (a) {\n          a.remove && a.remove(!1);\n        });\n        p && g.axes.forEach(function (a) {\n          a.update({}, !1);\n        });\n        x && g.series.forEach(function (a) {\n          a.update({}, !1);\n        });\n        d.loading && r(!0, g.options.loading, d.loading);\n        p = n && n.width;\n        n = n && n.height;\n        f(p) && p !== g.chartWidth || f(n) && n !== g.chartHeight ? g.setSize(p, n, e) : l(c, !0) && g.redraw(e);\n        q(g, \"afterUpdate\", {\n          options: d\n        });\n      },\n      setSubtitle: function setSubtitle(a) {\n        this.setTitle(void 0, a);\n      }\n    });\n    y(n.prototype, {\n      update: function update(a, c, b, d) {\n        function k() {\n          h.applyOptions(a);\n          null === h.y && g && (h.graphic = g.destroy());\n          e(a, !0) && (g && g.element && a && a.marker && void 0 !== a.marker.symbol && (h.graphic = g.destroy()), a && a.dataLabels && h.dataLabel && (h.dataLabel = h.dataLabel.destroy()), h.connector && (h.connector = h.connector.destroy()));\n          n = h.index;\n          f.updateParallelArrays(h, n);\n          x.data[n] = e(x.data[n], !0) || e(a, !0) ? h.options : l(a, x.data[n]);\n          f.isDirty = f.isDirtyData = !0;\n          !f.fixedBox && f.hasCartesianSeries && (p.isDirtyBox = !0);\n          \"point\" === x.legendType && (p.isDirtyLegend = !0);\n          c && p.redraw(b);\n        }\n\n        var h = this,\n            f = h.series,\n            g = h.graphic,\n            n,\n            p = f.chart,\n            x = f.options;\n        c = l(c, !0);\n        !1 === d ? k() : h.firePointEvent(\"update\", {\n          options: a\n        }, k);\n      },\n      remove: function remove(a, c) {\n        this.series.removePoint(this.series.data.indexOf(this), a, c);\n      }\n    });\n    y(d.prototype, {\n      addPoint: function addPoint(a, c, b, d) {\n        var k = this.options,\n            h = this.data,\n            e = this.chart,\n            f = this.xAxis,\n            f = f && f.hasNames && f.names,\n            g = k.data,\n            n,\n            p,\n            x = this.xData,\n            w,\n            r;\n        c = l(c, !0);\n        n = {\n          series: this\n        };\n        this.pointClass.prototype.applyOptions.apply(n, [a]);\n        r = n.x;\n        w = x.length;\n        if (this.requireSorting && r < x[w - 1]) for (p = !0; w && x[w - 1] > r;) {\n          w--;\n        }\n        this.updateParallelArrays(n, \"splice\", w, 0, 0);\n        this.updateParallelArrays(n, w);\n        f && n.name && (f[r] = n.name);\n        g.splice(w, 0, a);\n        p && (this.data.splice(w, 0, null), this.processData());\n        \"point\" === k.legendType && this.generatePoints();\n        b && (h[0] && h[0].remove ? h[0].remove(!1) : (h.shift(), this.updateParallelArrays(n, \"shift\"), g.shift()));\n        this.isDirtyData = this.isDirty = !0;\n        c && e.redraw(d);\n      },\n      removePoint: function removePoint(a, c, b) {\n        var d = this,\n            k = d.data,\n            h = k[a],\n            e = d.points,\n            f = d.chart,\n            g = function g() {\n          e && e.length === k.length && e.splice(a, 1);\n          k.splice(a, 1);\n          d.options.data.splice(a, 1);\n          d.updateParallelArrays(h || {\n            series: d\n          }, \"splice\", a, 1);\n          h && h.destroy();\n          d.isDirty = !0;\n          d.isDirtyData = !0;\n          c && f.redraw();\n        };\n\n        E(b, f);\n        c = l(c, !0);\n        h ? h.firePointEvent(\"remove\", null, g) : g();\n      },\n      remove: function remove(a, c, b, d) {\n        function k() {\n          h.destroy(d);\n          h.remove = null;\n          e.isDirtyLegend = e.isDirtyBox = !0;\n          e.linkSeries();\n          l(a, !0) && e.redraw(c);\n        }\n\n        var h = this,\n            e = h.chart;\n        !1 !== b ? q(h, \"remove\", null, k) : k();\n      },\n      update: function update(b, c) {\n        b = a.cleanRecursively(b, this.userOptions);\n        var d = this,\n            e = d.chart,\n            f = d.userOptions,\n            h = d.initialType || d.type,\n            g = b.type || f.type || e.options.chart.type,\n            n = w[h].prototype,\n            p,\n            m = [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n            E = [\"navigatorSeries\", \"baseSeries\"],\n            C = d.finishedAnimating && {\n          animation: !1\n        },\n            t = [\"data\", \"name\", \"turboThreshold\"],\n            v = Object.keys(b),\n            F = 0 < v.length;\n        v.forEach(function (a) {\n          -1 === t.indexOf(a) && (F = !1);\n        });\n        if (F) b.data && this.setData(b.data, !1), b.name && this.setName(b.name, !1);else {\n          E = m.concat(E);\n          E.forEach(function (a) {\n            E[a] = d[a];\n            delete d[a];\n          });\n          b = r(f, C, {\n            index: d.index,\n            pointStart: l(f.pointStart, d.xData[0])\n          }, {\n            data: d.options.data\n          }, b);\n          d.remove(!1, null, !1, !0);\n\n          for (p in n) {\n            d[p] = void 0;\n          }\n\n          w[g || h] ? y(d, w[g || h].prototype) : a.error(17, !0, e);\n          E.forEach(function (a) {\n            d[a] = E[a];\n          });\n          d.init(e, b);\n          b.zIndex !== f.zIndex && m.forEach(function (a) {\n            d[a] && d[a].attr({\n              zIndex: b.zIndex\n            });\n          });\n          d.initialType = h;\n          e.linkSeries();\n        }\n        q(this, \"afterUpdate\");\n        l(c, !0) && e.redraw(F ? void 0 : !1);\n      },\n      setName: function setName(a) {\n        this.name = this.options.name = this.userOptions.name = a;\n        this.chart.isDirtyLegend = !0;\n      }\n    });\n    y(G.prototype, {\n      update: function update(a, c) {\n        var d = this.chart,\n            e = a && a.events || {};\n        a = r(this.userOptions, a);\n        d.options[this.coll].indexOf && (d.options[this.coll][d.options[this.coll].indexOf(this.userOptions)] = a);\n        b(d.options[this.coll].events, function (a, c) {\n          \"undefined\" === typeof e[c] && (e[c] = void 0);\n        });\n        this.destroy(!0);\n        this.init(d, y(a, {\n          events: e\n        }));\n        d.isDirtyBox = !0;\n        l(c, !0) && d.redraw();\n      },\n      remove: function remove(a) {\n        for (var c = this.chart, b = this.coll, d = this.series, e = d.length; e--;) {\n          d[e] && d[e].remove(!1);\n        }\n\n        v(c.axes, this);\n        v(c[b], this);\n        p(c.options[b]) ? c.options[b].splice(this.options.index, 1) : delete c.options[b];\n        c[b].forEach(function (a, c) {\n          a.options.index = a.userOptions.index = c;\n        });\n        this.destroy();\n        c.isDirtyBox = !0;\n        l(a, !0) && c.redraw();\n      },\n      setTitle: function setTitle(a, c) {\n        this.update({\n          title: a\n        }, c);\n      },\n      setCategories: function setCategories(a, c) {\n        this.update({\n          categories: a\n        }, c);\n      }\n    });\n  })(H);\n\n  (function (a) {\n    var B = a.color,\n        A = a.pick,\n        G = a.Series,\n        m = a.seriesType;\n    m(\"area\", \"line\", {\n      softThreshold: !1,\n      threshold: 0\n    }, {\n      singleStacks: !1,\n      getStackPoints: function getStackPoints(g) {\n        var m = [],\n            u = [],\n            v = this.xAxis,\n            y = this.yAxis,\n            q = y.stacks[this.stackKey],\n            f = {},\n            e = this.index,\n            p = y.series,\n            r = p.length,\n            b,\n            l = A(y.options.reversedStacks, !0) ? 1 : -1,\n            n;\n        g = g || this.points;\n\n        if (this.options.stacking) {\n          for (n = 0; n < g.length; n++) {\n            g[n].leftNull = g[n].rightNull = null, f[g[n].x] = g[n];\n          }\n\n          a.objectEach(q, function (a, b) {\n            null !== a.total && u.push(b);\n          });\n          u.sort(function (a, b) {\n            return a - b;\n          });\n          b = p.map(function (a) {\n            return a.visible;\n          });\n          u.forEach(function (a, g) {\n            var d = 0,\n                p,\n                w;\n            if (f[a] && !f[a].isNull) m.push(f[a]), [-1, 1].forEach(function (c) {\n              var d = 1 === c ? \"rightNull\" : \"leftNull\",\n                  x = 0,\n                  m = q[u[g + c]];\n              if (m) for (n = e; 0 <= n && n < r;) {\n                p = m.points[n], p || (n === e ? f[a][d] = !0 : b[n] && (w = q[a].points[n]) && (x -= w[1] - w[0])), n += l;\n              }\n              f[a][1 === c ? \"rightCliff\" : \"leftCliff\"] = x;\n            });else {\n              for (n = e; 0 <= n && n < r;) {\n                if (p = q[a].points[n]) {\n                  d = p[1];\n                  break;\n                }\n\n                n += l;\n              }\n\n              d = y.translate(d, 0, 1, 0, 1);\n              m.push({\n                isNull: !0,\n                plotX: v.translate(a, 0, 0, 0, 1),\n                x: a,\n                plotY: d,\n                yBottom: d\n              });\n            }\n          });\n        }\n\n        return m;\n      },\n      getGraphPath: function getGraphPath(a) {\n        var g = G.prototype.getGraphPath,\n            m = this.options,\n            v = m.stacking,\n            y = this.yAxis,\n            q,\n            f,\n            e = [],\n            p = [],\n            r = this.index,\n            b,\n            l = y.stacks[this.stackKey],\n            n = m.threshold,\n            d = y.getThreshold(m.threshold),\n            w,\n            m = m.connectNulls || \"percent\" === v,\n            E = function E(f, g, c) {\n          var k = a[f];\n          f = v && l[k.x].points[r];\n          var x = k[c + \"Null\"] || 0;\n          c = k[c + \"Cliff\"] || 0;\n          var w,\n              h,\n              k = !0;\n          c || x ? (w = (x ? f[0] : f[1]) + c, h = f[0] + c, k = !!x) : !v && a[g] && a[g].isNull && (w = h = n);\n          void 0 !== w && (p.push({\n            plotX: b,\n            plotY: null === w ? d : y.getThreshold(w),\n            isNull: k,\n            isCliff: !0\n          }), e.push({\n            plotX: b,\n            plotY: null === h ? d : y.getThreshold(h),\n            doCurve: !1\n          }));\n        };\n\n        a = a || this.points;\n        v && (a = this.getStackPoints(a));\n\n        for (q = 0; q < a.length; q++) {\n          if (f = a[q].isNull, b = A(a[q].rectPlotX, a[q].plotX), w = A(a[q].yBottom, d), !f || m) m || E(q, q - 1, \"left\"), f && !v && m || (p.push(a[q]), e.push({\n            x: q,\n            plotX: b,\n            plotY: w\n          })), m || E(q, q + 1, \"right\");\n        }\n\n        q = g.call(this, p, !0, !0);\n        e.reversed = !0;\n        f = g.call(this, e, !0, !0);\n        f.length && (f[0] = \"L\");\n        f = q.concat(f);\n        g = g.call(this, p, !1, m);\n        f.xMap = q.xMap;\n        this.areaPath = f;\n        return g;\n      },\n      drawGraph: function drawGraph() {\n        this.areaPath = [];\n        G.prototype.drawGraph.apply(this);\n        var a = this,\n            m = this.areaPath,\n            u = this.options,\n            v = [[\"area\", \"highcharts-area\", this.color, u.fillColor]];\n        this.zones.forEach(function (g, q) {\n          v.push([\"zone-area-\" + q, \"highcharts-area highcharts-zone-area-\" + q + \" \" + g.className, g.color || a.color, g.fillColor || u.fillColor]);\n        });\n        v.forEach(function (g) {\n          var q = g[0],\n              f = a[q];\n          f ? (f.endX = a.preventGraphAnimation ? null : m.xMap, f.animate({\n            d: m\n          })) : (f = {\n            zIndex: 0\n          }, a.chart.styledMode || (f.fill = A(g[3], B(g[2]).setOpacity(A(u.fillOpacity, .75)).get())), f = a[q] = a.chart.renderer.path(m).addClass(g[1]).attr(f).add(a.group), f.isArea = !0);\n          f.startX = m.xMap;\n          f.shiftUnit = u.step ? 2 : 1;\n        });\n      },\n      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle\n    });\n  })(H);\n\n  (function (a) {\n    var B = a.pick;\n    a = a.seriesType;\n    a(\"spline\", \"line\", {}, {\n      getPointSpline: function getPointSpline(a, G, m) {\n        var g = G.plotX,\n            t = G.plotY,\n            u = a[m - 1];\n        m = a[m + 1];\n        var v, y, q, f;\n\n        if (u && !u.isNull && !1 !== u.doCurve && !G.isCliff && m && !m.isNull && !1 !== m.doCurve && !G.isCliff) {\n          a = u.plotY;\n          q = m.plotX;\n          m = m.plotY;\n          var e = 0;\n          v = (1.5 * g + u.plotX) / 2.5;\n          y = (1.5 * t + a) / 2.5;\n          q = (1.5 * g + q) / 2.5;\n          f = (1.5 * t + m) / 2.5;\n          q !== v && (e = (f - y) * (q - g) / (q - v) + t - f);\n          y += e;\n          f += e;\n          y > a && y > t ? (y = Math.max(a, t), f = 2 * t - y) : y < a && y < t && (y = Math.min(a, t), f = 2 * t - y);\n          f > m && f > t ? (f = Math.max(m, t), y = 2 * t - f) : f < m && f < t && (f = Math.min(m, t), y = 2 * t - f);\n          G.rightContX = q;\n          G.rightContY = f;\n        }\n\n        G = [\"C\", B(u.rightContX, u.plotX), B(u.rightContY, u.plotY), B(v, g), B(y, t), g, t];\n        u.rightContX = u.rightContY = null;\n        return G;\n      }\n    });\n  })(H);\n\n  (function (a) {\n    var B = a.seriesTypes.area.prototype,\n        A = a.seriesType;\n    A(\"areaspline\", \"spline\", a.defaultPlotOptions.area, {\n      getStackPoints: B.getStackPoints,\n      getGraphPath: B.getGraphPath,\n      drawGraph: B.drawGraph,\n      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle\n    });\n  })(H);\n\n  (function (a) {\n    var B = a.animObject,\n        A = a.color,\n        G = a.extend,\n        m = a.defined,\n        g = a.isNumber,\n        t = a.merge,\n        u = a.pick,\n        v = a.Series,\n        y = a.seriesType,\n        q = a.svg;\n    y(\"column\", \"line\", {\n      borderRadius: 0,\n      crisp: !0,\n      groupPadding: .2,\n      marker: null,\n      pointPadding: .1,\n      minPointLength: 0,\n      cropThreshold: 50,\n      pointRange: null,\n      states: {\n        hover: {\n          halo: !1,\n          brightness: .1\n        },\n        select: {\n          color: \"#cccccc\",\n          borderColor: \"#000000\"\n        }\n      },\n      dataLabels: {\n        align: null,\n        verticalAlign: null,\n        y: null\n      },\n      softThreshold: !1,\n      startFromThreshold: !0,\n      stickyTracking: !1,\n      tooltip: {\n        distance: 6\n      },\n      threshold: 0,\n      borderColor: \"#ffffff\"\n    }, {\n      cropShoulder: 0,\n      directTouch: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      negStacks: !0,\n      init: function init() {\n        v.prototype.init.apply(this, arguments);\n        var a = this,\n            e = a.chart;\n        e.hasRendered && e.series.forEach(function (e) {\n          e.type === a.type && (e.isDirty = !0);\n        });\n      },\n      getColumnMetrics: function getColumnMetrics() {\n        var a = this,\n            e = a.options,\n            g = a.xAxis,\n            r = a.yAxis,\n            b = g.options.reversedStacks,\n            b = g.reversed && !b || !g.reversed && b,\n            l,\n            n = {},\n            d = 0;\n        !1 === e.grouping ? d = 1 : a.chart.series.forEach(function (b) {\n          var c = b.options,\n              k = b.yAxis,\n              e;\n          b.type !== a.type || !b.visible && a.chart.options.chart.ignoreHiddenSeries || r.len !== k.len || r.pos !== k.pos || (c.stacking ? (l = b.stackKey, void 0 === n[l] && (n[l] = d++), e = n[l]) : !1 !== c.grouping && (e = d++), b.columnIndex = e);\n        });\n        var w = Math.min(Math.abs(g.transA) * (g.ordinalSlope || e.pointRange || g.closestPointRange || g.tickInterval || 1), g.len),\n            q = w * e.groupPadding,\n            m = (w - 2 * q) / (d || 1),\n            e = Math.min(e.maxPointWidth || g.len, u(e.pointWidth, m * (1 - 2 * e.pointPadding)));\n        a.columnMetrics = {\n          width: e,\n          offset: (m - e) / 2 + (q + ((a.columnIndex || 0) + (b ? 1 : 0)) * m - w / 2) * (b ? -1 : 1)\n        };\n        return a.columnMetrics;\n      },\n      crispCol: function crispCol(a, e, g, r) {\n        var b = this.chart,\n            f = this.borderWidth,\n            n = -(f % 2 ? .5 : 0),\n            f = f % 2 ? .5 : 1;\n        b.inverted && b.renderer.isVML && (f += 1);\n        this.options.crisp && (g = Math.round(a + g) + n, a = Math.round(a) + n, g -= a);\n        r = Math.round(e + r) + f;\n        n = .5 >= Math.abs(e) && .5 < r;\n        e = Math.round(e) + f;\n        r -= e;\n        n && r && (--e, r += 1);\n        return {\n          x: a,\n          y: e,\n          width: g,\n          height: r\n        };\n      },\n      translate: function translate() {\n        var a = this,\n            e = a.chart,\n            g = a.options,\n            r = a.dense = 2 > a.closestPointRange * a.xAxis.transA,\n            r = a.borderWidth = u(g.borderWidth, r ? 0 : 1),\n            b = a.yAxis,\n            l = g.threshold,\n            n = a.translatedThreshold = b.getThreshold(l),\n            d = u(g.minPointLength, 5),\n            w = a.getColumnMetrics(),\n            q = w.width,\n            C = a.barW = Math.max(q, 1 + 2 * r),\n            t = a.pointXOffset = w.offset;\n        e.inverted && (n -= .5);\n        g.pointPadding && (C = Math.ceil(C));\n        v.prototype.translate.apply(a);\n        a.points.forEach(function (c) {\n          var k = u(c.yBottom, n),\n              f = 999 + Math.abs(k),\n              g = q,\n              f = Math.min(Math.max(-f, c.plotY), b.len + f),\n              h = c.plotX + t,\n              p = C,\n              w = Math.min(f, k),\n              r,\n              E = Math.max(f, k) - w;\n          d && Math.abs(E) < d && (E = d, r = !b.reversed && !c.negative || b.reversed && c.negative, c.y === l && a.dataMax <= l && b.min < l && (r = !r), w = Math.abs(w - n) > d ? k - d : n - (r ? d : 0));\n          m(c.options.pointWidth) && (g = p = Math.ceil(c.options.pointWidth), h -= Math.round((g - q) / 2));\n          c.barX = h;\n          c.pointWidth = g;\n          c.tooltipPos = e.inverted ? [b.len + b.pos - e.plotLeft - f, a.xAxis.len - h - p / 2, E] : [h + p / 2, f + b.pos - e.plotTop, E];\n          c.shapeType = c.shapeType || \"rect\";\n          c.shapeArgs = a.crispCol.apply(a, c.isNull ? [h, n, p, 0] : [h, w, p, E]);\n        });\n      },\n      getSymbol: a.noop,\n      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,\n      drawGraph: function drawGraph() {\n        this.group[this.dense ? \"addClass\" : \"removeClass\"](\"highcharts-dense-data\");\n      },\n      pointAttribs: function pointAttribs(a, e) {\n        var f = this.options,\n            g,\n            b = this.pointAttrToOptions || {};\n        g = b.stroke || \"borderColor\";\n        var l = b[\"stroke-width\"] || \"borderWidth\",\n            n = a && a.color || this.color,\n            d = a && a[g] || f[g] || this.color || n,\n            w = a && a[l] || f[l] || this[l] || 0,\n            b = f.dashStyle;\n        a && this.zones.length && (n = a.getZone(), n = a.options.color || n && n.color || this.color);\n        e && (a = t(f.states[e], a.options.states && a.options.states[e] || {}), e = a.brightness, n = a.color || void 0 !== e && A(n).brighten(a.brightness).get() || n, d = a[g] || d, w = a[l] || w, b = a.dashStyle || b);\n        g = {\n          fill: n,\n          stroke: d,\n          \"stroke-width\": w\n        };\n        b && (g.dashstyle = b);\n        return g;\n      },\n      drawPoints: function drawPoints() {\n        var a = this,\n            e = this.chart,\n            p = a.options,\n            r = e.renderer,\n            b = p.animationLimit || 250,\n            l;\n        a.points.forEach(function (f) {\n          var d = f.graphic,\n              n = d && e.pointCount < b ? \"animate\" : \"attr\";\n\n          if (g(f.plotY) && null !== f.y) {\n            l = f.shapeArgs;\n            if (d) d[n](t(l));else f.graphic = d = r[f.shapeType](l).add(f.group || a.group);\n            p.borderRadius && d.attr({\n              r: p.borderRadius\n            });\n            e.styledMode || d[n](a.pointAttribs(f, f.selected && \"select\")).shadow(p.shadow, null, p.stacking && !p.borderRadius);\n            d.addClass(f.getClassName(), !0);\n          } else d && (f.graphic = d.destroy());\n        });\n      },\n      animate: function animate(a) {\n        var e = this,\n            f = this.yAxis,\n            g = e.options,\n            b = this.chart.inverted,\n            l = {},\n            n = b ? \"translateX\" : \"translateY\",\n            d;\n        q && (a ? (l.scaleY = .001, a = Math.min(f.pos + f.len, Math.max(f.pos, f.toPixels(g.threshold))), b ? l.translateX = a - f.len : l.translateY = a, e.clipBox && e.setClip(), e.group.attr(l)) : (d = e.group.attr(n), e.group.animate({\n          scaleY: 1\n        }, G(B(e.options.animation), {\n          step: function step(a, b) {\n            l[n] = d + b.pos * (f.pos - d);\n            e.group.attr(l);\n          }\n        })), e.animate = null));\n      },\n      remove: function remove() {\n        var a = this,\n            e = a.chart;\n        e.hasRendered && e.series.forEach(function (e) {\n          e.type === a.type && (e.isDirty = !0);\n        });\n        v.prototype.remove.apply(a, arguments);\n      }\n    });\n  })(H);\n\n  (function (a) {\n    a = a.seriesType;\n    a(\"bar\", \"column\", null, {\n      inverted: !0\n    });\n  })(H);\n\n  (function (a) {\n    var B = a.Series,\n        A = a.seriesType;\n    A(\"scatter\", \"line\", {\n      lineWidth: 0,\n      findNearestPointBy: \"xy\",\n      jitter: {\n        x: 0,\n        y: 0\n      },\n      marker: {\n        enabled: !0\n      },\n      tooltip: {\n        headerFormat: \"<span style=\\\"color:{point.color}\\\">\\u25CF</span> <span style=\\\"font-size: 10px\\\"> {series.name}</span><br/>\",\n        pointFormat: \"x: \\x3cb\\x3e{point.x}\\x3c/b\\x3e\\x3cbr/\\x3ey: \\x3cb\\x3e{point.y}\\x3c/b\\x3e\\x3cbr/\\x3e\"\n      }\n    }, {\n      sorted: !1,\n      requireSorting: !1,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n      takeOrdinalPosition: !1,\n      drawGraph: function drawGraph() {\n        this.options.lineWidth && B.prototype.drawGraph.call(this);\n      },\n      applyJitter: function applyJitter() {\n        var a = this,\n            m = this.options.jitter,\n            g = this.points.length;\n        m && this.points.forEach(function (t, u) {\n          [\"x\", \"y\"].forEach(function (v, y) {\n            var q,\n                f = \"plot\" + v.toUpperCase(),\n                e,\n                p;\n            m[v] && !t.isNull && (q = a[v + \"Axis\"], p = m[v] * q.transA, q && !q.isLog && (e = Math.max(0, t[f] - p), q = Math.min(q.len, t[f] + p), y = 1E4 * Math.sin(u + y * g), t[f] = e + (q - e) * (y - Math.floor(y)), \"x\" === v && (t.clientX = t.plotX)));\n          });\n        });\n      }\n    });\n    a.addEvent(B, \"afterTranslate\", function () {\n      this.applyJitter && this.applyJitter();\n    });\n  })(H);\n\n  (function (a) {\n    var B = a.deg2rad,\n        A = a.isNumber,\n        G = a.pick,\n        m = a.relativeLength;\n    a.CenteredSeriesMixin = {\n      getCenter: function getCenter() {\n        var a = this.options,\n            t = this.chart,\n            u = 2 * (a.slicedOffset || 0),\n            v = t.plotWidth - 2 * u,\n            t = t.plotHeight - 2 * u,\n            y = a.center,\n            y = [G(y[0], \"50%\"), G(y[1], \"50%\"), a.size || \"100%\", a.innerSize || 0],\n            q = Math.min(v, t),\n            f,\n            e;\n\n        for (f = 0; 4 > f; ++f) {\n          e = y[f], a = 2 > f || 2 === f && /%$/.test(e), y[f] = m(e, [v, t, q, y[2]][f]) + (a ? u : 0);\n        }\n\n        y[3] > y[2] && (y[3] = y[2]);\n        return y;\n      },\n      getStartAndEndRadians: function getStartAndEndRadians(a, m) {\n        a = A(a) ? a : 0;\n        m = A(m) && m > a && 360 > m - a ? m : a + 360;\n        return {\n          start: B * (a + -90),\n          end: B * (m + -90)\n        };\n      }\n    };\n  })(H);\n\n  (function (a) {\n    var B = a.addEvent,\n        A = a.CenteredSeriesMixin,\n        G = a.defined,\n        m = a.extend,\n        g = A.getStartAndEndRadians,\n        t = a.noop,\n        u = a.pick,\n        v = a.Point,\n        y = a.Series,\n        q = a.seriesType,\n        f = a.setAnimation;\n    q(\"pie\", \"line\", {\n      center: [null, null],\n      clip: !1,\n      colorByPoint: !0,\n      dataLabels: {\n        allowOverlap: !0,\n        connectorPadding: 5,\n        distance: 30,\n        enabled: !0,\n        formatter: function formatter() {\n          return this.point.isNull ? void 0 : this.point.name;\n        },\n        softConnector: !0,\n        x: 0,\n        connectorShape: \"fixedOffset\",\n        crookDistance: \"70%\"\n      },\n      ignoreHiddenPoint: !0,\n      legendType: \"point\",\n      marker: null,\n      size: null,\n      showInLegend: !1,\n      slicedOffset: 10,\n      stickyTracking: !1,\n      tooltip: {\n        followPointer: !0\n      },\n      borderColor: \"#ffffff\",\n      borderWidth: 1,\n      states: {\n        hover: {\n          brightness: .1\n        }\n      }\n    }, {\n      isCartesian: !1,\n      requireSorting: !1,\n      directTouch: !0,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      axisTypes: [],\n      pointAttribs: a.seriesTypes.column.prototype.pointAttribs,\n      animate: function animate(a) {\n        var e = this,\n            f = e.points,\n            b = e.startAngleRad;\n        a || (f.forEach(function (a) {\n          var f = a.graphic,\n              d = a.shapeArgs;\n          f && (f.attr({\n            r: a.startR || e.center[3] / 2,\n            start: b,\n            end: b\n          }), f.animate({\n            r: d.r,\n            start: d.start,\n            end: d.end\n          }, e.options.animation));\n        }), e.animate = null);\n      },\n      updateTotals: function updateTotals() {\n        var a,\n            f = 0,\n            g = this.points,\n            b = g.length,\n            l,\n            n = this.options.ignoreHiddenPoint;\n\n        for (a = 0; a < b; a++) {\n          l = g[a], f += n && !l.visible ? 0 : l.isNull ? 0 : l.y;\n        }\n\n        this.total = f;\n\n        for (a = 0; a < b; a++) {\n          l = g[a], l.percentage = 0 < f && (l.visible || !n) ? l.y / f * 100 : 0, l.total = f;\n        }\n      },\n      generatePoints: function generatePoints() {\n        y.prototype.generatePoints.call(this);\n        this.updateTotals();\n      },\n      getX: function getX(a, f, g) {\n        var b = this.center,\n            e = this.radii ? this.radii[g.index] : b[2] / 2;\n        return b[0] + (f ? -1 : 1) * Math.cos(Math.asin(Math.max(Math.min((a - b[1]) / (e + g.labelDistance), 1), -1))) * (e + g.labelDistance) + (0 < g.labelDistance ? (f ? -1 : 1) * this.options.dataLabels.padding : 0);\n      },\n      translate: function translate(a) {\n        this.generatePoints();\n        var e = 0,\n            f = this.options,\n            b = f.slicedOffset,\n            l = b + (f.borderWidth || 0),\n            n,\n            d,\n            w = g(f.startAngle, f.endAngle),\n            q = this.startAngleRad = w.start,\n            w = (this.endAngleRad = w.end) - q,\n            m = this.points,\n            t,\n            c,\n            k = f.dataLabels.distance,\n            f = f.ignoreHiddenPoint,\n            x,\n            D = m.length,\n            h;\n        a || (this.center = a = this.getCenter());\n\n        for (x = 0; x < D; x++) {\n          h = m[x];\n          h.labelDistance = u(h.options.dataLabels && h.options.dataLabels.distance, k);\n          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, h.labelDistance);\n          n = q + e * w;\n          if (!f || h.visible) e += h.percentage / 100;\n          d = q + e * w;\n          h.shapeType = \"arc\";\n          h.shapeArgs = {\n            x: a[0],\n            y: a[1],\n            r: a[2] / 2,\n            innerR: a[3] / 2,\n            start: Math.round(1E3 * n) / 1E3,\n            end: Math.round(1E3 * d) / 1E3\n          };\n          d = (d + n) / 2;\n          d > 1.5 * Math.PI ? d -= 2 * Math.PI : d < -Math.PI / 2 && (d += 2 * Math.PI);\n          h.slicedTranslation = {\n            translateX: Math.round(Math.cos(d) * b),\n            translateY: Math.round(Math.sin(d) * b)\n          };\n          t = Math.cos(d) * a[2] / 2;\n          c = Math.sin(d) * a[2] / 2;\n          h.tooltipPos = [a[0] + .7 * t, a[1] + .7 * c];\n          h.half = d < -Math.PI / 2 || d > Math.PI / 2 ? 1 : 0;\n          h.angle = d;\n          n = Math.min(l, h.labelDistance / 5);\n          h.labelPosition = {\n            natural: {\n              x: a[0] + t + Math.cos(d) * h.labelDistance,\n              y: a[1] + c + Math.sin(d) * h.labelDistance\n            },\n            \"final\": {},\n            alignment: 0 > h.labelDistance ? \"center\" : h.half ? \"right\" : \"left\",\n            connectorPosition: {\n              breakAt: {\n                x: a[0] + t + Math.cos(d) * n,\n                y: a[1] + c + Math.sin(d) * n\n              },\n              touchingSliceAt: {\n                x: a[0] + t,\n                y: a[1] + c\n              }\n            }\n          };\n        }\n      },\n      drawGraph: null,\n      drawPoints: function drawPoints() {\n        var a = this,\n            f = a.chart,\n            g = f.renderer,\n            b,\n            l,\n            n,\n            d,\n            w = a.options.shadow;\n        !w || a.shadowGroup || f.styledMode || (a.shadowGroup = g.g(\"shadow\").add(a.group));\n        a.points.forEach(function (e) {\n          l = e.graphic;\n          if (e.isNull) l && (e.graphic = l.destroy());else {\n            d = e.shapeArgs;\n            b = e.getTranslate();\n\n            if (!f.styledMode) {\n              var p = e.shadowGroup;\n              w && !p && (p = e.shadowGroup = g.g(\"shadow\").add(a.shadowGroup));\n              p && p.attr(b);\n              n = a.pointAttribs(e, e.selected && \"select\");\n            }\n\n            l ? (l.setRadialReference(a.center), f.styledMode || l.attr(n), l.animate(m(d, b))) : (e.graphic = l = g[e.shapeType](d).setRadialReference(a.center).attr(b).add(a.group), f.styledMode || l.attr(n).attr({\n              \"stroke-linejoin\": \"round\"\n            }).shadow(w, p));\n            l.attr({\n              visibility: e.visible ? \"inherit\" : \"hidden\"\n            });\n            l.addClass(e.getClassName());\n          }\n        });\n      },\n      searchPoint: t,\n      sortByAngle: function sortByAngle(a, f) {\n        a.sort(function (a, b) {\n          return void 0 !== a.angle && (b.angle - a.angle) * f;\n        });\n      },\n      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,\n      getCenter: A.getCenter,\n      getSymbol: t\n    }, {\n      init: function init() {\n        v.prototype.init.apply(this, arguments);\n        var a = this,\n            f;\n        a.name = u(a.name, \"Slice\");\n\n        f = function f(e) {\n          a.slice(\"select\" === e.type);\n        };\n\n        B(a, \"select\", f);\n        B(a, \"unselect\", f);\n        return a;\n      },\n      isValid: function isValid() {\n        return a.isNumber(this.y, !0) && 0 <= this.y;\n      },\n      setVisible: function setVisible(a, f) {\n        var e = this,\n            b = e.series,\n            g = b.chart,\n            n = b.options.ignoreHiddenPoint;\n        f = u(f, n);\n        a !== e.visible && (e.visible = e.options.visible = a = void 0 === a ? !e.visible : a, b.options.data[b.data.indexOf(e)] = e.options, [\"graphic\", \"dataLabel\", \"connector\", \"shadowGroup\"].forEach(function (b) {\n          if (e[b]) e[b][a ? \"show\" : \"hide\"](!0);\n        }), e.legendItem && g.legend.colorizeItem(e, a), a || \"hover\" !== e.state || e.setState(\"\"), n && (b.isDirty = !0), f && g.redraw());\n      },\n      slice: function slice(a, g, q) {\n        var b = this.series;\n        f(q, b.chart);\n        u(g, !0);\n        this.sliced = this.options.sliced = G(a) ? a : !this.sliced;\n        b.options.data[b.data.indexOf(this)] = this.options;\n        this.graphic.animate(this.getTranslate());\n        this.shadowGroup && this.shadowGroup.animate(this.getTranslate());\n      },\n      getTranslate: function getTranslate() {\n        return this.sliced ? this.slicedTranslation : {\n          translateX: 0,\n          translateY: 0\n        };\n      },\n      haloPath: function haloPath(a) {\n        var e = this.shapeArgs;\n        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(e.x, e.y, e.r + a, e.r + a, {\n          innerR: this.shapeArgs.r - 1,\n          start: e.start,\n          end: e.end\n        });\n      },\n      connectorShapes: {\n        fixedOffset: function fixedOffset(a, f, g) {\n          var b = f.breakAt;\n          f = f.touchingSliceAt;\n          return [\"M\", a.x, a.y].concat(g.softConnector ? [\"C\", a.x + (\"left\" === a.alignment ? -5 : 5), a.y, 2 * b.x - f.x, 2 * b.y - f.y, b.x, b.y] : [\"L\", b.x, b.y]).concat([\"L\", f.x, f.y]);\n        },\n        straight: function straight(a, f) {\n          f = f.touchingSliceAt;\n          return [\"M\", a.x, a.y, \"L\", f.x, f.y];\n        },\n        crookedLine: function crookedLine(e, f, g) {\n          f = f.touchingSliceAt;\n          var b = this.series,\n              l = b.center[0],\n              n = b.chart.plotWidth,\n              d = b.chart.plotLeft,\n              b = e.alignment,\n              w = this.shapeArgs.r;\n          g = a.relativeLength(g.crookDistance, 1);\n          g = \"left\" === b ? l + w + (n + d - l - w) * (1 - g) : d + (l - w) * g;\n          l = [\"L\", g, e.y];\n          if (\"left\" === b ? g > e.x || g < f.x : g < e.x || g > f.x) l = [];\n          return [\"M\", e.x, e.y].concat(l).concat([\"L\", f.x, f.y]);\n        }\n      },\n      getConnectorPath: function getConnectorPath() {\n        var a = this.labelPosition,\n            f = this.series.options.dataLabels,\n            g = f.connectorShape,\n            b = this.connectorShapes;\n        b[g] && (g = b[g]);\n        return g.call(this, {\n          x: a.final.x,\n          y: a.final.y,\n          alignment: a.alignment\n        }, a.connectorPosition, f);\n      }\n    });\n  })(H);\n\n  (function (a) {\n    var B = a.addEvent,\n        A = a.arrayMax,\n        G = a.defined,\n        m = a.extend,\n        g = a.format,\n        t = a.merge,\n        u = a.noop,\n        v = a.pick,\n        y = a.relativeLength,\n        q = a.Series,\n        f = a.seriesTypes,\n        e = a.stableSort,\n        p = a.isArray,\n        r = a.splat;\n\n    a.distribute = function (b, f, g) {\n      function d(a, c) {\n        return a.target - c.target;\n      }\n\n      var l,\n          n = !0,\n          p = b,\n          q = [],\n          c;\n      c = 0;\n      var k = p.reducedLen || f;\n\n      for (l = b.length; l--;) {\n        c += b[l].size;\n      }\n\n      if (c > k) {\n        e(b, function (a, c) {\n          return (c.rank || 0) - (a.rank || 0);\n        });\n\n        for (c = l = 0; c <= k;) {\n          c += b[l].size, l++;\n        }\n\n        q = b.splice(l - 1, b.length);\n      }\n\n      e(b, d);\n\n      for (b = b.map(function (a) {\n        return {\n          size: a.size,\n          targets: [a.target],\n          align: v(a.align, .5)\n        };\n      }); n;) {\n        for (l = b.length; l--;) {\n          n = b[l], c = (Math.min.apply(0, n.targets) + Math.max.apply(0, n.targets)) / 2, n.pos = Math.min(Math.max(0, c - n.size * n.align), f - n.size);\n        }\n\n        l = b.length;\n\n        for (n = !1; l--;) {\n          0 < l && b[l - 1].pos + b[l - 1].size > b[l].pos && (b[l - 1].size += b[l].size, b[l - 1].targets = b[l - 1].targets.concat(b[l].targets), b[l - 1].align = .5, b[l - 1].pos + b[l - 1].size > f && (b[l - 1].pos = f - b[l - 1].size), b.splice(l, 1), n = !0);\n        }\n      }\n\n      p.push.apply(p, q);\n      l = 0;\n      b.some(function (c) {\n        var b = 0;\n        if (c.targets.some(function () {\n          p[l].pos = c.pos + b;\n          if (Math.abs(p[l].pos - p[l].target) > g) return p.slice(0, l + 1).forEach(function (a) {\n            delete a.pos;\n          }), p.reducedLen = (p.reducedLen || f) - .1 * f, p.reducedLen > .1 * f && a.distribute(p, f, g), !0;\n          b += p[l].size;\n          l++;\n        })) return !0;\n      });\n      e(p, d);\n    };\n\n    q.prototype.drawDataLabels = function () {\n      function b(a, c) {\n        var b = c.filter;\n        return b ? (c = b.operator, a = a[b.property], b = b.value, \"\\x3e\" === c && a > b || \"\\x3c\" === c && a < b || \"\\x3e\\x3d\" === c && a >= b || \"\\x3c\\x3d\" === c && a <= b || \"\\x3d\\x3d\" === c && a == b || \"\\x3d\\x3d\\x3d\" === c && a === b ? !0 : !1) : !0;\n      }\n\n      function e(a, c) {\n        var b = [],\n            d;\n        if (p(a) && !p(c)) b = a.map(function (a) {\n          return t(a, c);\n        });else if (p(c) && !p(a)) b = c.map(function (c) {\n          return t(a, c);\n        });else if (p(a) || p(c)) for (d = Math.max(a.length, c.length); d--;) {\n          b[d] = t(a[d], c[d]);\n        } else b = t(a, c);\n        return b;\n      }\n\n      var f = this,\n          d = f.chart,\n          q = f.options,\n          m = q.dataLabels,\n          C = f.points,\n          u,\n          c = f.hasRendered || 0,\n          k,\n          x = v(m.defer, !!q.animation),\n          D = d.renderer,\n          m = e(e(d.options.plotOptions && d.options.plotOptions.series && d.options.plotOptions.series.dataLabels, d.options.plotOptions && d.options.plotOptions[f.type] && d.options.plotOptions[f.type].dataLabels), m);\n      a.fireEvent(this, \"drawDataLabels\");\n      if (p(m) || m.enabled || f._hasPointLabels) k = f.plotGroup(\"dataLabelsGroup\", \"data-labels\", x && !c ? \"hidden\" : \"visible\", m.zIndex || 6), x && (k.attr({\n        opacity: +c\n      }), c || B(f, \"afterAnimate\", function () {\n        f.visible && k.show(!0);\n        k[q.animation ? \"animate\" : \"attr\"]({\n          opacity: 1\n        }, {\n          duration: 200\n        });\n      })), C.forEach(function (c) {\n        u = r(e(m, c.dlOptions || c.options && c.options.dataLabels));\n        u.forEach(function (h, e) {\n          var l = h.enabled && !c.isNull && b(c, h),\n              n,\n              p,\n              x,\n              w,\n              m = c.dataLabels ? c.dataLabels[e] : c.dataLabel,\n              r = c.connectors ? c.connectors[e] : c.connector,\n              E = !m;\n          l && (n = c.getLabelConfig(), p = h[c.formatPrefix + \"Format\"] || h.format, n = G(p) ? g(p, n, d.time) : (h[c.formatPrefix + \"Formatter\"] || h.formatter).call(n, h), p = h.style, x = h.rotation, d.styledMode || (p.color = v(h.color, p.color, f.color, \"#000000\"), \"contrast\" === p.color && (c.contrastColor = D.getContrast(c.color || f.color), p.color = h.inside || 0 > v(h.distance, c.labelDistance) || q.stacking ? c.contrastColor : \"#000000\"), q.cursor && (p.cursor = q.cursor)), w = {\n            r: h.borderRadius || 0,\n            rotation: x,\n            padding: h.padding,\n            zIndex: 1\n          }, d.styledMode || (w.fill = h.backgroundColor, w.stroke = h.borderColor, w[\"stroke-width\"] = h.borderWidth), a.objectEach(w, function (a, c) {\n            void 0 === a && delete w[c];\n          }));\n          !m || l && G(n) ? l && G(n) && (m ? w.text = n : (c.dataLabels = c.dataLabels || [], m = c.dataLabels[e] = x ? D.text(n, 0, -9999).addClass(\"highcharts-data-label\") : D.label(n, 0, -9999, h.shape, null, null, h.useHTML, null, \"data-label\"), e || (c.dataLabel = m), m.addClass(\" highcharts-data-label-color-\" + c.colorIndex + \" \" + (h.className || \"\") + (h.useHTML ? \" highcharts-tracker\" : \"\"))), m.options = h, m.attr(w), d.styledMode || m.css(p).shadow(h.shadow), m.added || m.add(k), f.alignDataLabel(c, m, h, null, E)) : (c.dataLabel = c.dataLabel && c.dataLabel.destroy(), c.dataLabels && (1 === c.dataLabels.length ? delete c.dataLabels : delete c.dataLabels[e]), e || delete c.dataLabel, r && (c.connector = c.connector.destroy(), c.connectors && (1 === c.connectors.length ? delete c.connectors : delete c.connectors[e])));\n        });\n      });\n      a.fireEvent(this, \"afterDrawDataLabels\");\n    };\n\n    q.prototype.alignDataLabel = function (a, e, f, d, g) {\n      var b = this.chart,\n          l = this.isCartesian && b.inverted,\n          n = v(a.dlBox && a.dlBox.centerX, a.plotX, -9999),\n          c = v(a.plotY, -9999),\n          k = e.getBBox(),\n          p,\n          q = f.rotation,\n          h = f.align,\n          w = this.visible && (a.series.forceDL || b.isInsidePlot(n, Math.round(c), l) || d && b.isInsidePlot(n, l ? d.x + 1 : d.y + d.height - 1, l)),\n          r = \"justify\" === v(f.overflow, \"justify\");\n      if (w && (p = b.renderer.fontMetrics(b.styledMode ? void 0 : f.style.fontSize, e).b, d = m({\n        x: l ? this.yAxis.len - c : n,\n        y: Math.round(l ? this.xAxis.len - n : c),\n        width: 0,\n        height: 0\n      }, d), m(f, {\n        width: k.width,\n        height: k.height\n      }), q ? (r = !1, n = b.renderer.rotCorr(p, q), n = {\n        x: d.x + f.x + d.width / 2 + n.x,\n        y: d.y + f.y + {\n          top: 0,\n          middle: .5,\n          bottom: 1\n        }[f.verticalAlign] * d.height\n      }, e[g ? \"attr\" : \"animate\"](n).attr({\n        align: h\n      }), c = (q + 720) % 360, c = 180 < c && 360 > c, \"left\" === h ? n.y -= c ? k.height : 0 : \"center\" === h ? (n.x -= k.width / 2, n.y -= k.height / 2) : \"right\" === h && (n.x -= k.width, n.y -= c ? 0 : k.height), e.placed = !0, e.alignAttr = n) : (e.align(f, null, d), n = e.alignAttr), r && 0 <= d.height ? a.isLabelJustified = this.justifyDataLabel(e, f, n, k, d, g) : v(f.crop, !0) && (w = b.isInsidePlot(n.x, n.y) && b.isInsidePlot(n.x + k.width, n.y + k.height)), f.shape && !q)) e[g ? \"attr\" : \"animate\"]({\n        anchorX: l ? b.plotWidth - a.plotY : a.plotX,\n        anchorY: l ? b.plotHeight - a.plotX : a.plotY\n      });\n      w || (e.attr({\n        y: -9999\n      }), e.placed = !1);\n    };\n\n    q.prototype.justifyDataLabel = function (a, e, f, d, g, p) {\n      var b = this.chart,\n          l = e.align,\n          c = e.verticalAlign,\n          k,\n          n,\n          q = a.box ? 0 : a.padding || 0;\n      k = f.x + q;\n      0 > k && (\"right\" === l ? e.align = \"left\" : e.x = -k, n = !0);\n      k = f.x + d.width - q;\n      k > b.plotWidth && (\"left\" === l ? e.align = \"right\" : e.x = b.plotWidth - k, n = !0);\n      k = f.y + q;\n      0 > k && (\"bottom\" === c ? e.verticalAlign = \"top\" : e.y = -k, n = !0);\n      k = f.y + d.height - q;\n      k > b.plotHeight && (\"top\" === c ? e.verticalAlign = \"bottom\" : e.y = b.plotHeight - k, n = !0);\n      n && (a.placed = !p, a.align(e, null, g));\n      return n;\n    };\n\n    f.pie && (f.pie.prototype.dataLabelPositioners = {\n      radialDistributionY: function radialDistributionY(a) {\n        return a.top + a.distributeBox.pos;\n      },\n      radialDistributionX: function radialDistributionX(a, e, f, d) {\n        return a.getX(f < e.top + 2 || f > e.bottom - 2 ? d : f, e.half, e);\n      },\n      justify: function justify(a, e, f) {\n        return f[0] + (a.half ? -1 : 1) * (e + a.labelDistance);\n      },\n      alignToPlotEdges: function alignToPlotEdges(a, e, f, d) {\n        a = a.getBBox().width;\n        return e ? a + d : f - a - d;\n      },\n      alignToConnectors: function alignToConnectors(a, e, f, d) {\n        var b = 0,\n            g;\n        a.forEach(function (a) {\n          g = a.dataLabel.getBBox().width;\n          g > b && (b = g);\n        });\n        return e ? b + d : f - b - d;\n      }\n    }, f.pie.prototype.drawDataLabels = function () {\n      var b = this,\n          e = b.data,\n          f,\n          d = b.chart,\n          g = b.options.dataLabels,\n          p = g.connectorPadding,\n          m = v(g.connectorWidth, 1),\n          r = d.plotWidth,\n          c = d.plotHeight,\n          k = d.plotLeft,\n          x = Math.round(d.chartWidth / 3),\n          t,\n          h = b.center,\n          z = h[2] / 2,\n          u = h[1],\n          y,\n          B,\n          I,\n          O,\n          R = [[], []],\n          K,\n          S,\n          H,\n          T,\n          P = [0, 0, 0, 0],\n          U = b.dataLabelPositioners;\n      b.visible && (g.enabled || b._hasPointLabels) && (e.forEach(function (a) {\n        a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({\n          width: \"auto\"\n        }).css({\n          width: \"auto\",\n          textOverflow: \"clip\"\n        }), a.dataLabel.shortened = !1);\n      }), q.prototype.drawDataLabels.apply(b), e.forEach(function (a) {\n        a.dataLabel && (a.visible ? (R[a.half].push(a), a.dataLabel._pos = null, !G(g.style.width) && !G(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > x && (a.dataLabel.css({\n          width: .7 * x\n        }), a.dataLabel.shortened = !0)) : (a.dataLabel = a.dataLabel.destroy(), a.dataLabels && 1 === a.dataLabels.length && delete a.dataLabels));\n      }), R.forEach(function (e, l) {\n        var n,\n            q,\n            x = e.length,\n            m = [],\n            w;\n        if (x) for (b.sortByAngle(e, l - .5), 0 < b.maxLabelDistance && (n = Math.max(0, u - z - b.maxLabelDistance), q = Math.min(u + z + b.maxLabelDistance, d.plotHeight), e.forEach(function (a) {\n          0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, u - z - a.labelDistance), a.bottom = Math.min(u + z + a.labelDistance, d.plotHeight), w = a.dataLabel.getBBox().height || 21, a.distributeBox = {\n            target: a.labelPosition.natural.y - a.top + w / 2,\n            size: w,\n            rank: a.y\n          }, m.push(a.distributeBox));\n        }), n = q + w - n, a.distribute(m, n, n / 5)), T = 0; T < x; T++) {\n          f = e[T];\n          I = f.labelPosition;\n          y = f.dataLabel;\n          H = !1 === f.visible ? \"hidden\" : \"inherit\";\n          S = n = I.natural.y;\n          m && G(f.distributeBox) && (void 0 === f.distributeBox.pos ? H = \"hidden\" : (O = f.distributeBox.size, S = U.radialDistributionY(f)));\n          delete f.positionIndex;\n          if (g.justify) K = U.justify(f, z, h);else switch (g.alignTo) {\n            case \"connectors\":\n              K = U.alignToConnectors(e, l, r, k);\n              break;\n\n            case \"plotEdges\":\n              K = U.alignToPlotEdges(y, l, r, k);\n              break;\n\n            default:\n              K = U.radialDistributionX(b, f, S, n);\n          }\n          y._attr = {\n            visibility: H,\n            align: I.alignment\n          };\n          y._pos = {\n            x: K + g.x + ({\n              left: p,\n              right: -p\n            }[I.alignment] || 0),\n            y: S + g.y - 10\n          };\n          I.final.x = K;\n          I.final.y = S;\n          v(g.crop, !0) && (B = y.getBBox().width, n = null, K - B < p && 1 === l ? (n = Math.round(B - K + p), P[3] = Math.max(n, P[3])) : K + B > r - p && 0 === l && (n = Math.round(K + B - r + p), P[1] = Math.max(n, P[1])), 0 > S - O / 2 ? P[0] = Math.max(Math.round(-S + O / 2), P[0]) : S + O / 2 > c && (P[2] = Math.max(Math.round(S + O / 2 - c), P[2])), y.sideOverflow = n);\n        }\n      }), 0 === A(P) || this.verifyDataLabelOverflow(P)) && (this.placeDataLabels(), m && this.points.forEach(function (a) {\n        var c;\n        t = a.connector;\n\n        if ((y = a.dataLabel) && y._pos && a.visible && 0 < a.labelDistance) {\n          H = y._attr.visibility;\n          if (c = !t) a.connector = t = d.renderer.path().addClass(\"highcharts-data-label-connector  highcharts-color-\" + a.colorIndex + (a.className ? \" \" + a.className : \"\")).add(b.dataLabelsGroup), d.styledMode || t.attr({\n            \"stroke-width\": m,\n            stroke: g.connectorColor || a.color || \"#666666\"\n          });\n          t[c ? \"attr\" : \"animate\"]({\n            d: a.getConnectorPath()\n          });\n          t.attr(\"visibility\", H);\n        } else t && (a.connector = t.destroy());\n      }));\n    }, f.pie.prototype.placeDataLabels = function () {\n      this.points.forEach(function (a) {\n        var b = a.dataLabel;\n        b && a.visible && ((a = b._pos) ? (b.sideOverflow && (b._attr.width = b.getBBox().width - b.sideOverflow, b.css({\n          width: b._attr.width + \"px\",\n          textOverflow: (this.options.dataLabels.style || {}).textOverflow || \"ellipsis\"\n        }), b.shortened = !0), b.attr(b._attr), b[b.moved ? \"animate\" : \"attr\"](a), b.moved = !0) : b && b.attr({\n          y: -9999\n        }));\n      }, this);\n    }, f.pie.prototype.alignDataLabel = u, f.pie.prototype.verifyDataLabelOverflow = function (a) {\n      var b = this.center,\n          e = this.options,\n          d = e.center,\n          f = e.minSize || 80,\n          g,\n          p = null !== e.size;\n      p || (null !== d[0] ? g = Math.max(b[2] - Math.max(a[1], a[3]), f) : (g = Math.max(b[2] - a[1] - a[3], f), b[0] += (a[3] - a[1]) / 2), null !== d[1] ? g = Math.max(Math.min(g, b[2] - Math.max(a[0], a[2])), f) : (g = Math.max(Math.min(g, b[2] - a[0] - a[2]), f), b[1] += (a[0] - a[2]) / 2), g < b[2] ? (b[2] = g, b[3] = Math.min(y(e.innerSize || 0, g), g), this.translate(b), this.drawDataLabels && this.drawDataLabels()) : p = !0);\n      return p;\n    });\n    f.column && (f.column.prototype.alignDataLabel = function (a, e, f, d, g) {\n      var b = this.chart.inverted,\n          l = a.series,\n          n = a.dlBox || a.shapeArgs,\n          c = v(a.below, a.plotY > v(this.translatedThreshold, l.yAxis.len)),\n          k = v(f.inside, !!this.options.stacking);\n      n && (d = t(n), 0 > d.y && (d.height += d.y, d.y = 0), n = d.y + d.height - l.yAxis.len, 0 < n && (d.height -= n), b && (d = {\n        x: l.yAxis.len - d.y - d.height,\n        y: l.xAxis.len - d.x - d.width,\n        width: d.height,\n        height: d.width\n      }), k || (b ? (d.x += c ? 0 : d.width, d.width = 0) : (d.y += c ? d.height : 0, d.height = 0)));\n      f.align = v(f.align, !b || k ? \"center\" : c ? \"right\" : \"left\");\n      f.verticalAlign = v(f.verticalAlign, b || k ? \"middle\" : c ? \"top\" : \"bottom\");\n      q.prototype.alignDataLabel.call(this, a, e, f, d, g);\n      a.isLabelJustified && a.contrastColor && e.css({\n        color: a.contrastColor\n      });\n    });\n  })(H);\n\n  (function (a) {\n    var B = a.Chart,\n        A = a.isArray,\n        G = a.objectEach,\n        m = a.pick,\n        g = a.addEvent,\n        t = a.fireEvent;\n    g(B, \"render\", function () {\n      var a = [];\n      (this.labelCollectors || []).forEach(function (g) {\n        a = a.concat(g());\n      });\n      (this.yAxis || []).forEach(function (g) {\n        g.options.stackLabels && !g.options.stackLabels.allowOverlap && G(g.stacks, function (g) {\n          G(g, function (g) {\n            a.push(g.label);\n          });\n        });\n      });\n      (this.series || []).forEach(function (g) {\n        var t = g.options.dataLabels;\n        g.visible && (!1 !== t.enabled || g._hasPointLabels) && g.points.forEach(function (g) {\n          g.visible && (A(g.dataLabels) ? g.dataLabels : g.dataLabel ? [g.dataLabel] : []).forEach(function (f) {\n            var e = f.options;\n            f.labelrank = m(e.labelrank, g.labelrank, g.shapeArgs && g.shapeArgs.height);\n            e.allowOverlap || a.push(f);\n          });\n        });\n      });\n      this.hideOverlappingLabels(a);\n    });\n\n    B.prototype.hideOverlappingLabels = function (a) {\n      var g = this,\n          m = a.length,\n          q = g.renderer,\n          f,\n          e,\n          p,\n          r,\n          b,\n          l,\n          n = function n(a, b, e, f, g, c, k, l) {\n        return !(g > a + e || g + k < a || c > b + f || c + l < b);\n      };\n\n      p = function p(a) {\n        var b,\n            d,\n            e,\n            f = a.box ? 0 : a.padding || 0;\n        e = 0;\n        if (a && (!a.alignAttr || a.placed)) return b = a.alignAttr || {\n          x: a.attr(\"x\"),\n          y: a.attr(\"y\")\n        }, d = a.parentGroup, a.width || (e = a.getBBox(), a.width = e.width, a.height = e.height, e = q.fontMetrics(null, a.element).h), {\n          x: b.x + (d.translateX || 0) + f,\n          y: b.y + (d.translateY || 0) + f - e,\n          width: a.width - 2 * f,\n          height: a.height - 2 * f\n        };\n      };\n\n      for (e = 0; e < m; e++) {\n        if (f = a[e]) f.oldOpacity = f.opacity, f.newOpacity = 1, f.absoluteBox = p(f);\n      }\n\n      a.sort(function (a, b) {\n        return (b.labelrank || 0) - (a.labelrank || 0);\n      });\n\n      for (e = 0; e < m; e++) {\n        for (l = (p = a[e]) && p.absoluteBox, f = e + 1; f < m; ++f) {\n          if (b = (r = a[f]) && r.absoluteBox, l && b && p !== r && 0 !== p.newOpacity && 0 !== r.newOpacity && (b = n(l.x, l.y, l.width, l.height, b.x, b.y, b.width, b.height))) (p.labelrank < r.labelrank ? p : r).newOpacity = 0;\n        }\n      }\n\n      a.forEach(function (a) {\n        var b, d;\n        a && (d = a.newOpacity, a.oldOpacity !== d && (a.alignAttr && a.placed ? (d ? a.show(!0) : b = function b() {\n          a.hide();\n        }, a.alignAttr.opacity = d, a[a.isOld ? \"animate\" : \"attr\"](a.alignAttr, null, b), t(g, \"afterHideOverlappingLabels\")) : a.attr({\n          opacity: d\n        })), a.isOld = !0);\n      });\n    };\n  })(H);\n\n  (function (a) {\n    var B = a.addEvent,\n        A = a.Chart,\n        G = a.createElement,\n        m = a.css,\n        g = a.defaultOptions,\n        t = a.defaultPlotOptions,\n        u = a.extend,\n        v = a.fireEvent,\n        y = a.hasTouch,\n        q = a.isObject,\n        f = a.Legend,\n        e = a.merge,\n        p = a.pick,\n        r = a.Point,\n        b = a.Series,\n        l = a.seriesTypes,\n        n = a.svg,\n        d;\n    d = a.TrackerMixin = {\n      drawTrackerPoint: function drawTrackerPoint() {\n        var a = this,\n            b = a.chart,\n            d = b.pointer,\n            e = function e(a) {\n          var c = d.getPointFromEvent(a);\n          void 0 !== c && (d.isDirectTouch = !0, c.onMouseOver(a));\n        };\n\n        a.points.forEach(function (a) {\n          a.graphic && (a.graphic.element.point = a);\n          a.dataLabel && (a.dataLabel.div ? a.dataLabel.div.point = a : a.dataLabel.element.point = a);\n        });\n        a._hasTracking || (a.trackerGroups.forEach(function (c) {\n          if (a[c]) {\n            a[c].addClass(\"highcharts-tracker\").on(\"mouseover\", e).on(\"mouseout\", function (a) {\n              d.onTrackerMouseOut(a);\n            });\n            if (y) a[c].on(\"touchstart\", e);\n            !b.styledMode && a.options.cursor && a[c].css(m).css({\n              cursor: a.options.cursor\n            });\n          }\n        }), a._hasTracking = !0);\n        v(this, \"afterDrawTracker\");\n      },\n      drawTrackerGraph: function drawTrackerGraph() {\n        var a = this,\n            b = a.options,\n            d = b.trackByArea,\n            e = [].concat(d ? a.areaPath : a.graphPath),\n            c = e.length,\n            k = a.chart,\n            f = k.pointer,\n            g = k.renderer,\n            h = k.options.tooltip.snap,\n            l = a.tracker,\n            p,\n            q = function q() {\n          if (k.hoverSeries !== a) a.onMouseOver();\n        },\n            m = \"rgba(192,192,192,\" + (n ? .0001 : .002) + \")\";\n\n        if (c && !d) for (p = c + 1; p--;) {\n          \"M\" === e[p] && e.splice(p + 1, 0, e[p + 1] - h, e[p + 2], \"L\"), (p && \"M\" === e[p] || p === c) && e.splice(p, 0, \"L\", e[p - 2] + h, e[p - 1]);\n        }\n        l ? l.attr({\n          d: e\n        }) : a.graph && (a.tracker = g.path(e).attr({\n          visibility: a.visible ? \"visible\" : \"hidden\",\n          zIndex: 2\n        }).addClass(d ? \"highcharts-tracker-area\" : \"highcharts-tracker-line\").add(a.group), k.styledMode || a.tracker.attr({\n          \"stroke-linejoin\": \"round\",\n          stroke: m,\n          fill: d ? m : \"none\",\n          \"stroke-width\": a.graph.strokeWidth() + (d ? 0 : 2 * h)\n        }), [a.tracker, a.markerGroup].forEach(function (a) {\n          a.addClass(\"highcharts-tracker\").on(\"mouseover\", q).on(\"mouseout\", function (a) {\n            f.onTrackerMouseOut(a);\n          });\n          b.cursor && !k.styledMode && a.css({\n            cursor: b.cursor\n          });\n          if (y) a.on(\"touchstart\", q);\n        }));\n        v(this, \"afterDrawTracker\");\n      }\n    };\n    l.column && (l.column.prototype.drawTracker = d.drawTrackerPoint);\n    l.pie && (l.pie.prototype.drawTracker = d.drawTrackerPoint);\n    l.scatter && (l.scatter.prototype.drawTracker = d.drawTrackerPoint);\n    u(f.prototype, {\n      setItemEvents: function setItemEvents(a, b, d) {\n        var f = this,\n            c = f.chart.renderer.boxWrapper,\n            k = \"highcharts-legend-\" + (a instanceof r ? \"point\" : \"series\") + \"-active\",\n            g = f.chart.styledMode;\n        (d ? b : a.legendGroup).on(\"mouseover\", function () {\n          a.setState(\"hover\");\n          c.addClass(k);\n          g || b.css(f.options.itemHoverStyle);\n        }).on(\"mouseout\", function () {\n          f.styledMode || b.css(e(a.visible ? f.itemStyle : f.itemHiddenStyle));\n          c.removeClass(k);\n          a.setState();\n        }).on(\"click\", function (b) {\n          var d = function d() {\n            a.setVisible && a.setVisible();\n          };\n\n          c.removeClass(k);\n          b = {\n            browserEvent: b\n          };\n          a.firePointEvent ? a.firePointEvent(\"legendItemClick\", b, d) : v(a, \"legendItemClick\", b, d);\n        });\n      },\n      createCheckboxForItem: function createCheckboxForItem(a) {\n        a.checkbox = G(\"input\", {\n          type: \"checkbox\",\n          className: \"highcharts-legend-checkbox\",\n          checked: a.selected,\n          defaultChecked: a.selected\n        }, this.options.itemCheckboxStyle, this.chart.container);\n        B(a.checkbox, \"click\", function (b) {\n          v(a.series || a, \"checkboxClick\", {\n            checked: b.target.checked,\n            item: a\n          }, function () {\n            a.select();\n          });\n        });\n      }\n    });\n    u(A.prototype, {\n      showResetZoom: function showResetZoom() {\n        function a() {\n          b.zoomOut();\n        }\n\n        var b = this,\n            d = g.lang,\n            e = b.options.chart.resetZoomButton,\n            c = e.theme,\n            k = c.states,\n            f = \"chart\" === e.relativeTo ? null : \"plotBox\";\n        v(this, \"beforeShowResetZoom\", null, function () {\n          b.resetZoomButton = b.renderer.button(d.resetZoom, null, null, a, c, k && k.hover).attr({\n            align: e.position.align,\n            title: d.resetZoomTitle\n          }).addClass(\"highcharts-reset-zoom\").add().align(e.position, !1, f);\n        });\n      },\n      zoomOut: function zoomOut() {\n        v(this, \"selection\", {\n          resetSelection: !0\n        }, this.zoom);\n      },\n      zoom: function zoom(a) {\n        var b,\n            d = this.pointer,\n            e = !1,\n            c;\n        !a || a.resetSelection ? (this.axes.forEach(function (a) {\n          b = a.zoom();\n        }), d.initiated = !1) : a.xAxis.concat(a.yAxis).forEach(function (a) {\n          var c = a.axis;\n          d[c.isXAxis ? \"zoomX\" : \"zoomY\"] && (b = c.zoom(a.min, a.max), c.displayBtn && (e = !0));\n        });\n        c = this.resetZoomButton;\n        e && !c ? this.showResetZoom() : !e && q(c) && (this.resetZoomButton = c.destroy());\n        b && this.redraw(p(this.options.chart.animation, a && a.animation, 100 > this.pointCount));\n      },\n      pan: function pan(a, b) {\n        var d = this,\n            e = d.hoverPoints,\n            c;\n        v(this, \"pan\", {\n          originalEvent: a\n        }, function () {\n          e && e.forEach(function (a) {\n            a.setState();\n          });\n          (\"xy\" === b ? [1, 0] : [1]).forEach(function (b) {\n            b = d[b ? \"xAxis\" : \"yAxis\"][0];\n            var k = b.horiz,\n                e = a[k ? \"chartX\" : \"chartY\"],\n                k = k ? \"mouseDownX\" : \"mouseDownY\",\n                h = d[k],\n                f = (b.pointRange || 0) / 2,\n                g = b.reversed && !d.inverted || !b.reversed && d.inverted ? -1 : 1,\n                l = b.getExtremes(),\n                n = b.toValue(h - e, !0) + f * g,\n                g = b.toValue(h + b.len - e, !0) - f * g,\n                p = g < n,\n                h = p ? g : n,\n                n = p ? n : g,\n                g = Math.min(l.dataMin, f ? l.min : b.toValue(b.toPixels(l.min) - b.minPixelPadding)),\n                f = Math.max(l.dataMax, f ? l.max : b.toValue(b.toPixels(l.max) + b.minPixelPadding)),\n                p = g - h;\n            0 < p && (n += p, h = g);\n            p = n - f;\n            0 < p && (n = f, h -= p);\n            b.series.length && h !== l.min && n !== l.max && (b.setExtremes(h, n, !1, !1, {\n              trigger: \"pan\"\n            }), c = !0);\n            d[k] = e;\n          });\n          c && d.redraw(!1);\n          m(d.container, {\n            cursor: \"move\"\n          });\n        });\n      }\n    });\n    u(r.prototype, {\n      select: function select(a, b) {\n        var d = this,\n            e = d.series,\n            c = e.chart;\n        a = p(a, !d.selected);\n        d.firePointEvent(a ? \"select\" : \"unselect\", {\n          accumulate: b\n        }, function () {\n          d.selected = d.options.selected = a;\n          e.options.data[e.data.indexOf(d)] = d.options;\n          d.setState(a && \"select\");\n          b || c.getSelectedPoints().forEach(function (a) {\n            a.selected && a !== d && (a.selected = a.options.selected = !1, e.options.data[e.data.indexOf(a)] = a.options, a.setState(\"\"), a.firePointEvent(\"unselect\"));\n          });\n        });\n      },\n      onMouseOver: function onMouseOver(a) {\n        var b = this.series.chart,\n            d = b.pointer;\n        a = a ? d.normalize(a) : d.getChartCoordinatesFromPoint(this, b.inverted);\n        d.runPointActions(a, this);\n      },\n      onMouseOut: function onMouseOut() {\n        var a = this.series.chart;\n        this.firePointEvent(\"mouseOut\");\n        (a.hoverPoints || []).forEach(function (a) {\n          a.setState();\n        });\n        a.hoverPoints = a.hoverPoint = null;\n      },\n      importEvents: function importEvents() {\n        if (!this.hasImportedEvents) {\n          var b = this,\n              d = e(b.series.options.point, b.options).events;\n          b.events = d;\n          a.objectEach(d, function (a, d) {\n            B(b, d, a);\n          });\n          this.hasImportedEvents = !0;\n        }\n      },\n      setState: function setState(a, b) {\n        var d = Math.floor(this.plotX),\n            e = this.plotY,\n            c = this.series,\n            k = c.options.states[a || \"normal\"] || {},\n            f = t[c.type].marker && c.options.marker,\n            g = f && !1 === f.enabled,\n            h = f && f.states && f.states[a || \"normal\"] || {},\n            l = !1 === h.enabled,\n            n = c.stateMarkerGraphic,\n            q = this.marker || {},\n            m = c.chart,\n            r = c.halo,\n            w,\n            E = f && c.markerAttribs;\n        a = a || \"\";\n\n        if (!(a === this.state && !b || this.selected && \"select\" !== a || !1 === k.enabled || a && (l || g && !1 === h.enabled) || a && q.states && q.states[a] && !1 === q.states[a].enabled)) {\n          E && (w = c.markerAttribs(this, a));\n          if (this.graphic) this.state && this.graphic.removeClass(\"highcharts-point-\" + this.state), a && this.graphic.addClass(\"highcharts-point-\" + a), m.styledMode || this.graphic.animate(c.pointAttribs(this, a), p(m.options.chart.animation, k.animation)), w && this.graphic.animate(w, p(m.options.chart.animation, h.animation, f.animation)), n && n.hide();else {\n            if (a && h) {\n              f = q.symbol || c.symbol;\n              n && n.currentSymbol !== f && (n = n.destroy());\n              if (n) n[b ? \"animate\" : \"attr\"]({\n                x: w.x,\n                y: w.y\n              });else f && (c.stateMarkerGraphic = n = m.renderer.symbol(f, w.x, w.y, w.width, w.height).add(c.markerGroup), n.currentSymbol = f);\n              !m.styledMode && n && n.attr(c.pointAttribs(this, a));\n            }\n\n            n && (n[a && m.isInsidePlot(d, e, m.inverted) ? \"show\" : \"hide\"](), n.element.point = this);\n          }\n          (d = k.halo) && d.size ? (r || (c.halo = r = m.renderer.path().add((this.graphic || n).parentGroup)), r.show()[b ? \"animate\" : \"attr\"]({\n            d: this.haloPath(d.size)\n          }), r.attr({\n            \"class\": \"highcharts-halo highcharts-color-\" + p(this.colorIndex, c.colorIndex) + (this.className ? \" \" + this.className : \"\"),\n            zIndex: -1\n          }), r.point = this, m.styledMode || r.attr(u({\n            fill: this.color || c.color,\n            \"fill-opacity\": d.opacity\n          }, d.attributes))) : r && r.point && r.point.haloPath && r.animate({\n            d: r.point.haloPath(0)\n          }, null, r.hide);\n          this.state = a;\n          v(this, \"afterSetState\");\n        }\n      },\n      haloPath: function haloPath(a) {\n        return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a);\n      }\n    });\n    u(b.prototype, {\n      onMouseOver: function onMouseOver() {\n        var a = this.chart,\n            b = a.hoverSeries;\n        if (b && b !== this) b.onMouseOut();\n        this.options.events.mouseOver && v(this, \"mouseOver\");\n        this.setState(\"hover\");\n        a.hoverSeries = this;\n      },\n      onMouseOut: function onMouseOut() {\n        var a = this.options,\n            b = this.chart,\n            d = b.tooltip,\n            e = b.hoverPoint;\n        b.hoverSeries = null;\n        if (e) e.onMouseOut();\n        this && a.events.mouseOut && v(this, \"mouseOut\");\n        !d || this.stickyTracking || d.shared && !this.noSharedTooltip || d.hide();\n        this.setState();\n      },\n      setState: function setState(a) {\n        var b = this,\n            d = b.options,\n            e = b.graph,\n            c = d.states,\n            k = d.lineWidth,\n            d = 0;\n        a = a || \"\";\n        if (b.state !== a && ([b.group, b.markerGroup, b.dataLabelsGroup].forEach(function (c) {\n          c && (b.state && c.removeClass(\"highcharts-series-\" + b.state), a && c.addClass(\"highcharts-series-\" + a));\n        }), b.state = a, !(b.chart.styledMode || c[a] && !1 === c[a].enabled) && (a && (k = c[a].lineWidth || k + (c[a].lineWidthPlus || 0)), e && !e.dashstyle))) for (k = {\n          \"stroke-width\": k\n        }, e.animate(k, p(c[a || \"normal\"] && c[a || \"normal\"].animation, b.chart.options.chart.animation)); b[\"zone-graph-\" + d];) {\n          b[\"zone-graph-\" + d].attr(k), d += 1;\n        }\n      },\n      setVisible: function setVisible(a, b) {\n        var d = this,\n            e = d.chart,\n            c = d.legendItem,\n            k,\n            f = e.options.chart.ignoreHiddenSeries,\n            g = d.visible;\n        k = (d.visible = a = d.options.visible = d.userOptions.visible = void 0 === a ? !g : a) ? \"show\" : \"hide\";\n        [\"group\", \"dataLabelsGroup\", \"markerGroup\", \"tracker\", \"tt\"].forEach(function (a) {\n          if (d[a]) d[a][k]();\n        });\n        if (e.hoverSeries === d || (e.hoverPoint && e.hoverPoint.series) === d) d.onMouseOut();\n        c && e.legend.colorizeItem(d, a);\n        d.isDirty = !0;\n        d.options.stacking && e.series.forEach(function (a) {\n          a.options.stacking && a.visible && (a.isDirty = !0);\n        });\n        d.linkedSeries.forEach(function (c) {\n          c.setVisible(a, !1);\n        });\n        f && (e.isDirtyBox = !0);\n        v(d, k);\n        !1 !== b && e.redraw();\n      },\n      show: function show() {\n        this.setVisible(!0);\n      },\n      hide: function hide() {\n        this.setVisible(!1);\n      },\n      select: function select(a) {\n        this.selected = a = this.options.selected = void 0 === a ? !this.selected : a;\n        this.checkbox && (this.checkbox.checked = a);\n        v(this, a ? \"select\" : \"unselect\");\n      },\n      drawTracker: d.drawTrackerGraph\n    });\n  })(H);\n\n  (function (a) {\n    var B = a.Chart,\n        A = a.isArray,\n        G = a.isObject,\n        m = a.pick,\n        g = a.splat;\n\n    B.prototype.setResponsive = function (g, m) {\n      var t = this.options.responsive,\n          u = [],\n          q = this.currentResponsive;\n      !m && t && t.rules && t.rules.forEach(function (f) {\n        void 0 === f._id && (f._id = a.uniqueKey());\n        this.matchResponsiveRule(f, u, g);\n      }, this);\n      m = a.merge.apply(0, u.map(function (f) {\n        return a.find(t.rules, function (a) {\n          return a._id === f;\n        }).chartOptions;\n      }));\n      m.isResponsiveOptions = !0;\n      u = u.toString() || void 0;\n      u !== (q && q.ruleIds) && (q && this.update(q.undoOptions, g), u ? (q = this.currentOptions(m), q.isResponsiveOptions = !0, this.currentResponsive = {\n        ruleIds: u,\n        mergedOptions: m,\n        undoOptions: q\n      }, this.update(m, g)) : this.currentResponsive = void 0);\n    };\n\n    B.prototype.matchResponsiveRule = function (a, g) {\n      var t = a.condition;\n      (t.callback || function () {\n        return this.chartWidth <= m(t.maxWidth, Number.MAX_VALUE) && this.chartHeight <= m(t.maxHeight, Number.MAX_VALUE) && this.chartWidth >= m(t.minWidth, 0) && this.chartHeight >= m(t.minHeight, 0);\n      }).call(this) && g.push(a._id);\n    };\n\n    B.prototype.currentOptions = function (m) {\n      function t(m, q, f, e) {\n        var p;\n        a.objectEach(m, function (a, b) {\n          if (!e && -1 < [\"series\", \"xAxis\", \"yAxis\"].indexOf(b)) for (a = g(a), f[b] = [], p = 0; p < a.length; p++) {\n            q[b][p] && (f[b][p] = {}, t(a[p], q[b][p], f[b][p], e + 1));\n          } else G(a) ? (f[b] = A(a) ? [] : {}, t(a, q[b] || {}, f[b], e + 1)) : f[b] = q[b] || null;\n        });\n      }\n\n      var v = {};\n      t(m, this.options, v, 0);\n      return v;\n    };\n  })(H);\n\n  (function (a) {\n    var B = a.addEvent,\n        A = a.Axis,\n        G = a.Chart,\n        m = a.css,\n        g = a.defined,\n        t = a.extend,\n        u = a.noop,\n        v = a.pick,\n        y = a.timeUnits;\n    B(a.Series, \"updatedData\", function () {\n      var a = this.xAxis;\n      a && a.options.ordinal && delete a.ordinalIndex;\n    });\n\n    A.prototype.getTimeTicks = function (a, f, e, p, m, b, l) {\n      var n = 0,\n          d,\n          q,\n          r = {},\n          t,\n          v,\n          c,\n          k = [],\n          x = -Number.MAX_VALUE,\n          D = this.options.tickPixelInterval,\n          h = this.chart.time,\n          z = [];\n      if (!this.options.ordinal && !this.options.breaks || !m || 3 > m.length || void 0 === f) return h.getTimeTicks.apply(h, arguments);\n      v = m.length;\n\n      for (d = 0; d < v; d++) {\n        c = d && m[d - 1] > e;\n        m[d] < f && (n = d);\n\n        if (d === v - 1 || m[d + 1] - m[d] > 5 * b || c) {\n          if (m[d] > x) {\n            for (q = h.getTimeTicks(a, m[n], m[d], p); q.length && q[0] <= x;) {\n              q.shift();\n            }\n\n            q.length && (x = q[q.length - 1]);\n            z.push(k.length);\n            k = k.concat(q);\n          }\n\n          n = d + 1;\n        }\n\n        if (c) break;\n      }\n\n      q = q.info;\n\n      if (l && q.unitRange <= y.hour) {\n        d = k.length - 1;\n\n        for (n = 1; n < d; n++) {\n          h.dateFormat(\"%d\", k[n]) !== h.dateFormat(\"%d\", k[n - 1]) && (r[k[n]] = \"day\", t = !0);\n        }\n\n        t && (r[k[0]] = \"day\");\n        q.higherRanks = r;\n      }\n\n      q.segmentStarts = z;\n      k.info = q;\n\n      if (l && g(D)) {\n        n = z = k.length;\n        t = [];\n\n        for (var u, h = []; n--;) {\n          d = this.translate(k[n]), u && (h[n] = u - d), t[n] = u = d;\n        }\n\n        h.sort();\n        h = h[Math.floor(h.length / 2)];\n        h < .6 * D && (h = null);\n        n = k[z - 1] > e ? z - 1 : z;\n\n        for (u = void 0; n--;) {\n          d = t[n], z = Math.abs(u - d), u && z < .8 * D && (null === h || z < .8 * h) ? (r[k[n]] && !r[k[n + 1]] ? (z = n + 1, u = d) : z = n, k.splice(z, 1)) : u = d;\n        }\n      }\n\n      return k;\n    };\n\n    t(A.prototype, {\n      beforeSetTickPositions: function beforeSetTickPositions() {\n        var a,\n            f = [],\n            e,\n            g = !1,\n            m,\n            b = this.getExtremes(),\n            l = b.min,\n            n = b.max,\n            d,\n            w = this.isXAxis && !!this.options.breaks,\n            b = this.options.ordinal,\n            t = Number.MAX_VALUE,\n            u = this.chart.options.chart.ignoreHiddenSeries,\n            y;\n\n        if (b || w) {\n          this.series.forEach(function (c, b) {\n            e = [];\n\n            if (!(u && !1 === c.visible || !1 === c.takeOrdinalPosition && !w) && (f = f.concat(c.processedXData), a = f.length, f.sort(function (a, b) {\n              return a - b;\n            }), t = Math.min(t, v(c.closestPointRange, t)), a)) {\n              for (b = 0; b < a - 1;) {\n                f[b] !== f[b + 1] && e.push(f[b + 1]), b++;\n              }\n\n              e[0] !== f[0] && e.unshift(f[0]);\n              f = e;\n            }\n\n            c.isSeriesBoosting && (y = !0);\n          });\n          y && (f.length = 0);\n          a = f.length;\n\n          if (2 < a) {\n            m = f[1] - f[0];\n\n            for (d = a - 1; d-- && !g;) {\n              f[d + 1] - f[d] !== m && (g = !0);\n            }\n\n            !this.options.keepOrdinalPadding && (f[0] - l > m || n - f[f.length - 1] > m) && (g = !0);\n          } else this.options.overscroll && (2 === a ? t = f[1] - f[0] : 1 === a ? (t = this.options.overscroll, f = [f[0], f[0] + t]) : t = this.overscrollPointsRange);\n\n          g ? (this.options.overscroll && (this.overscrollPointsRange = t, f = f.concat(this.getOverscrollPositions())), this.ordinalPositions = f, m = this.ordinal2lin(Math.max(l, f[0]), !0), d = Math.max(this.ordinal2lin(Math.min(n, f[f.length - 1]), !0), 1), this.ordinalSlope = n = (n - l) / (d - m), this.ordinalOffset = l - m * n) : (this.overscrollPointsRange = v(this.closestPointRange, this.overscrollPointsRange), this.ordinalPositions = this.ordinalSlope = this.ordinalOffset = void 0);\n        }\n\n        this.isOrdinal = b && g;\n        this.groupIntervalFactor = null;\n      },\n      val2lin: function val2lin(a, f) {\n        var e = this.ordinalPositions;\n\n        if (e) {\n          var g = e.length,\n              m,\n              b;\n\n          for (m = g; m--;) {\n            if (e[m] === a) {\n              b = m;\n              break;\n            }\n          }\n\n          for (m = g - 1; m--;) {\n            if (a > e[m] || 0 === m) {\n              a = (a - e[m]) / (e[m + 1] - e[m]);\n              b = m + a;\n              break;\n            }\n          }\n\n          f = f ? b : this.ordinalSlope * (b || 0) + this.ordinalOffset;\n        } else f = a;\n\n        return f;\n      },\n      lin2val: function lin2val(a, f) {\n        var e = this.ordinalPositions;\n\n        if (e) {\n          var g = this.ordinalSlope,\n              m = this.ordinalOffset,\n              b = e.length - 1,\n              l;\n          if (f) 0 > a ? a = e[0] : a > b ? a = e[b] : (b = Math.floor(a), l = a - b);else for (; b--;) {\n            if (f = g * b + m, a >= f) {\n              g = g * (b + 1) + m;\n              l = (a - f) / (g - f);\n              break;\n            }\n          }\n          return void 0 !== l && void 0 !== e[b] ? e[b] + (l ? l * (e[b + 1] - e[b]) : 0) : a;\n        }\n\n        return a;\n      },\n      getExtendedPositions: function getExtendedPositions() {\n        var a = this,\n            f = a.chart,\n            e = a.series[0].currentDataGrouping,\n            g = a.ordinalIndex,\n            m = e ? e.count + e.unitName : \"raw\",\n            b = a.options.overscroll,\n            l = a.getExtremes(),\n            n,\n            d;\n        g || (g = a.ordinalIndex = {});\n        g[m] || (n = {\n          series: [],\n          chart: f,\n          getExtremes: function getExtremes() {\n            return {\n              min: l.dataMin,\n              max: l.dataMax + b\n            };\n          },\n          options: {\n            ordinal: !0\n          },\n          val2lin: A.prototype.val2lin,\n          ordinal2lin: A.prototype.ordinal2lin\n        }, a.series.forEach(function (b) {\n          d = {\n            xAxis: n,\n            xData: b.xData.slice(),\n            chart: f,\n            destroyGroupedData: u\n          };\n          d.xData = d.xData.concat(a.getOverscrollPositions());\n          d.options = {\n            dataGrouping: e ? {\n              enabled: !0,\n              forced: !0,\n              approximation: \"open\",\n              units: [[e.unitName, [e.count]]]\n            } : {\n              enabled: !1\n            }\n          };\n          b.processData.apply(d);\n          n.series.push(d);\n        }), a.beforeSetTickPositions.apply(n), g[m] = n.ordinalPositions);\n        return g[m];\n      },\n      getOverscrollPositions: function getOverscrollPositions() {\n        var g = this.options.overscroll,\n            f = this.overscrollPointsRange,\n            e = [],\n            p = this.dataMax;\n        if (a.defined(f)) for (e.push(p); p <= this.dataMax + g;) {\n          p += f, e.push(p);\n        }\n        return e;\n      },\n      getGroupIntervalFactor: function getGroupIntervalFactor(a, f, e) {\n        var g;\n        e = e.processedXData;\n        var m = e.length,\n            b = [];\n        g = this.groupIntervalFactor;\n\n        if (!g) {\n          for (g = 0; g < m - 1; g++) {\n            b[g] = e[g + 1] - e[g];\n          }\n\n          b.sort(function (a, b) {\n            return a - b;\n          });\n          b = b[Math.floor(m / 2)];\n          a = Math.max(a, e[0]);\n          f = Math.min(f, e[m - 1]);\n          this.groupIntervalFactor = g = m * b / (f - a);\n        }\n\n        return g;\n      },\n      postProcessTickInterval: function postProcessTickInterval(a) {\n        var f = this.ordinalSlope;\n        return f ? this.options.breaks ? this.closestPointRange || a : a / (f / this.closestPointRange) : a;\n      }\n    });\n    A.prototype.ordinal2lin = A.prototype.val2lin;\n    B(G, \"pan\", function (a) {\n      var f = this.xAxis[0],\n          e = f.options.overscroll,\n          g = a.originalEvent.chartX,\n          q = !1;\n\n      if (f.options.ordinal && f.series.length) {\n        var b = this.mouseDownX,\n            l = f.getExtremes(),\n            n = l.dataMax,\n            d = l.min,\n            w = l.max,\n            t = this.hoverPoints,\n            v = f.closestPointRange || f.overscrollPointsRange,\n            b = (b - g) / (f.translationSlope * (f.ordinalSlope || v)),\n            u = {\n          ordinalPositions: f.getExtendedPositions()\n        },\n            v = f.lin2val,\n            c = f.val2lin,\n            k;\n        u.ordinalPositions ? 1 < Math.abs(b) && (t && t.forEach(function (a) {\n          a.setState();\n        }), 0 > b ? (t = u, k = f.ordinalPositions ? f : u) : (t = f.ordinalPositions ? f : u, k = u), u = k.ordinalPositions, n > u[u.length - 1] && u.push(n), this.fixedRange = w - d, b = f.toFixedRange(null, null, v.apply(t, [c.apply(t, [d, !0]) + b, !0]), v.apply(k, [c.apply(k, [w, !0]) + b, !0])), b.min >= Math.min(l.dataMin, d) && b.max <= Math.max(n, w) + e && f.setExtremes(b.min, b.max, !0, !1, {\n          trigger: \"pan\"\n        }), this.mouseDownX = g, m(this.container, {\n          cursor: \"move\"\n        })) : q = !0;\n      } else q = !0;\n\n      q ? e && (f.max = f.dataMax + e) : a.preventDefault();\n    });\n    B(A, \"foundExtremes\", function () {\n      this.isXAxis && g(this.options.overscroll) && this.max === this.dataMax && (!this.chart.mouseIsDown || this.isInternal) && (!this.eventArgs || this.eventArgs && \"navigator\" !== this.eventArgs.trigger) && (this.max += this.options.overscroll, !this.isInternal && g(this.userMin) && (this.min += this.options.overscroll));\n    });\n  })(H);\n\n  (function (a) {\n    var B = a.addEvent,\n        A = a.pick,\n        G = a.extend,\n        m = a.isArray,\n        g = a.fireEvent,\n        t = a.Axis,\n        u = a.Series;\n    G(t.prototype, {\n      isInBreak: function isInBreak(a, g) {\n        var m = a.repeat || Infinity,\n            f = a.from,\n            e = a.to - a.from;\n        g = g >= f ? (g - f) % m : m - (f - g) % m;\n        return a.inclusive ? g <= e : g < e && 0 !== g;\n      },\n      isInAnyBreak: function isInAnyBreak(a, g) {\n        var m = this.options.breaks,\n            f = m && m.length,\n            e,\n            p,\n            r;\n\n        if (f) {\n          for (; f--;) {\n            this.isInBreak(m[f], a) && (e = !0, p || (p = A(m[f].showPoints, !this.isXAxis)));\n          }\n\n          r = e && g ? e && !p : e;\n        }\n\n        return r;\n      }\n    });\n    B(t, \"afterInit\", function () {\n      \"function\" === typeof this.setBreaks && this.setBreaks(this.options.breaks, !1);\n    });\n    B(t, \"afterSetTickPositions\", function () {\n      if (this.isBroken) {\n        var a = this.tickPositions,\n            g = this.tickPositions.info,\n            m = [],\n            f;\n\n        for (f = 0; f < a.length; f++) {\n          this.isInAnyBreak(a[f]) || m.push(a[f]);\n        }\n\n        this.tickPositions = m;\n        this.tickPositions.info = g;\n      }\n    });\n    B(t, \"afterSetOptions\", function () {\n      this.isBroken && (this.options.ordinal = !1);\n    });\n\n    t.prototype.setBreaks = function (a, u) {\n      function q(a) {\n        var b = a,\n            f,\n            g;\n\n        for (g = 0; g < e.breakArray.length; g++) {\n          if (f = e.breakArray[g], f.to <= a) b -= f.len;else if (f.from >= a) break;else if (e.isInBreak(f, a)) {\n            b -= a - f.from;\n            break;\n          }\n        }\n\n        return b;\n      }\n\n      function f(a) {\n        var b, f;\n\n        for (f = 0; f < e.breakArray.length && !(b = e.breakArray[f], b.from >= a); f++) {\n          b.to < a ? a += b.len : e.isInBreak(b, a) && (a += b.len);\n        }\n\n        return a;\n      }\n\n      var e = this,\n          p = m(a) && !!a.length;\n      e.isDirty = e.isBroken !== p;\n      e.isBroken = p;\n      e.options.breaks = e.userOptions.breaks = a;\n      e.forceRedraw = !0;\n      p || e.val2lin !== q || (delete e.val2lin, delete e.lin2val);\n      p && (e.userOptions.ordinal = !1, e.val2lin = q, e.lin2val = f, e.setExtremes = function (a, b, e, f, d) {\n        if (this.isBroken) {\n          for (; this.isInAnyBreak(a);) {\n            a -= this.closestPointRange;\n          }\n\n          for (; this.isInAnyBreak(b);) {\n            b -= this.closestPointRange;\n          }\n        }\n\n        t.prototype.setExtremes.call(this, a, b, e, f, d);\n      }, e.setAxisTranslation = function (a) {\n        t.prototype.setAxisTranslation.call(this, a);\n        this.unitLength = null;\n\n        if (this.isBroken) {\n          a = e.options.breaks;\n          var b = [],\n              f = [],\n              n = 0,\n              d,\n              m,\n              p = e.userMin || e.min,\n              q = e.userMax || e.max,\n              r = A(e.pointRangePadding, 0),\n              c,\n              k;\n          a.forEach(function (a) {\n            m = a.repeat || Infinity;\n            e.isInBreak(a, p) && (p += a.to % m - p % m);\n            e.isInBreak(a, q) && (q -= q % m - a.from % m);\n          });\n          a.forEach(function (a) {\n            c = a.from;\n\n            for (m = a.repeat || Infinity; c - m > p;) {\n              c -= m;\n            }\n\n            for (; c < p;) {\n              c += m;\n            }\n\n            for (k = c; k < q; k += m) {\n              b.push({\n                value: k,\n                move: \"in\"\n              }), b.push({\n                value: k + (a.to - a.from),\n                move: \"out\",\n                size: a.breakSize\n              });\n            }\n          });\n          b.sort(function (a, b) {\n            return a.value === b.value ? (\"in\" === a.move ? 0 : 1) - (\"in\" === b.move ? 0 : 1) : a.value - b.value;\n          });\n          d = 0;\n          c = p;\n          b.forEach(function (a) {\n            d += \"in\" === a.move ? 1 : -1;\n            1 === d && \"in\" === a.move && (c = a.value);\n            0 === d && (f.push({\n              from: c,\n              to: a.value,\n              len: a.value - c - (a.size || 0)\n            }), n += a.value - c - (a.size || 0));\n          });\n          e.breakArray = f;\n          e.unitLength = q - p - n + r;\n          g(e, \"afterBreaks\");\n          e.staticScale ? e.transA = e.staticScale : e.unitLength && (e.transA *= (q - e.min + r) / e.unitLength);\n          r && (e.minPixelPadding = e.transA * e.minPointOffset);\n          e.min = p;\n          e.max = q;\n        }\n      });\n      A(u, !0) && this.chart.redraw();\n    };\n\n    B(u, \"afterGeneratePoints\", function () {\n      var a = this.xAxis,\n          g = this.yAxis,\n          m = this.points,\n          f,\n          e = m.length,\n          p = this.options.connectNulls,\n          r;\n      if (a && g && (a.options.breaks || g.options.breaks)) for (; e--;) {\n        f = m[e], r = null === f.y && !1 === p, r || !a.isInAnyBreak(f.x, !0) && !g.isInAnyBreak(f.y, !0) || (m.splice(e, 1), this.data[e] && this.data[e].destroyElements());\n      }\n    });\n    B(u, \"afterRender\", function () {\n      this.drawBreaks(this.xAxis, [\"x\"]);\n      this.drawBreaks(this.yAxis, A(this.pointArrayMap, [\"y\"]));\n    });\n\n    a.Series.prototype.drawBreaks = function (a, m) {\n      var q = this,\n          f = q.points,\n          e,\n          p,\n          r,\n          b;\n      a && m.forEach(function (l) {\n        e = a.breakArray || [];\n        p = a.isXAxis ? a.min : A(q.options.threshold, a.min);\n        f.forEach(function (f) {\n          b = A(f[\"stack\" + l.toUpperCase()], f[l]);\n          e.forEach(function (d) {\n            r = !1;\n            if (p < d.from && b > d.to || p > d.from && b < d.from) r = \"pointBreak\";else if (p < d.from && b > d.from && b < d.to || p > d.from && b > d.to && b < d.from) r = \"pointInBreak\";\n            r && g(a, r, {\n              point: f,\n              brk: d\n            });\n          });\n        });\n      });\n    };\n\n    a.Series.prototype.gappedPath = function () {\n      var g = this.currentDataGrouping,\n          m = g && g.gapSize,\n          g = this.options.gapSize,\n          q = this.points.slice(),\n          f = q.length - 1,\n          e = this.yAxis;\n      if (g && 0 < f) for (\"value\" !== this.options.gapUnit && (g *= this.closestPointRange), m && m > g && (g = m); f--;) {\n        q[f + 1].x - q[f].x > g && (m = (q[f].x + q[f + 1].x) / 2, q.splice(f + 1, 0, {\n          isNull: !0,\n          x: m\n        }), this.options.stacking && (m = e.stacks[this.stackKey][m] = new a.StackItem(e, e.options.stackLabels, !1, m, this.stack), m.total = 0));\n      }\n      return this.getGraphPath(q);\n    };\n  })(H);\n\n  (function (a) {\n    var B = a.addEvent,\n        A = a.arrayMax,\n        G = a.arrayMin,\n        m = a.Axis,\n        g = a.defaultPlotOptions,\n        t = a.defined,\n        u = a.extend,\n        v = a.format,\n        y = a.isNumber,\n        q = a.merge,\n        f = a.pick,\n        e = a.Point,\n        p = a.Series,\n        r = a.Tooltip,\n        b = a.approximations = {\n      sum: function sum(a) {\n        var b = a.length,\n            c;\n        if (!b && a.hasNulls) c = null;else if (b) for (c = 0; b--;) {\n          c += a[b];\n        }\n        return c;\n      },\n      average: function average(a) {\n        var c = a.length;\n        a = b.sum(a);\n        y(a) && c && (a /= c);\n        return a;\n      },\n      averages: function averages() {\n        var a = [];\n        [].forEach.call(arguments, function (c) {\n          a.push(b.average(c));\n        });\n        return void 0 === a[0] ? void 0 : a;\n      },\n      open: function open(a) {\n        return a.length ? a[0] : a.hasNulls ? null : void 0;\n      },\n      high: function high(a) {\n        return a.length ? A(a) : a.hasNulls ? null : void 0;\n      },\n      low: function low(a) {\n        return a.length ? G(a) : a.hasNulls ? null : void 0;\n      },\n      close: function close(a) {\n        return a.length ? a[a.length - 1] : a.hasNulls ? null : void 0;\n      },\n      ohlc: function ohlc(a, c, d, e) {\n        a = b.open(a);\n        c = b.high(c);\n        d = b.low(d);\n        e = b.close(e);\n        if (y(a) || y(c) || y(d) || y(e)) return [a, c, d, e];\n      },\n      range: function range(a, c) {\n        a = b.low(a);\n        c = b.high(c);\n        if (y(a) || y(c)) return [a, c];\n        if (null === a && null === c) return null;\n      }\n    },\n        l = function l(a, c, d, e) {\n      var f = this,\n          h = f.data,\n          k = f.options && f.options.data,\n          g = [],\n          l = [],\n          n = [],\n          m = a.length,\n          p,\n          x,\n          r = !!c,\n          w = [],\n          u = f.pointArrayMap,\n          D = u && u.length,\n          v = [\"x\"].concat(u || [\"y\"]),\n          E = 0,\n          C = 0,\n          F,\n          A;\n      e = \"function\" === typeof e ? e : b[e] ? b[e] : b[f.getDGApproximation && f.getDGApproximation() || \"average\"];\n      D ? u.forEach(function () {\n        w.push([]);\n      }) : w.push([]);\n      F = D || 1;\n\n      for (A = 0; A <= m && !(a[A] >= d[0]); A++) {\n        ;\n      }\n\n      for (A; A <= m; A++) {\n        for (; void 0 !== d[E + 1] && a[A] >= d[E + 1] || A === m;) {\n          p = d[E];\n          f.dataGroupInfo = {\n            start: f.cropStart + C,\n            length: w[0].length\n          };\n          x = e.apply(f, w);\n          f.pointClass && !t(f.dataGroupInfo.options) && (f.dataGroupInfo.options = q(f.pointClass.prototype.optionsToObject.call({\n            series: f\n          }, f.options.data[f.cropStart + C])), v.forEach(function (a) {\n            delete f.dataGroupInfo.options[a];\n          }));\n          void 0 !== x && (g.push(p), l.push(x), n.push(f.dataGroupInfo));\n          C = A;\n\n          for (p = 0; p < F; p++) {\n            w[p].length = 0, w[p].hasNulls = !1;\n          }\n\n          E += 1;\n          if (A === m) break;\n        }\n\n        if (A === m) break;\n\n        if (u) {\n          p = f.cropStart + A;\n          x = h && h[p] || f.pointClass.prototype.applyOptions.apply({\n            series: f\n          }, [k[p]]);\n          var B;\n\n          for (p = 0; p < D; p++) {\n            B = x[u[p]], y(B) ? w[p].push(B) : null === B && (w[p].hasNulls = !0);\n          }\n        } else p = r ? c[A] : null, y(p) ? w[0].push(p) : null === p && (w[0].hasNulls = !0);\n      }\n\n      return {\n        groupedXData: g,\n        groupedYData: l,\n        groupMap: n\n      };\n    },\n        n = {\n      approximations: b,\n      groupData: l\n    },\n        d = p.prototype,\n        w = d.processData,\n        E = d.generatePoints,\n        C = {\n      groupPixelWidth: 2,\n      dateTimeLabelFormats: {\n        millisecond: [\"%A, %b %e, %H:%M:%S.%L\", \"%A, %b %e, %H:%M:%S.%L\", \"-%H:%M:%S.%L\"],\n        second: [\"%A, %b %e, %H:%M:%S\", \"%A, %b %e, %H:%M:%S\", \"-%H:%M:%S\"],\n        minute: [\"%A, %b %e, %H:%M\", \"%A, %b %e, %H:%M\", \"-%H:%M\"],\n        hour: [\"%A, %b %e, %H:%M\", \"%A, %b %e, %H:%M\", \"-%H:%M\"],\n        day: [\"%A, %b %e, %Y\", \"%A, %b %e\", \"-%A, %b %e, %Y\"],\n        week: [\"Week from %A, %b %e, %Y\", \"%A, %b %e\", \"-%A, %b %e, %Y\"],\n        month: [\"%B %Y\", \"%B\", \"-%B %Y\"],\n        year: [\"%Y\", \"%Y\", \"-%Y\"]\n      }\n    },\n        F = {\n      line: {},\n      spline: {},\n      area: {},\n      areaspline: {},\n      column: {\n        groupPixelWidth: 10\n      },\n      columnrange: {\n        groupPixelWidth: 10\n      },\n      candlestick: {\n        groupPixelWidth: 10\n      },\n      ohlc: {\n        groupPixelWidth: 5\n      }\n    },\n        c = a.defaultDataGroupingUnits = [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1]], [\"week\", [1]], [\"month\", [1, 3, 6]], [\"year\", null]];\n\n    d.getDGApproximation = function () {\n      return a.seriesTypes.arearange && this instanceof a.seriesTypes.arearange ? \"range\" : a.seriesTypes.ohlc && this instanceof a.seriesTypes.ohlc ? \"ohlc\" : a.seriesTypes.column && this instanceof a.seriesTypes.column ? \"sum\" : \"average\";\n    };\n\n    d.groupData = l;\n\n    d.processData = function () {\n      var a = this.chart,\n          b = this.options.dataGrouping,\n          e = !1 !== this.allowDG && b && f(b.enabled, a.options.isStock),\n          h = this.visible || !a.options.chart.ignoreHiddenSeries,\n          g,\n          l = this.currentDataGrouping,\n          n,\n          m = !1;\n      this.forceCrop = e;\n      this.groupPixelWidth = null;\n      this.hasProcessed = !0;\n      e && !this.requireSorting && (this.requireSorting = m = !0);\n      e = !1 === w.apply(this, arguments) || !e;\n      m && (this.requireSorting = !1);\n\n      if (!e) {\n        this.destroyGroupedData();\n        var p,\n            e = b.groupAll ? this.xData : this.processedXData,\n            q = b.groupAll ? this.yData : this.processedYData,\n            r = a.plotSizeX,\n            a = this.xAxis,\n            u = a.options.ordinal,\n            v = this.groupPixelWidth = a.getGroupPixelWidth && a.getGroupPixelWidth();\n\n        if (v) {\n          this.isDirty = g = !0;\n          this.points = null;\n          m = a.getExtremes();\n          n = m.min;\n          var m = m.max,\n              u = u && a.getGroupIntervalFactor(n, m, this) || 1,\n              v = v * (m - n) / r * u,\n              r = a.getTimeTicks(a.normalizeTimeTickInterval(v, b.units || c), Math.min(n, e[0]), Math.max(m, e[e.length - 1]), a.options.startOfWeek, e, this.closestPointRange),\n              q = d.groupData.apply(this, [e, q, r, b.approximation]),\n              e = q.groupedXData,\n              u = q.groupedYData,\n              E = 0;\n\n          if (b.smoothed && e.length) {\n            p = e.length - 1;\n\n            for (e[p] = Math.min(e[p], m); p-- && 0 < p;) {\n              e[p] += v / 2;\n            }\n\n            e[0] = Math.max(e[0], n);\n          }\n\n          for (p = 1; p < r.length; p++) {\n            r.info.segmentStarts && -1 !== r.info.segmentStarts.indexOf(p) || (E = Math.max(r[p] - r[p - 1], E));\n          }\n\n          n = r.info;\n          n.gapSize = E;\n          this.closestPointRange = r.info.totalRange;\n          this.groupMap = q.groupMap;\n\n          if (t(e[0]) && e[0] < a.dataMin && h) {\n            if (!t(a.options.min) && a.min <= a.dataMin || a.min === a.dataMin) a.min = e[0];\n            a.dataMin = e[0];\n          }\n\n          b.groupAll && (b = this.cropData(e, u, a.min, a.max, 1), e = b.xData, u = b.yData);\n          this.processedXData = e;\n          this.processedYData = u;\n        } else this.groupMap = null;\n\n        this.hasGroupedData = g;\n        this.currentDataGrouping = n;\n        this.preventGraphAnimation = (l && l.totalRange) !== (n && n.totalRange);\n      }\n    };\n\n    d.destroyGroupedData = function () {\n      var a = this.groupedData;\n      (a || []).forEach(function (b, c) {\n        b && (a[c] = b.destroy ? b.destroy() : null);\n      });\n      this.groupedData = null;\n    };\n\n    d.generatePoints = function () {\n      E.apply(this);\n      this.destroyGroupedData();\n      this.groupedData = this.hasGroupedData ? this.points : null;\n    };\n\n    B(e, \"update\", function () {\n      if (this.dataGroup) return a.error(24, !1, this.series.chart), !1;\n    });\n    B(r, \"headerFormatter\", function (a) {\n      var b = this.chart.time,\n          c = a.labelConfig,\n          d = c.series,\n          e = d.tooltipOptions,\n          f = d.options.dataGrouping,\n          k = e.xDateFormat,\n          g,\n          l = d.xAxis,\n          n,\n          m = e[(a.isFooter ? \"footer\" : \"header\") + \"Format\"];\n      l && \"datetime\" === l.options.type && f && y(c.key) && (n = d.currentDataGrouping, f = f.dateTimeLabelFormats || C.dateTimeLabelFormats, n ? (e = f[n.unitName], 1 === n.count ? k = e[0] : (k = e[1], g = e[2])) : !k && f && (k = this.getXDateFormat(c, e, l)), k = b.dateFormat(k, c.key), g && (k += b.dateFormat(g, c.key + n.totalRange - 1)), d.chart.styledMode && (m = this.styledModeFormat(m)), a.text = v(m, {\n        point: u(c.point, {\n          key: k\n        }),\n        series: d\n      }, b), a.preventDefault());\n    });\n    B(p, \"destroy\", d.destroyGroupedData);\n    B(p, \"afterSetOptions\", function (a) {\n      a = a.options;\n      var b = this.type,\n          c = this.chart.options.plotOptions,\n          d = g[b].dataGrouping,\n          e = this.useCommonDataGrouping && C;\n      if (F[b] || e) d || (d = q(C, F[b])), a.dataGrouping = q(e, d, c.series && c.series.dataGrouping, c[b].dataGrouping, this.userOptions.dataGrouping);\n    });\n    B(m, \"afterSetScale\", function () {\n      this.series.forEach(function (a) {\n        a.hasProcessed = !1;\n      });\n    });\n\n    m.prototype.getGroupPixelWidth = function () {\n      var a = this.series,\n          b = a.length,\n          c,\n          d = 0,\n          e = !1,\n          g;\n\n      for (c = b; c--;) {\n        (g = a[c].options.dataGrouping) && (d = Math.max(d, f(g.groupPixelWidth, C.groupPixelWidth)));\n      }\n\n      for (c = b; c--;) {\n        (g = a[c].options.dataGrouping) && a[c].hasProcessed && (b = (a[c].processedXData || a[c].data).length, a[c].groupPixelWidth || b > this.chart.plotSizeX / d || b && g.forced) && (e = !0);\n      }\n\n      return e ? d : 0;\n    };\n\n    m.prototype.setDataGrouping = function (a, b) {\n      var c;\n      b = f(b, !0);\n      a || (a = {\n        forced: !1,\n        units: null\n      });\n      if (this instanceof m) for (c = this.series.length; c--;) {\n        this.series[c].update({\n          dataGrouping: a\n        }, !1);\n      } else this.chart.options.series.forEach(function (b) {\n        b.dataGrouping = a;\n      }, !1);\n      this.ordinalSlope = null;\n      b && this.chart.redraw();\n    };\n\n    return a.dataGrouping = n;\n  })(H);\n\n  (function (a) {\n    var B = a.Point,\n        A = a.seriesType,\n        G = a.seriesTypes;\n    A(\"ohlc\", \"column\", {\n      lineWidth: 1,\n      tooltip: {\n        pointFormat: \"<span style=\\\"color:{point.color}\\\">\\u25CF</span> <b> {series.name}</b><br/>Open: {point.open}<br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>\"\n      },\n      threshold: null,\n      states: {\n        hover: {\n          lineWidth: 3\n        }\n      },\n      stickyTracking: !0\n    }, {\n      directTouch: !1,\n      pointArrayMap: [\"open\", \"high\", \"low\", \"close\"],\n      toYData: function toYData(a) {\n        return [a.open, a.high, a.low, a.close];\n      },\n      pointValKey: \"close\",\n      pointAttrToOptions: {\n        stroke: \"color\",\n        \"stroke-width\": \"lineWidth\"\n      },\n      init: function init() {\n        G.column.prototype.init.apply(this, arguments);\n        this.options.stacking = !1;\n      },\n      pointAttribs: function pointAttribs(a, g) {\n        g = G.column.prototype.pointAttribs.call(this, a, g);\n        var m = this.options;\n        delete g.fill;\n        !a.options.color && m.upColor && a.open < a.close && (g.stroke = m.upColor);\n        return g;\n      },\n      translate: function translate() {\n        var a = this,\n            g = a.yAxis,\n            t = !!a.modifyValue,\n            u = [\"plotOpen\", \"plotHigh\", \"plotLow\", \"plotClose\", \"yBottom\"];\n        G.column.prototype.translate.apply(a);\n        a.points.forEach(function (m) {\n          [m.open, m.high, m.low, m.close, m.low].forEach(function (v, q) {\n            null !== v && (t && (v = a.modifyValue(v)), m[u[q]] = g.toPixels(v, !0));\n          });\n          m.tooltipPos[1] = m.plotHigh + g.pos - a.chart.plotTop;\n        });\n      },\n      drawPoints: function drawPoints() {\n        var a = this,\n            g = a.chart;\n        a.points.forEach(function (m) {\n          var t,\n              v,\n              y,\n              q,\n              f = m.graphic,\n              e,\n              p = !f;\n          void 0 !== m.plotY && (f || (m.graphic = f = g.renderer.path().add(a.group)), g.styledMode || f.attr(a.pointAttribs(m, m.selected && \"select\")), v = f.strokeWidth() % 2 / 2, e = Math.round(m.plotX) - v, y = Math.round(m.shapeArgs.width / 2), q = [\"M\", e, Math.round(m.yBottom), \"L\", e, Math.round(m.plotHigh)], null !== m.open && (t = Math.round(m.plotOpen) + v, q.push(\"M\", e, t, \"L\", e - y, t)), null !== m.close && (t = Math.round(m.plotClose) + v, q.push(\"M\", e, t, \"L\", e + y, t)), f[p ? \"attr\" : \"animate\"]({\n            d: q\n          }).addClass(m.getClassName(), !0));\n        });\n      },\n      animate: null\n    }, {\n      getClassName: function getClassName() {\n        return B.prototype.getClassName.call(this) + (this.open < this.close ? \" highcharts-point-up\" : \" highcharts-point-down\");\n      }\n    });\n  })(H);\n\n  (function (a) {\n    var B = a.defaultPlotOptions,\n        A = a.merge,\n        G = a.seriesType,\n        m = a.seriesTypes;\n    G(\"candlestick\", \"ohlc\", A(B.column, {\n      states: {\n        hover: {\n          lineWidth: 2\n        }\n      },\n      tooltip: B.ohlc.tooltip,\n      threshold: null,\n      lineColor: \"#000000\",\n      lineWidth: 1,\n      upColor: \"#ffffff\",\n      stickyTracking: !0\n    }), {\n      pointAttribs: function pointAttribs(a, t) {\n        var g = m.column.prototype.pointAttribs.call(this, a, t),\n            v = this.options,\n            y = a.open < a.close,\n            q = v.lineColor || this.color;\n        g[\"stroke-width\"] = v.lineWidth;\n        g.fill = a.options.color || (y ? v.upColor || this.color : this.color);\n        g.stroke = a.lineColor || (y ? v.upLineColor || q : q);\n        t && (a = v.states[t], g.fill = a.color || g.fill, g.stroke = a.lineColor || g.stroke, g[\"stroke-width\"] = a.lineWidth || g[\"stroke-width\"]);\n        return g;\n      },\n      drawPoints: function drawPoints() {\n        var a = this,\n            m = a.chart,\n            u = a.yAxis.reversed;\n        a.points.forEach(function (g) {\n          var t = g.graphic,\n              q,\n              f,\n              e,\n              p,\n              r,\n              b,\n              l,\n              n = !t;\n          void 0 !== g.plotY && (t || (g.graphic = t = m.renderer.path().add(a.group)), a.chart.styledMode || t.attr(a.pointAttribs(g, g.selected && \"select\")).shadow(a.options.shadow), r = t.strokeWidth() % 2 / 2, b = Math.round(g.plotX) - r, q = g.plotOpen, f = g.plotClose, e = Math.min(q, f), q = Math.max(q, f), l = Math.round(g.shapeArgs.width / 2), f = u ? q !== g.yBottom : Math.round(e) !== Math.round(g.plotHigh), p = u ? Math.round(e) !== Math.round(g.plotHigh) : q !== g.yBottom, e = Math.round(e) + r, q = Math.round(q) + r, r = [], r.push(\"M\", b - l, q, \"L\", b - l, e, \"L\", b + l, e, \"L\", b + l, q, \"Z\", \"M\", b, e, \"L\", b, f ? Math.round(u ? g.yBottom : g.plotHigh) : e, \"M\", b, q, \"L\", b, p ? Math.round(u ? g.plotHigh : g.yBottom) : q), t[n ? \"attr\" : \"animate\"]({\n            d: r\n          }).addClass(g.getClassName(), !0));\n        });\n      }\n    });\n  })(H);\n\n  da = function (a) {\n    var B = a.defined,\n        A = a.seriesTypes,\n        G = a.stableSort;\n    return {\n      getPlotBox: function getPlotBox() {\n        return a.Series.prototype.getPlotBox.call(this.options.onSeries && this.chart.get(this.options.onSeries) || this);\n      },\n      translate: function translate() {\n        A.column.prototype.translate.apply(this);\n        var a = this,\n            g = a.options,\n            t = a.chart,\n            u = a.points,\n            v = u.length - 1,\n            y,\n            q = g.onSeries,\n            q = q && t.get(q),\n            g = g.onKey || \"y\",\n            f = q && q.options.step,\n            e = q && q.points,\n            p = e && e.length,\n            r = t.inverted,\n            b = a.xAxis,\n            l = a.yAxis,\n            n = 0,\n            d,\n            w,\n            E,\n            C;\n        if (q && q.visible && p) for (n = (q.pointXOffset || 0) + (q.barW || 0) / 2, t = q.currentDataGrouping, w = e[p - 1].x + (t ? t.totalRange : 0), G(u, function (a, b) {\n          return a.x - b.x;\n        }), g = \"plot\" + g[0].toUpperCase() + g.substr(1); p-- && u[v] && !(d = e[p], t = u[v], t.y = d.y, d.x <= t.x && void 0 !== d[g] && (t.x <= w && (t.plotY = d[g], d.x < t.x && !f && (E = e[p + 1]) && void 0 !== E[g] && (C = (t.x - d.x) / (E.x - d.x), t.plotY += C * (E[g] - d[g]), t.y += C * (E.y - d.y))), v--, p++, 0 > v));) {\n          ;\n        }\n        u.forEach(function (d, c) {\n          var e;\n          d.plotX += n;\n          if (void 0 === d.plotY || r) 0 <= d.plotX && d.plotX <= b.len ? r ? (d.plotY = b.translate(d.x, 0, 1, 0, 1), d.plotX = B(d.y) ? l.translate(d.y, 0, 0, 0, 1) : 0) : d.plotY = (b.opposite ? 0 : a.yAxis.len) + b.offset : d.shapeArgs = {};\n          (y = u[c - 1]) && y.plotX === d.plotX && (void 0 === y.stackIndex && (y.stackIndex = 0), e = y.stackIndex + 1);\n          d.stackIndex = e;\n        });\n        this.onSeries = q;\n      }\n    };\n  }(H);\n\n  (function (a, B) {\n    function A(a) {\n      e[a + \"pin\"] = function (f, b, g, n, d) {\n        var l = d && d.anchorX;\n        d = d && d.anchorY;\n        \"circle\" === a && n > g && (f -= Math.round((n - g) / 2), g = n);\n        f = e[a](f, b, g, n);\n        l && d && (f.push(\"M\", \"circle\" === a ? f[1] - f[4] : f[1] + f[4] / 2, b > d ? b : b + n, \"L\", l, d), f = f.concat(e.circle(l - 1, d - 1, 2, 2)));\n        return f;\n      };\n    }\n\n    var G = a.addEvent,\n        m = a.merge,\n        g = a.noop,\n        t = a.defined,\n        u = a.Renderer,\n        v = a.Series,\n        y = a.seriesType,\n        q = a.TrackerMixin,\n        f = a.VMLRenderer,\n        e = a.SVGRenderer.prototype.symbols;\n    y(\"flags\", \"column\", {\n      pointRange: 0,\n      allowOverlapX: !1,\n      shape: \"flag\",\n      stackDistance: 12,\n      textAlign: \"center\",\n      tooltip: {\n        pointFormat: \"{point.text}\\x3cbr/\\x3e\"\n      },\n      threshold: null,\n      y: -30,\n      fillColor: \"#ffffff\",\n      lineWidth: 1,\n      states: {\n        hover: {\n          lineColor: \"#000000\",\n          fillColor: \"#ccd6eb\"\n        }\n      },\n      style: {\n        fontSize: \"11px\",\n        fontWeight: \"bold\"\n      }\n    }, {\n      sorted: !1,\n      noSharedTooltip: !0,\n      allowDG: !1,\n      takeOrdinalPosition: !1,\n      trackerGroups: [\"markerGroup\"],\n      forceCrop: !0,\n      init: v.prototype.init,\n      pointAttribs: function pointAttribs(a, e) {\n        var b = this.options,\n            f = a && a.color || this.color,\n            g = b.lineColor,\n            d = a && a.lineWidth;\n        a = a && a.fillColor || b.fillColor;\n        e && (a = b.states[e].fillColor, g = b.states[e].lineColor, d = b.states[e].lineWidth);\n        return {\n          fill: a || f,\n          stroke: g || f,\n          \"stroke-width\": d || b.lineWidth || 0\n        };\n      },\n      translate: B.translate,\n      getPlotBox: B.getPlotBox,\n      drawPoints: function drawPoints() {\n        var e = this.points,\n            f = this.chart,\n            b = f.renderer,\n            g,\n            n,\n            d = f.inverted,\n            q = this.options,\n            u = q.y,\n            v,\n            y,\n            c,\n            k,\n            x,\n            D,\n            h = this.yAxis,\n            z = {},\n            A = [];\n\n        for (y = e.length; y--;) {\n          c = e[y], D = (d ? c.plotY : c.plotX) > this.xAxis.len, g = c.plotX, k = c.stackIndex, v = c.options.shape || q.shape, n = c.plotY, void 0 !== n && (n = c.plotY + u - (void 0 !== k && k * q.stackDistance)), c.anchorX = k ? void 0 : c.plotX, x = k ? void 0 : c.plotY, k = c.graphic, void 0 !== n && 0 <= g && !D ? (k || (k = c.graphic = b.label(\"\", null, null, v, null, null, q.useHTML), f.styledMode || k.attr(this.pointAttribs(c)).css(m(q.style, c.style)), k.attr({\n            align: \"flag\" === v ? \"left\" : \"center\",\n            width: q.width,\n            height: q.height,\n            \"text-align\": q.textAlign\n          }).addClass(\"highcharts-point\").add(this.markerGroup), c.graphic.div && (c.graphic.div.point = c), f.styledMode || k.shadow(q.shadow), k.isNew = !0), 0 < g && (g -= k.strokeWidth() % 2), v = {\n            y: n,\n            anchorY: x\n          }, q.allowOverlapX && (v.x = g, v.anchorX = c.anchorX), k.attr({\n            text: c.options.title || q.title || \"A\"\n          })[k.isNew ? \"attr\" : \"animate\"](v), q.allowOverlapX || (z[c.plotX] ? z[c.plotX].size = Math.max(z[c.plotX].size, k.width) : z[c.plotX] = {\n            align: 0,\n            size: k.width,\n            target: g,\n            anchorX: g\n          }), c.tooltipPos = [g, n + h.pos - f.plotTop]) : k && (c.graphic = k.destroy());\n        }\n\n        q.allowOverlapX || (a.objectEach(z, function (a) {\n          a.plotX = a.anchorX;\n          A.push(a);\n        }), a.distribute(A, d ? h.len : this.xAxis.len, 100), e.forEach(function (a) {\n          var b = a.graphic && z[a.plotX];\n          b && (a.graphic[a.graphic.isNew ? \"attr\" : \"animate\"]({\n            x: b.pos,\n            anchorX: a.anchorX\n          }), t(b.pos) ? a.graphic.isNew = !1 : (a.graphic.attr({\n            x: -9999,\n            anchorX: -9999\n          }), a.graphic.isNew = !0));\n        }));\n        q.useHTML && a.wrap(this.markerGroup, \"on\", function (b) {\n          return a.SVGElement.prototype.on.apply(b.apply(this, [].slice.call(arguments, 1)), [].slice.call(arguments, 1));\n        });\n      },\n      drawTracker: function drawTracker() {\n        var a = this.points;\n        q.drawTrackerPoint.apply(this);\n        a.forEach(function (e) {\n          var b = e.graphic;\n          b && G(b.element, \"mouseover\", function () {\n            0 < e.stackIndex && !e.raised && (e._y = b.y, b.attr({\n              y: e._y - 8\n            }), e.raised = !0);\n            a.forEach(function (a) {\n              a !== e && a.raised && a.graphic && (a.graphic.attr({\n                y: a._y\n              }), a.raised = !1);\n            });\n          });\n        });\n      },\n      animate: function animate(a) {\n        a ? this.setClip() : this.animate = null;\n      },\n      setClip: function setClip() {\n        v.prototype.setClip.apply(this, arguments);\n        !1 !== this.options.clip && this.sharedClipKey && this.markerGroup.clip(this.chart[this.sharedClipKey]);\n      },\n      buildKDTree: g,\n      invertGroups: g\n    });\n\n    e.flag = function (a, f, b, g, n) {\n      var d = n && n.anchorX || a;\n      n = n && n.anchorY || f;\n      return e.circle(d - 1, n - 1, 2, 2).concat([\"M\", d, n, \"L\", a, f + g, a, f, a + b, f, a + b, f + g, a, f + g, \"Z\"]);\n    };\n\n    A(\"circle\");\n    A(\"square\");\n    u === f && [\"flag\", \"circlepin\", \"squarepin\"].forEach(function (a) {\n      f.prototype.symbols[a] = e[a];\n    });\n  })(H, da);\n\n  (function (a) {\n    function B(a, e, f) {\n      this.init(a, e, f);\n    }\n\n    var A = a.addEvent,\n        G = a.Axis,\n        m = a.correctFloat,\n        g = a.defaultOptions,\n        t = a.defined,\n        u = a.destroyObjectProperties,\n        v = a.fireEvent,\n        y = a.hasTouch,\n        q = a.merge,\n        f = a.pick,\n        e = a.removeEvent,\n        p,\n        r = {\n      height: a.isTouchDevice ? 20 : 14,\n      barBorderRadius: 0,\n      buttonBorderRadius: 0,\n      liveRedraw: void 0,\n      margin: 10,\n      minWidth: 6,\n      step: .2,\n      zIndex: 3,\n      barBackgroundColor: \"#cccccc\",\n      barBorderWidth: 1,\n      barBorderColor: \"#cccccc\",\n      buttonArrowColor: \"#333333\",\n      buttonBackgroundColor: \"#e6e6e6\",\n      buttonBorderColor: \"#cccccc\",\n      buttonBorderWidth: 1,\n      rifleColor: \"#333333\",\n      trackBackgroundColor: \"#f2f2f2\",\n      trackBorderColor: \"#f2f2f2\",\n      trackBorderWidth: 1\n    };\n    g.scrollbar = q(!0, r, g.scrollbar);\n\n    a.swapXY = p = function p(a, e) {\n      var b = a.length,\n          d;\n      if (e) for (e = 0; e < b; e += 3) {\n        d = a[e + 1], a[e + 1] = a[e + 2], a[e + 2] = d;\n      }\n      return a;\n    };\n\n    B.prototype = {\n      init: function init(a, e, g) {\n        this.scrollbarButtons = [];\n        this.renderer = a;\n        this.userOptions = e;\n        this.options = q(r, e);\n        this.chart = g;\n        this.size = f(this.options.size, this.options.height);\n        e.enabled && (this.render(), this.initEvents(), this.addEvents());\n      },\n      render: function render() {\n        var a = this.renderer,\n            e = this.options,\n            f = this.size,\n            d = this.chart.styledMode,\n            g;\n        this.group = g = a.g(\"scrollbar\").attr({\n          zIndex: e.zIndex,\n          translateY: -99999\n        }).add();\n        this.track = a.rect().addClass(\"highcharts-scrollbar-track\").attr({\n          x: 0,\n          r: e.trackBorderRadius || 0,\n          height: f,\n          width: f\n        }).add(g);\n        d || this.track.attr({\n          fill: e.trackBackgroundColor,\n          stroke: e.trackBorderColor,\n          \"stroke-width\": e.trackBorderWidth\n        });\n        this.trackBorderWidth = this.track.strokeWidth();\n        this.track.attr({\n          y: -this.trackBorderWidth % 2 / 2\n        });\n        this.scrollbarGroup = a.g().add(g);\n        this.scrollbar = a.rect().addClass(\"highcharts-scrollbar-thumb\").attr({\n          height: f,\n          width: f,\n          r: e.barBorderRadius || 0\n        }).add(this.scrollbarGroup);\n        this.scrollbarRifles = a.path(p([\"M\", -3, f / 4, \"L\", -3, 2 * f / 3, \"M\", 0, f / 4, \"L\", 0, 2 * f / 3, \"M\", 3, f / 4, \"L\", 3, 2 * f / 3], e.vertical)).addClass(\"highcharts-scrollbar-rifles\").add(this.scrollbarGroup);\n        d || (this.scrollbar.attr({\n          fill: e.barBackgroundColor,\n          stroke: e.barBorderColor,\n          \"stroke-width\": e.barBorderWidth\n        }), this.scrollbarRifles.attr({\n          stroke: e.rifleColor,\n          \"stroke-width\": 1\n        }));\n        this.scrollbarStrokeWidth = this.scrollbar.strokeWidth();\n        this.scrollbarGroup.translate(-this.scrollbarStrokeWidth % 2 / 2, -this.scrollbarStrokeWidth % 2 / 2);\n        this.drawScrollbarButton(0);\n        this.drawScrollbarButton(1);\n      },\n      position: function position(a, e, f, d) {\n        var b = this.options.vertical,\n            g = 0,\n            l = this.rendered ? \"animate\" : \"attr\";\n        this.x = a;\n        this.y = e + this.trackBorderWidth;\n        this.width = f;\n        this.xOffset = this.height = d;\n        this.yOffset = g;\n        b ? (this.width = this.yOffset = f = g = this.size, this.xOffset = e = 0, this.barWidth = d - 2 * f, this.x = a += this.options.margin) : (this.height = this.xOffset = d = e = this.size, this.barWidth = f - 2 * d, this.y += this.options.margin);\n        this.group[l]({\n          translateX: a,\n          translateY: this.y\n        });\n        this.track[l]({\n          width: f,\n          height: d\n        });\n        this.scrollbarButtons[1][l]({\n          translateX: b ? 0 : f - e,\n          translateY: b ? d - g : 0\n        });\n      },\n      drawScrollbarButton: function drawScrollbarButton(a) {\n        var b = this.renderer,\n            e = this.scrollbarButtons,\n            d = this.options,\n            f = this.size,\n            g;\n        g = b.g().add(this.group);\n        e.push(g);\n        g = b.rect().addClass(\"highcharts-scrollbar-button\").add(g);\n        this.chart.styledMode || g.attr({\n          stroke: d.buttonBorderColor,\n          \"stroke-width\": d.buttonBorderWidth,\n          fill: d.buttonBackgroundColor\n        });\n        g.attr(g.crisp({\n          x: -.5,\n          y: -.5,\n          width: f + 1,\n          height: f + 1,\n          r: d.buttonBorderRadius\n        }, g.strokeWidth()));\n        g = b.path(p([\"M\", f / 2 + (a ? -1 : 1), f / 2 - 3, \"L\", f / 2 + (a ? -1 : 1), f / 2 + 3, \"L\", f / 2 + (a ? 2 : -2), f / 2], d.vertical)).addClass(\"highcharts-scrollbar-arrow\").add(e[a]);\n        this.chart.styledMode || g.attr({\n          fill: d.buttonArrowColor\n        });\n      },\n      setRange: function setRange(a, e) {\n        var b = this.options,\n            d = b.vertical,\n            f = b.minWidth,\n            g = this.barWidth,\n            l,\n            p,\n            c = !this.rendered || this.hasDragged || this.chart.navigator && this.chart.navigator.hasDragged ? \"attr\" : \"animate\";\n        t(g) && (a = Math.max(a, 0), l = Math.ceil(g * a), this.calculatedWidth = p = m(g * Math.min(e, 1) - l), p < f && (l = (g - f + p) * a, p = f), f = Math.floor(l + this.xOffset + this.yOffset), g = p / 2 - .5, this.from = a, this.to = e, d ? (this.scrollbarGroup[c]({\n          translateY: f\n        }), this.scrollbar[c]({\n          height: p\n        }), this.scrollbarRifles[c]({\n          translateY: g\n        }), this.scrollbarTop = f, this.scrollbarLeft = 0) : (this.scrollbarGroup[c]({\n          translateX: f\n        }), this.scrollbar[c]({\n          width: p\n        }), this.scrollbarRifles[c]({\n          translateX: g\n        }), this.scrollbarLeft = f, this.scrollbarTop = 0), 12 >= p ? this.scrollbarRifles.hide() : this.scrollbarRifles.show(!0), !1 === b.showFull && (0 >= a && 1 <= e ? this.group.hide() : this.group.show()), this.rendered = !0);\n      },\n      initEvents: function initEvents() {\n        var a = this;\n\n        a.mouseMoveHandler = function (b) {\n          var e = a.chart.pointer.normalize(b),\n              d = a.options.vertical ? \"chartY\" : \"chartX\",\n              f = a.initPositions;\n          !a.grabbedCenter || b.touches && 0 === b.touches[0][d] || (e = a.cursorToScrollbarPosition(e)[d], d = a[d], d = e - d, a.hasDragged = !0, a.updatePosition(f[0] + d, f[1] + d), a.hasDragged && v(a, \"changed\", {\n            from: a.from,\n            to: a.to,\n            trigger: \"scrollbar\",\n            DOMType: b.type,\n            DOMEvent: b\n          }));\n        };\n\n        a.mouseUpHandler = function (b) {\n          a.hasDragged && v(a, \"changed\", {\n            from: a.from,\n            to: a.to,\n            trigger: \"scrollbar\",\n            DOMType: b.type,\n            DOMEvent: b\n          });\n          a.grabbedCenter = a.hasDragged = a.chartX = a.chartY = null;\n        };\n\n        a.mouseDownHandler = function (b) {\n          b = a.chart.pointer.normalize(b);\n          b = a.cursorToScrollbarPosition(b);\n          a.chartX = b.chartX;\n          a.chartY = b.chartY;\n          a.initPositions = [a.from, a.to];\n          a.grabbedCenter = !0;\n        };\n\n        a.buttonToMinClick = function (b) {\n          var e = m(a.to - a.from) * a.options.step;\n          a.updatePosition(m(a.from - e), m(a.to - e));\n          v(a, \"changed\", {\n            from: a.from,\n            to: a.to,\n            trigger: \"scrollbar\",\n            DOMEvent: b\n          });\n        };\n\n        a.buttonToMaxClick = function (b) {\n          var e = (a.to - a.from) * a.options.step;\n          a.updatePosition(a.from + e, a.to + e);\n          v(a, \"changed\", {\n            from: a.from,\n            to: a.to,\n            trigger: \"scrollbar\",\n            DOMEvent: b\n          });\n        };\n\n        a.trackClick = function (b) {\n          var e = a.chart.pointer.normalize(b),\n              d = a.to - a.from,\n              f = a.y + a.scrollbarTop,\n              g = a.x + a.scrollbarLeft;\n          a.options.vertical && e.chartY > f || !a.options.vertical && e.chartX > g ? a.updatePosition(a.from + d, a.to + d) : a.updatePosition(a.from - d, a.to - d);\n          v(a, \"changed\", {\n            from: a.from,\n            to: a.to,\n            trigger: \"scrollbar\",\n            DOMEvent: b\n          });\n        };\n      },\n      cursorToScrollbarPosition: function cursorToScrollbarPosition(a) {\n        var b = this.options,\n            b = b.minWidth > this.calculatedWidth ? b.minWidth : 0;\n        return {\n          chartX: (a.chartX - this.x - this.xOffset) / (this.barWidth - b),\n          chartY: (a.chartY - this.y - this.yOffset) / (this.barWidth - b)\n        };\n      },\n      updatePosition: function updatePosition(a, e) {\n        1 < e && (a = m(1 - m(e - a)), e = 1);\n        0 > a && (e = m(e - a), a = 0);\n        this.from = a;\n        this.to = e;\n      },\n      update: function update(a) {\n        this.destroy();\n        this.init(this.chart.renderer, q(!0, this.options, a), this.chart);\n      },\n      addEvents: function addEvents() {\n        var a = this.options.inverted ? [1, 0] : [0, 1],\n            e = this.scrollbarButtons,\n            f = this.scrollbarGroup.element,\n            d = this.mouseDownHandler,\n            g = this.mouseMoveHandler,\n            m = this.mouseUpHandler,\n            a = [[e[a[0]].element, \"click\", this.buttonToMinClick], [e[a[1]].element, \"click\", this.buttonToMaxClick], [this.track.element, \"click\", this.trackClick], [f, \"mousedown\", d], [f.ownerDocument, \"mousemove\", g], [f.ownerDocument, \"mouseup\", m]];\n        y && a.push([f, \"touchstart\", d], [f.ownerDocument, \"touchmove\", g], [f.ownerDocument, \"touchend\", m]);\n        a.forEach(function (a) {\n          A.apply(null, a);\n        });\n        this._events = a;\n      },\n      removeEvents: function removeEvents() {\n        this._events.forEach(function (a) {\n          e.apply(null, a);\n        });\n\n        this._events.length = 0;\n      },\n      destroy: function destroy() {\n        var a = this.chart.scroller;\n        this.removeEvents();\n        [\"track\", \"scrollbarRifles\", \"scrollbar\", \"scrollbarGroup\", \"group\"].forEach(function (a) {\n          this[a] && this[a].destroy && (this[a] = this[a].destroy());\n        }, this);\n        a && this === a.scrollbar && (a.scrollbar = null, u(a.scrollbarButtons));\n      }\n    };\n    A(G, \"afterInit\", function () {\n      var b = this;\n      b.options && b.options.scrollbar && b.options.scrollbar.enabled && (b.options.scrollbar.vertical = !b.horiz, b.options.startOnTick = b.options.endOnTick = !1, b.scrollbar = new B(b.chart.renderer, b.options.scrollbar, b.chart), A(b.scrollbar, \"changed\", function (e) {\n        var g = Math.min(f(b.options.min, b.min), b.min, b.dataMin),\n            d = Math.max(f(b.options.max, b.max), b.max, b.dataMax) - g,\n            l;\n        b.horiz && !b.reversed || !b.horiz && b.reversed ? (l = g + d * this.to, g += d * this.from) : (l = g + d * (1 - this.from), g += d * (1 - this.to));\n        f(this.options.liveRedraw, a.svg && !a.isTouchDevice && !this.chart.isBoosting) || \"mouseup\" === e.DOMType || !t(e.DOMType) ? b.setExtremes(g, l, !0, \"mousemove\" !== e.DOMType, e) : this.setRange(this.from, this.to);\n      }));\n    });\n    A(G, \"afterRender\", function () {\n      var a = Math.min(f(this.options.min, this.min), this.min, f(this.dataMin, this.min)),\n          e = Math.max(f(this.options.max, this.max), this.max, f(this.dataMax, this.max)),\n          g = this.scrollbar,\n          d = this.titleOffset || 0;\n\n      if (g) {\n        this.horiz ? (g.position(this.left, this.top + this.height + 2 + this.chart.scrollbarsOffsets[1] + (this.opposite ? 0 : d + this.axisTitleMargin + this.offset), this.width, this.height), d = 1) : (g.position(this.left + this.width + 2 + this.chart.scrollbarsOffsets[0] + (this.opposite ? d + this.axisTitleMargin + this.offset : 0), this.top, this.width, this.height), d = 0);\n        if (!this.opposite && !this.horiz || this.opposite && this.horiz) this.chart.scrollbarsOffsets[d] += this.scrollbar.size + this.scrollbar.options.margin;\n        isNaN(a) || isNaN(e) || !t(this.min) || !t(this.max) ? g.setRange(0, 0) : (d = (this.min - a) / (e - a), a = (this.max - a) / (e - a), this.horiz && !this.reversed || !this.horiz && this.reversed ? g.setRange(d, a) : g.setRange(1 - a, 1 - d));\n      }\n    });\n    A(G, \"afterGetOffset\", function () {\n      var a = this.horiz ? 2 : 1,\n          e = this.scrollbar;\n      e && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[a] += e.size + e.options.margin);\n    });\n    a.Scrollbar = B;\n  })(H);\n\n  (function (a) {\n    function B(a) {\n      this.init(a);\n    }\n\n    var A = a.addEvent,\n        G = a.Axis,\n        m = a.Chart,\n        g = a.color,\n        t = a.defaultOptions,\n        u = a.defined,\n        v = a.destroyObjectProperties,\n        y = a.erase,\n        q = a.extend,\n        f = a.hasTouch,\n        e = a.isArray,\n        p = a.isNumber,\n        r = a.isTouchDevice,\n        b = a.merge,\n        l = a.pick,\n        n = a.removeEvent,\n        d = a.Scrollbar,\n        w = a.Series,\n        E = a.seriesTypes,\n        C = [].concat(a.defaultDataGroupingUnits),\n        F = function F(a) {\n      var c = [].filter.call(arguments, p);\n      if (c.length) return Math[a].apply(0, c);\n    };\n\n    C[4] = [\"day\", [1, 2, 3, 4]];\n    C[5] = [\"week\", [1, 2, 3]];\n    E = void 0 === E.areaspline ? \"line\" : \"areaspline\";\n    q(t, {\n      navigator: {\n        height: 40,\n        margin: 25,\n        maskInside: !0,\n        handles: {\n          width: 7,\n          height: 15,\n          symbols: [\"navigator-handle\", \"navigator-handle\"],\n          enabled: !0,\n          lineWidth: 1,\n          backgroundColor: \"#f2f2f2\",\n          borderColor: \"#999999\"\n        },\n        maskFill: g(\"#6685c2\").setOpacity(.3).get(),\n        outlineColor: \"#cccccc\",\n        outlineWidth: 1,\n        series: {\n          type: E,\n          fillOpacity: .05,\n          lineWidth: 1,\n          compare: null,\n          dataGrouping: {\n            approximation: \"average\",\n            enabled: !0,\n            groupPixelWidth: 2,\n            smoothed: !0,\n            units: C\n          },\n          dataLabels: {\n            enabled: !1,\n            zIndex: 2\n          },\n          id: \"highcharts-navigator-series\",\n          className: \"highcharts-navigator-series\",\n          lineColor: null,\n          marker: {\n            enabled: !1\n          },\n          pointRange: 0,\n          threshold: null\n        },\n        xAxis: {\n          overscroll: 0,\n          className: \"highcharts-navigator-xaxis\",\n          tickLength: 0,\n          lineWidth: 0,\n          gridLineColor: \"#e6e6e6\",\n          gridLineWidth: 1,\n          tickPixelInterval: 200,\n          labels: {\n            align: \"left\",\n            style: {\n              color: \"#999999\"\n            },\n            x: 3,\n            y: -4\n          },\n          crosshair: !1\n        },\n        yAxis: {\n          className: \"highcharts-navigator-yaxis\",\n          gridLineWidth: 0,\n          startOnTick: !1,\n          endOnTick: !1,\n          minPadding: .1,\n          maxPadding: .1,\n          labels: {\n            enabled: !1\n          },\n          crosshair: !1,\n          title: {\n            text: null\n          },\n          tickLength: 0,\n          tickWidth: 0\n        }\n      }\n    });\n\n    a.Renderer.prototype.symbols[\"navigator-handle\"] = function (a, b, d, e, f) {\n      a = f.width / 2;\n      b = Math.round(a / 3) + .5;\n      f = f.height;\n      return [\"M\", -a - 1, .5, \"L\", a, .5, \"L\", a, f + .5, \"L\", -a - 1, f + .5, \"L\", -a - 1, .5, \"M\", -b, 4, \"L\", -b, f - 3, \"M\", b - 1, 4, \"L\", b - 1, f - 3];\n    };\n\n    B.prototype = {\n      drawHandle: function drawHandle(a, b, d, e) {\n        var c = this.navigatorOptions.handles.height;\n        this.handles[b][e](d ? {\n          translateX: Math.round(this.left + this.height / 2),\n          translateY: Math.round(this.top + parseInt(a, 10) + .5 - c)\n        } : {\n          translateX: Math.round(this.left + parseInt(a, 10)),\n          translateY: Math.round(this.top + this.height / 2 - c / 2 - 1)\n        });\n      },\n      drawOutline: function drawOutline(a, b, d, e) {\n        var c = this.navigatorOptions.maskInside,\n            f = this.outline.strokeWidth(),\n            g = f / 2,\n            f = f % 2 / 2,\n            k = this.outlineHeight,\n            l = this.scrollbarHeight,\n            n = this.size,\n            m = this.left - l,\n            p = this.top;\n        d ? (m -= g, d = p + b + f, b = p + a + f, a = [\"M\", m + k, p - l - f, \"L\", m + k, d, \"L\", m, d, \"L\", m, b, \"L\", m + k, b, \"L\", m + k, p + n + l].concat(c ? [\"M\", m + k, d - g, \"L\", m + k, b + g] : [])) : (a += m + l - f, b += m + l - f, p += g, a = [\"M\", m, p, \"L\", a, p, \"L\", a, p + k, \"L\", b, p + k, \"L\", b, p, \"L\", m + n + 2 * l, p].concat(c ? [\"M\", a - g, p, \"L\", b + g, p] : []));\n        this.outline[e]({\n          d: a\n        });\n      },\n      drawMasks: function drawMasks(a, b, d, e) {\n        var c = this.left,\n            f = this.top,\n            g = this.height,\n            k,\n            l,\n            n,\n            m;\n        d ? (n = [c, c, c], m = [f, f + a, f + b], l = [g, g, g], k = [a, b - a, this.size - b]) : (n = [c, c + a, c + b], m = [f, f, f], l = [a, b - a, this.size - b], k = [g, g, g]);\n        this.shades.forEach(function (a, c) {\n          a[e]({\n            x: n[c],\n            y: m[c],\n            width: l[c],\n            height: k[c]\n          });\n        });\n      },\n      renderElements: function renderElements() {\n        var a = this,\n            b = a.navigatorOptions,\n            d = b.maskInside,\n            e = a.chart,\n            f = e.renderer,\n            g,\n            l = {\n          cursor: e.inverted ? \"ns-resize\" : \"ew-resize\"\n        };\n        a.navigatorGroup = g = f.g(\"navigator\").attr({\n          zIndex: 8,\n          visibility: \"hidden\"\n        }).add();\n        [!d, d, !d].forEach(function (c, d) {\n          a.shades[d] = f.rect().addClass(\"highcharts-navigator-mask\" + (1 === d ? \"-inside\" : \"-outside\")).add(g);\n          e.styledMode || a.shades[d].attr({\n            fill: c ? b.maskFill : \"rgba(0,0,0,0)\"\n          }).css(1 === d && l);\n        });\n        a.outline = f.path().addClass(\"highcharts-navigator-outline\").add(g);\n        e.styledMode || a.outline.attr({\n          \"stroke-width\": b.outlineWidth,\n          stroke: b.outlineColor\n        });\n        b.handles.enabled && [0, 1].forEach(function (c) {\n          b.handles.inverted = e.inverted;\n          a.handles[c] = f.symbol(b.handles.symbols[c], -b.handles.width / 2 - 1, 0, b.handles.width, b.handles.height, b.handles);\n          a.handles[c].attr({\n            zIndex: 7 - c\n          }).addClass(\"highcharts-navigator-handle highcharts-navigator-handle-\" + [\"left\", \"right\"][c]).add(g);\n\n          if (!e.styledMode) {\n            var d = b.handles;\n            a.handles[c].attr({\n              fill: d.backgroundColor,\n              stroke: d.borderColor,\n              \"stroke-width\": d.lineWidth\n            }).css(l);\n          }\n        });\n      },\n      update: function update(a) {\n        (this.series || []).forEach(function (a) {\n          a.baseSeries && delete a.baseSeries.navigatorSeries;\n        });\n        this.destroy();\n        b(!0, this.chart.options.navigator, this.options, a);\n        this.init(this.chart);\n      },\n      render: function render(c, b, d, e) {\n        var f = this.chart,\n            g,\n            k,\n            n = this.scrollbarHeight,\n            m,\n            q = this.xAxis;\n        g = q.fake ? f.xAxis[0] : q;\n        var r = this.navigatorEnabled,\n            x,\n            t = this.rendered;\n        k = f.inverted;\n        var w,\n            v = f.xAxis[0].minRange,\n            D = f.xAxis[0].options.maxRange;\n\n        if (!this.hasDragged || u(d)) {\n          if (!p(c) || !p(b)) if (t) d = 0, e = l(q.width, g.width);else return;\n          this.left = l(q.left, f.plotLeft + n + (k ? f.plotWidth : 0));\n          this.size = x = m = l(q.len, (k ? f.plotHeight : f.plotWidth) - 2 * n);\n          f = k ? n : m + 2 * n;\n          d = l(d, q.toPixels(c, !0));\n          e = l(e, q.toPixels(b, !0));\n          p(d) && Infinity !== Math.abs(d) || (d = 0, e = f);\n          c = q.toValue(d, !0);\n          b = q.toValue(e, !0);\n          w = Math.abs(a.correctFloat(b - c));\n          w < v ? this.grabbedLeft ? d = q.toPixels(b - v, !0) : this.grabbedRight && (e = q.toPixels(c + v, !0)) : u(D) && w > D && (this.grabbedLeft ? d = q.toPixels(b - D, !0) : this.grabbedRight && (e = q.toPixels(c + D, !0)));\n          this.zoomedMax = Math.min(Math.max(d, e, 0), x);\n          this.zoomedMin = Math.min(Math.max(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(d, e), 0), x);\n          this.range = this.zoomedMax - this.zoomedMin;\n          x = Math.round(this.zoomedMax);\n          d = Math.round(this.zoomedMin);\n          r && (this.navigatorGroup.attr({\n            visibility: \"visible\"\n          }), t = t && !this.hasDragged ? \"animate\" : \"attr\", this.drawMasks(d, x, k, t), this.drawOutline(d, x, k, t), this.navigatorOptions.handles.enabled && (this.drawHandle(d, 0, k, t), this.drawHandle(x, 1, k, t)));\n          this.scrollbar && (k ? (k = this.top - n, g = this.left - n + (r || !g.opposite ? 0 : (g.titleOffset || 0) + g.axisTitleMargin), n = m + 2 * n) : (k = this.top + (r ? this.height : -n), g = this.left - n), this.scrollbar.position(g, k, f, n), this.scrollbar.setRange(this.zoomedMin / (m || 1), this.zoomedMax / (m || 1)));\n          this.rendered = !0;\n        }\n      },\n      addMouseEvents: function addMouseEvents() {\n        var a = this,\n            b = a.chart,\n            d = b.container,\n            e = [],\n            g,\n            l;\n\n        a.mouseMoveHandler = g = function g(c) {\n          a.onMouseMove(c);\n        };\n\n        a.mouseUpHandler = l = function l(c) {\n          a.onMouseUp(c);\n        };\n\n        e = a.getPartsEvents(\"mousedown\");\n        e.push(A(d, \"mousemove\", g), A(d.ownerDocument, \"mouseup\", l));\n        f && (e.push(A(d, \"touchmove\", g), A(d.ownerDocument, \"touchend\", l)), e.concat(a.getPartsEvents(\"touchstart\")));\n        a.eventsToUnbind = e;\n        a.series && a.series[0] && e.push(A(a.series[0].xAxis, \"foundExtremes\", function () {\n          b.navigator.modifyNavigatorAxisExtremes();\n        }));\n      },\n      getPartsEvents: function getPartsEvents(a) {\n        var c = this,\n            b = [];\n        [\"shades\", \"handles\"].forEach(function (d) {\n          c[d].forEach(function (e, f) {\n            b.push(A(e.element, a, function (a) {\n              c[d + \"Mousedown\"](a, f);\n            }));\n          });\n        });\n        return b;\n      },\n      shadesMousedown: function shadesMousedown(a, b) {\n        a = this.chart.pointer.normalize(a);\n        var c = this.chart,\n            d = this.xAxis,\n            e = this.zoomedMin,\n            f = this.left,\n            g = this.size,\n            k = this.range,\n            l = a.chartX,\n            n,\n            m;\n        c.inverted && (l = a.chartY, f = this.top);\n        1 === b ? (this.grabbedCenter = l, this.fixedWidth = k, this.dragOffset = l - e) : (a = l - f - k / 2, 0 === b ? a = Math.max(0, a) : 2 === b && a + k >= g && (a = g - k, this.reversedExtremes ? (a -= k, m = this.getUnionExtremes().dataMin) : n = this.getUnionExtremes().dataMax), a !== e && (this.fixedWidth = k, b = d.toFixedRange(a, a + k, m, n), u(b.min) && c.xAxis[0].setExtremes(Math.min(b.min, b.max), Math.max(b.min, b.max), !0, null, {\n          trigger: \"navigator\"\n        })));\n      },\n      handlesMousedown: function handlesMousedown(a, b) {\n        this.chart.pointer.normalize(a);\n        a = this.chart;\n        var c = a.xAxis[0],\n            d = this.reversedExtremes;\n        0 === b ? (this.grabbedLeft = !0, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = d ? c.min : c.max) : (this.grabbedRight = !0, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = d ? c.max : c.min);\n        a.fixedRange = null;\n      },\n      onMouseMove: function onMouseMove(b) {\n        var c = this,\n            d = c.chart,\n            e = c.left,\n            f = c.navigatorSize,\n            g = c.range,\n            n = c.dragOffset,\n            m = d.inverted;\n        b.touches && 0 === b.touches[0].pageX || (b = d.pointer.normalize(b), d = b.chartX, m && (e = c.top, d = b.chartY), c.grabbedLeft ? (c.hasDragged = !0, c.render(0, 0, d - e, c.otherHandlePos)) : c.grabbedRight ? (c.hasDragged = !0, c.render(0, 0, c.otherHandlePos, d - e)) : c.grabbedCenter && (c.hasDragged = !0, d < n ? d = n : d > f + n - g && (d = f + n - g), c.render(0, 0, d - n, d - n + g)), c.hasDragged && c.scrollbar && l(c.scrollbar.options.liveRedraw, a.svg && !r && !this.chart.isBoosting) && (b.DOMType = b.type, setTimeout(function () {\n          c.onMouseUp(b);\n        }, 0)));\n      },\n      onMouseUp: function onMouseUp(a) {\n        var b = this.chart,\n            c = this.xAxis,\n            d = this.scrollbar,\n            e,\n            f,\n            g = a.DOMEvent || a;\n        (!this.hasDragged || d && d.hasDragged) && \"scrollbar\" !== a.trigger || (d = this.getUnionExtremes(), this.zoomedMin === this.otherHandlePos ? e = this.fixedExtreme : this.zoomedMax === this.otherHandlePos && (f = this.fixedExtreme), this.zoomedMax === this.size && (f = this.reversedExtremes ? d.dataMin : d.dataMax), 0 === this.zoomedMin && (e = this.reversedExtremes ? d.dataMax : d.dataMin), c = c.toFixedRange(this.zoomedMin, this.zoomedMax, e, f), u(c.min) && b.xAxis[0].setExtremes(Math.min(c.min, c.max), Math.max(c.min, c.max), !0, this.hasDragged ? !1 : null, {\n          trigger: \"navigator\",\n          triggerOp: \"navigator-drag\",\n          DOMEvent: g\n        }));\n        \"mousemove\" !== a.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null);\n      },\n      removeEvents: function removeEvents() {\n        this.eventsToUnbind && (this.eventsToUnbind.forEach(function (a) {\n          a();\n        }), this.eventsToUnbind = void 0);\n        this.removeBaseSeriesEvents();\n      },\n      removeBaseSeriesEvents: function removeBaseSeriesEvents() {\n        var a = this.baseSeries || [];\n        this.navigatorEnabled && a[0] && (!1 !== this.navigatorOptions.adaptToUpdatedData && a.forEach(function (a) {\n          n(a, \"updatedData\", this.updatedDataHandler);\n        }, this), a[0].xAxis && n(a[0].xAxis, \"foundExtremes\", this.modifyBaseAxisExtremes));\n      },\n      init: function init(a) {\n        var c = a.options,\n            e = c.navigator,\n            f = e.enabled,\n            g = c.scrollbar,\n            n = g.enabled,\n            c = f ? e.height : 0,\n            m = n ? g.height : 0;\n        this.handles = [];\n        this.shades = [];\n        this.chart = a;\n        this.setBaseSeries();\n        this.height = c;\n        this.scrollbarHeight = m;\n        this.scrollbarEnabled = n;\n        this.navigatorEnabled = f;\n        this.navigatorOptions = e;\n        this.scrollbarOptions = g;\n        this.outlineHeight = c + m;\n        this.opposite = l(e.opposite, !f && a.inverted);\n        var p = this,\n            f = p.baseSeries,\n            g = a.xAxis.length,\n            n = a.yAxis.length,\n            q = f && f[0] && f[0].xAxis || a.xAxis[0] || {\n          options: {}\n        };\n        a.isDirtyBox = !0;\n        p.navigatorEnabled ? (p.xAxis = new G(a, b({\n          breaks: q.options.breaks,\n          ordinal: q.options.ordinal\n        }, e.xAxis, {\n          id: \"navigator-x-axis\",\n          yAxis: \"navigator-y-axis\",\n          isX: !0,\n          type: \"datetime\",\n          index: g,\n          isInternal: !0,\n          offset: 0,\n          keepOrdinalPadding: !0,\n          startOnTick: !1,\n          endOnTick: !1,\n          minPadding: 0,\n          maxPadding: 0,\n          zoomEnabled: !1\n        }, a.inverted ? {\n          offsets: [m, 0, -m, 0],\n          width: c\n        } : {\n          offsets: [0, -m, 0, m],\n          height: c\n        })), p.yAxis = new G(a, b(e.yAxis, {\n          id: \"navigator-y-axis\",\n          alignTicks: !1,\n          offset: 0,\n          index: n,\n          isInternal: !0,\n          zoomEnabled: !1\n        }, a.inverted ? {\n          width: c\n        } : {\n          height: c\n        })), f || e.series.data ? p.updateNavigatorSeries(!1) : 0 === a.series.length && (p.unbindRedraw = A(a, \"beforeRedraw\", function () {\n          0 < a.series.length && !p.series && (p.setBaseSeries(), p.unbindRedraw());\n        })), p.reversedExtremes = a.inverted && !p.xAxis.reversed || !a.inverted && p.xAxis.reversed, p.renderElements(), p.addMouseEvents()) : p.xAxis = {\n          translate: function translate(b, c) {\n            var d = a.xAxis[0],\n                e = d.getExtremes(),\n                f = d.len - 2 * m,\n                g = F(\"min\", d.options.min, e.dataMin),\n                d = F(\"max\", d.options.max, e.dataMax) - g;\n            return c ? b * d / f + g : f * (b - g) / d;\n          },\n          toPixels: function toPixels(a) {\n            return this.translate(a);\n          },\n          toValue: function toValue(a) {\n            return this.translate(a, !0);\n          },\n          toFixedRange: G.prototype.toFixedRange,\n          fake: !0\n        };\n        a.options.scrollbar.enabled && (a.scrollbar = p.scrollbar = new d(a.renderer, b(a.options.scrollbar, {\n          margin: p.navigatorEnabled ? 0 : 10,\n          vertical: a.inverted\n        }), a), A(p.scrollbar, \"changed\", function (b) {\n          var c = p.size,\n              d = c * this.to,\n              c = c * this.from;\n          p.hasDragged = p.scrollbar.hasDragged;\n          p.render(0, 0, c, d);\n          (a.options.scrollbar.liveRedraw || \"mousemove\" !== b.DOMType && \"touchmove\" !== b.DOMType) && setTimeout(function () {\n            p.onMouseUp(b);\n          });\n        }));\n        p.addBaseSeriesEvents();\n        p.addChartEvents();\n      },\n      getUnionExtremes: function getUnionExtremes(a) {\n        var b = this.chart.xAxis[0],\n            c = this.xAxis,\n            d = c.options,\n            e = b.options,\n            f;\n        a && null === b.dataMin || (f = {\n          dataMin: l(d && d.min, F(\"min\", e.min, b.dataMin, c.dataMin, c.min)),\n          dataMax: l(d && d.max, F(\"max\", e.max, b.dataMax, c.dataMax, c.max))\n        });\n        return f;\n      },\n      setBaseSeries: function setBaseSeries(b, d) {\n        var c = this.chart,\n            e = this.baseSeries = [];\n        b = b || c.options && c.options.navigator.baseSeries || (c.series.length ? a.find(c.series, function (a) {\n          return !a.options.isInternal;\n        }).index : 0);\n        (c.series || []).forEach(function (a, c) {\n          a.options.isInternal || !a.options.showInNavigator && (c !== b && a.options.id !== b || !1 === a.options.showInNavigator) || e.push(a);\n        });\n        this.xAxis && !this.xAxis.fake && this.updateNavigatorSeries(!0, d);\n      },\n      updateNavigatorSeries: function updateNavigatorSeries(c, d) {\n        var f = this,\n            g = f.chart,\n            h = f.baseSeries,\n            k,\n            l,\n            m = f.navigatorOptions.series,\n            p,\n            r = {\n          enableMouseTracking: !1,\n          index: null,\n          linkedTo: null,\n          group: \"nav\",\n          padXAxis: !1,\n          xAxis: \"navigator-x-axis\",\n          yAxis: \"navigator-y-axis\",\n          showInLegend: !1,\n          stacking: !1,\n          isInternal: !0\n        },\n            w = f.series = (f.series || []).filter(function (a) {\n          var b = a.baseSeries;\n          return 0 > h.indexOf(b) ? (b && (n(b, \"updatedData\", f.updatedDataHandler), delete b.navigatorSeries), a.chart && a.destroy(), !1) : !0;\n        });\n        h && h.length && h.forEach(function (a) {\n          var c = a.navigatorSeries,\n              n = q({\n            color: a.color,\n            visible: a.visible\n          }, e(m) ? t.navigator.series : m);\n          c && !1 === f.navigatorOptions.adaptToUpdatedData || (r.name = \"Navigator \" + h.length, k = a.options || {}, p = k.navigatorOptions || {}, l = b(k, r, n, p), n = p.data || n.data, f.hasNavigatorData = f.hasNavigatorData || !!n, l.data = n || k.data && k.data.slice(0), c && c.options ? c.update(l, d) : (a.navigatorSeries = g.initSeries(l), a.navigatorSeries.baseSeries = a, w.push(a.navigatorSeries)));\n        });\n        if (m.data && (!h || !h.length) || e(m)) f.hasNavigatorData = !1, m = a.splat(m), m.forEach(function (a, c) {\n          r.name = \"Navigator \" + (w.length + 1);\n          l = b(t.navigator.series, {\n            color: g.series[c] && !g.series[c].options.isInternal && g.series[c].color || g.options.colors[c] || g.options.colors[0]\n          }, r, a);\n          l.data = a.data;\n          l.data && (f.hasNavigatorData = !0, w.push(g.initSeries(l)));\n        });\n        c && this.addBaseSeriesEvents();\n      },\n      addBaseSeriesEvents: function addBaseSeriesEvents() {\n        var a = this,\n            b = a.baseSeries || [];\n        b[0] && b[0].xAxis && A(b[0].xAxis, \"foundExtremes\", this.modifyBaseAxisExtremes);\n        b.forEach(function (b) {\n          A(b, \"show\", function () {\n            this.navigatorSeries && this.navigatorSeries.setVisible(!0, !1);\n          });\n          A(b, \"hide\", function () {\n            this.navigatorSeries && this.navigatorSeries.setVisible(!1, !1);\n          });\n          !1 !== this.navigatorOptions.adaptToUpdatedData && b.xAxis && A(b, \"updatedData\", this.updatedDataHandler);\n          A(b, \"remove\", function () {\n            this.navigatorSeries && (y(a.series, this.navigatorSeries), u(this.navigatorSeries.options) && this.navigatorSeries.remove(!1), delete this.navigatorSeries);\n          });\n        }, this);\n      },\n      getBaseSeriesMin: function getBaseSeriesMin(a) {\n        return this.baseSeries.reduce(function (a, b) {\n          return Math.min(a, b.xData[0]);\n        }, a);\n      },\n      modifyNavigatorAxisExtremes: function modifyNavigatorAxisExtremes() {\n        var a = this.xAxis,\n            b;\n        a.getExtremes && (!(b = this.getUnionExtremes(!0)) || b.dataMin === a.min && b.dataMax === a.max || (a.min = b.dataMin, a.max = b.dataMax));\n      },\n      modifyBaseAxisExtremes: function modifyBaseAxisExtremes() {\n        var a = this.chart.navigator,\n            b = this.getExtremes(),\n            d = b.dataMin,\n            e = b.dataMax,\n            b = b.max - b.min,\n            f = a.stickToMin,\n            g = a.stickToMax,\n            n = l(this.options.overscroll, 0),\n            m,\n            q,\n            r = a.series && a.series[0],\n            t = !!this.setExtremes;\n        this.eventArgs && \"rangeSelectorButton\" === this.eventArgs.trigger || (f && (q = d, m = q + b), g && (m = e + n, f || (q = Math.max(m - b, a.getBaseSeriesMin(r && r.xData ? r.xData[0] : -Number.MAX_VALUE)))), t && (f || g) && p(q) && (this.min = this.userMin = q, this.max = this.userMax = m));\n        a.stickToMin = a.stickToMax = null;\n      },\n      updatedDataHandler: function updatedDataHandler() {\n        var a = this.chart.navigator,\n            b = this.navigatorSeries,\n            d = a.getBaseSeriesMin(this.xData[0]);\n        a.stickToMax = a.reversedExtremes ? 0 === Math.round(a.zoomedMin) : Math.round(a.zoomedMax) >= Math.round(a.size);\n        a.stickToMin = p(this.xAxis.min) && this.xAxis.min <= d && (!this.chart.fixedRange || !a.stickToMax);\n        b && !a.hasNavigatorData && (b.options.pointStart = this.xData[0], b.setData(this.options.data, !1, null, !1));\n      },\n      addChartEvents: function addChartEvents() {\n        this.eventsToUnbind || (this.eventsToUnbind = []);\n        this.eventsToUnbind.push(A(this.chart, \"redraw\", function () {\n          var a = this.navigator,\n              b = a && (a.baseSeries && a.baseSeries[0] && a.baseSeries[0].xAxis || a.scrollbar && this.xAxis[0]);\n          b && a.render(b.min, b.max);\n        }), A(this.chart, \"getMargins\", function () {\n          var a = this.navigator,\n              b = a.opposite ? \"plotTop\" : \"marginBottom\";\n          this.inverted && (b = a.opposite ? \"marginRight\" : \"plotLeft\");\n          this[b] = (this[b] || 0) + (a.navigatorEnabled || !this.inverted ? a.outlineHeight : 0) + a.navigatorOptions.margin;\n        }));\n      },\n      destroy: function destroy() {\n        this.removeEvents();\n        this.xAxis && (y(this.chart.xAxis, this.xAxis), y(this.chart.axes, this.xAxis));\n        this.yAxis && (y(this.chart.yAxis, this.yAxis), y(this.chart.axes, this.yAxis));\n        (this.series || []).forEach(function (a) {\n          a.destroy && a.destroy();\n        });\n        \"series xAxis yAxis shades outline scrollbarTrack scrollbarRifles scrollbarGroup scrollbar navigatorGroup rendered\".split(\" \").forEach(function (a) {\n          this[a] && this[a].destroy && this[a].destroy();\n          this[a] = null;\n        }, this);\n        [this.handles].forEach(function (a) {\n          v(a);\n        }, this);\n      }\n    };\n    a.Navigator = B;\n    A(G, \"zoom\", function (a) {\n      var b = this.chart.options,\n          c = b.chart.zoomType,\n          d = b.chart.pinchType,\n          e = b.navigator,\n          b = b.rangeSelector;\n      this.isXAxis && (e && e.enabled || b && b.enabled) && (\"y\" === c ? a.zoomed = !1 : (!r && \"xy\" === c || r && \"xy\" === d) && this.options.range && (c = this.previousZoom, u(a.newMin) ? this.previousZoom = [this.min, this.max] : c && (a.newMin = c[0], a.newMax = c[1], delete this.previousZoom)));\n      void 0 !== a.zoomed && a.preventDefault();\n    });\n    A(m, \"beforeShowResetZoom\", function () {\n      var a = this.options,\n          b = a.navigator,\n          d = a.rangeSelector;\n      if ((b && b.enabled || d && d.enabled) && (!r && \"x\" === a.chart.zoomType || r && \"x\" === a.chart.pinchType)) return !1;\n    });\n    A(m, \"beforeRender\", function () {\n      var a = this.options;\n      if (a.navigator.enabled || a.scrollbar.enabled) this.scroller = this.navigator = new B(this);\n    });\n    A(m, \"afterSetChartSize\", function () {\n      var a = this.legend,\n          b = this.navigator,\n          d,\n          e,\n          f,\n          g;\n      b && (e = a && a.options, f = b.xAxis, g = b.yAxis, d = b.scrollbarHeight, this.inverted ? (b.left = b.opposite ? this.chartWidth - d - b.height : this.spacing[3] + d, b.top = this.plotTop + d) : (b.left = this.plotLeft + d, b.top = b.navigatorOptions.top || this.chartHeight - b.height - d - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (e && \"bottom\" === e.verticalAlign && e.enabled && !e.floating ? a.legendHeight + l(e.margin, 10) : 0)), f && g && (this.inverted ? f.options.left = g.options.left = b.left : f.options.top = g.options.top = b.top, f.setAxisSize(), g.setAxisSize()));\n    });\n    A(m, \"update\", function (a) {\n      var c = a.options.navigator || {},\n          d = a.options.scrollbar || {};\n      this.navigator || this.scroller || !c.enabled && !d.enabled || (b(!0, this.options.navigator, c), b(!0, this.options.scrollbar, d), delete a.options.navigator, delete a.options.scrollbar);\n    });\n    A(m, \"afterUpdate\", function () {\n      this.navigator || this.scroller || !this.options.navigator.enabled && !this.options.scrollbar.enabled || (this.scroller = this.navigator = new B(this));\n    });\n    A(m, \"afterAddSeries\", function () {\n      this.navigator && this.navigator.setBaseSeries(null, !1);\n    });\n    A(w, \"afterUpdate\", function () {\n      this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, !1);\n    });\n    m.prototype.callbacks.push(function (a) {\n      var b = a.navigator;\n      b && a.xAxis[0] && (a = a.xAxis[0].getExtremes(), b.render(a.min, a.max));\n    });\n  })(H);\n\n  (function (a) {\n    function B(a) {\n      this.init(a);\n    }\n\n    var A = a.addEvent,\n        G = a.Axis,\n        m = a.Chart,\n        g = a.css,\n        t = a.createElement,\n        u = a.defaultOptions,\n        v = a.defined,\n        y = a.destroyObjectProperties,\n        q = a.discardElement,\n        f = a.extend,\n        e = a.fireEvent,\n        p = a.isNumber,\n        r = a.merge,\n        b = a.pick,\n        l = a.pInt,\n        n = a.splat;\n    f(u, {\n      rangeSelector: {\n        verticalAlign: \"top\",\n        buttonTheme: {\n          width: 28,\n          height: 18,\n          padding: 2,\n          zIndex: 7\n        },\n        floating: !1,\n        x: 0,\n        y: 0,\n        height: void 0,\n        inputPosition: {\n          align: \"right\",\n          x: 0,\n          y: 0\n        },\n        buttonPosition: {\n          align: \"left\",\n          x: 0,\n          y: 0\n        },\n        labelStyle: {\n          color: \"#666666\"\n        }\n      }\n    });\n    u.lang = r(u.lang, {\n      rangeSelectorZoom: \"Zoom\",\n      rangeSelectorFrom: \"From\",\n      rangeSelectorTo: \"To\"\n    });\n    B.prototype = {\n      clickButton: function clickButton(a, e) {\n        var d = this.chart,\n            f = this.buttonOptions[a],\n            g = d.xAxis[0],\n            c = d.scroller && d.scroller.getUnionExtremes() || g || {},\n            k = c.dataMin,\n            l = c.dataMax,\n            m,\n            h = g && Math.round(Math.min(g.max, b(l, g.max))),\n            q = f.type,\n            r,\n            c = f._range,\n            t,\n            w,\n            u,\n            v = f.dataGrouping;\n\n        if (null !== k && null !== l) {\n          d.fixedRange = c;\n          v && (this.forcedDataGrouping = !0, G.prototype.setDataGrouping.call(g || {\n            chart: this.chart\n          }, v, !1), this.frozenStates = f.preserveDataGrouping);\n          if (\"month\" === q || \"year\" === q) g ? (q = {\n            range: f,\n            max: h,\n            chart: d,\n            dataMin: k,\n            dataMax: l\n          }, m = g.minFromRange.call(q), p(q.newMax) && (h = q.newMax)) : c = f;else if (c) m = Math.max(h - c, k), h = Math.min(m + c, l);else if (\"ytd\" === q) {\n            if (g) void 0 === l && (k = Number.MAX_VALUE, l = Number.MIN_VALUE, d.series.forEach(function (a) {\n              a = a.xData;\n              k = Math.min(a[0], k);\n              l = Math.max(a[a.length - 1], l);\n            }), e = !1), h = this.getYTDExtremes(l, k, d.time.useUTC), m = t = h.min, h = h.max;else {\n              this.deferredYTDClick = a;\n              return;\n            }\n          } else \"all\" === q && g && (m = k, h = l);\n          m += f._offsetMin;\n          h += f._offsetMax;\n          this.setSelected(a);\n          g ? g.setExtremes(m, h, b(e, 1), null, {\n            trigger: \"rangeSelectorButton\",\n            rangeSelectorButton: f\n          }) : (r = n(d.options.xAxis)[0], u = r.range, r.range = c, w = r.min, r.min = t, A(d, \"load\", function () {\n            r.range = u;\n            r.min = w;\n          }));\n        }\n      },\n      setSelected: function setSelected(a) {\n        this.selected = this.options.selected = a;\n      },\n      defaultButtons: [{\n        type: \"month\",\n        count: 1,\n        text: \"1m\"\n      }, {\n        type: \"month\",\n        count: 3,\n        text: \"3m\"\n      }, {\n        type: \"month\",\n        count: 6,\n        text: \"6m\"\n      }, {\n        type: \"ytd\",\n        text: \"YTD\"\n      }, {\n        type: \"year\",\n        count: 1,\n        text: \"1y\"\n      }, {\n        type: \"all\",\n        text: \"All\"\n      }],\n      init: function init(a) {\n        var b = this,\n            d = a.options.rangeSelector,\n            f = d.buttons || [].concat(b.defaultButtons),\n            g = d.selected,\n            c = function c() {\n          var a = b.minInput,\n              c = b.maxInput;\n          a && a.blur && e(a, \"blur\");\n          c && c.blur && e(c, \"blur\");\n        };\n\n        b.chart = a;\n        b.options = d;\n        b.buttons = [];\n        a.extraTopMargin = d.height;\n        b.buttonOptions = f;\n        this.unMouseDown = A(a.container, \"mousedown\", c);\n        this.unResize = A(a, \"resize\", c);\n        f.forEach(b.computeButtonRange);\n        void 0 !== g && f[g] && this.clickButton(g, !1);\n        A(a, \"load\", function () {\n          a.xAxis && a.xAxis[0] && A(a.xAxis[0], \"setExtremes\", function (c) {\n            this.max - this.min !== a.fixedRange && \"rangeSelectorButton\" !== c.trigger && \"updatedData\" !== c.trigger && b.forcedDataGrouping && !b.frozenStates && this.setDataGrouping(!1, !1);\n          });\n        });\n      },\n      updateButtonStates: function updateButtonStates() {\n        var a = this,\n            b = this.chart,\n            e = b.xAxis[0],\n            f = Math.round(e.max - e.min),\n            g = !e.hasVisibleSeries,\n            c = b.scroller && b.scroller.getUnionExtremes() || e,\n            k = c.dataMin,\n            l = c.dataMax,\n            b = a.getYTDExtremes(l, k, b.time.useUTC),\n            m = b.min,\n            h = b.max,\n            n = a.selected,\n            q = p(n),\n            r = a.options.allButtonsEnabled,\n            t = a.buttons;\n        a.buttonOptions.forEach(function (b, c) {\n          var d = b._range,\n              p = b.type,\n              w = b.count || 1,\n              x = t[c],\n              u = 0,\n              v = b._offsetMax - b._offsetMin;\n          b = c === n;\n          var z = d > l - k,\n              y = d < e.minRange,\n              E = !1,\n              C = !1,\n              d = d === f;\n          (\"month\" === p || \"year\" === p) && f + 36E5 >= 864E5 * {\n            month: 28,\n            year: 365\n          }[p] * w - v && f - 36E5 <= 864E5 * {\n            month: 31,\n            year: 366\n          }[p] * w + v ? d = !0 : \"ytd\" === p ? (d = h - m + v === f, E = !b) : \"all\" === p && (d = e.max - e.min >= l - k, C = !b && q && d);\n          p = !r && (z || y || C || g);\n          w = b && d || d && !q && !E || b && a.frozenStates;\n          p ? u = 3 : w && (q = !0, u = 2);\n          x.state !== u && (x.setState(u), 0 === u && n === c && a.setSelected(null));\n        });\n      },\n      computeButtonRange: function computeButtonRange(a) {\n        var d = a.type,\n            e = a.count || 1,\n            f = {\n          millisecond: 1,\n          second: 1E3,\n          minute: 6E4,\n          hour: 36E5,\n          day: 864E5,\n          week: 6048E5\n        };\n        if (f[d]) a._range = f[d] * e;else if (\"month\" === d || \"year\" === d) a._range = 864E5 * {\n          month: 30,\n          year: 365\n        }[d] * e;\n        a._offsetMin = b(a.offsetMin, 0);\n        a._offsetMax = b(a.offsetMax, 0);\n        a._range += a._offsetMax - a._offsetMin;\n      },\n      setInputValue: function setInputValue(a, b) {\n        var d = this.chart.options.rangeSelector,\n            e = this.chart.time,\n            f = this[a + \"Input\"];\n        v(b) && (f.previousValue = f.HCTime, f.HCTime = b);\n        f.value = e.dateFormat(d.inputEditDateFormat || \"%Y-%m-%d\", f.HCTime);\n        this[a + \"DateBox\"].attr({\n          text: e.dateFormat(d.inputDateFormat || \"%b %e, %Y\", f.HCTime)\n        });\n      },\n      showInput: function showInput(a) {\n        var b = this.inputGroup,\n            d = this[a + \"DateBox\"];\n        g(this[a + \"Input\"], {\n          left: b.translateX + d.x + \"px\",\n          top: b.translateY + \"px\",\n          width: d.width - 2 + \"px\",\n          height: d.height - 2 + \"px\",\n          border: \"2px solid silver\"\n        });\n      },\n      hideInput: function hideInput(a) {\n        g(this[a + \"Input\"], {\n          border: 0,\n          width: \"1px\",\n          height: \"1px\"\n        });\n        this.setInputValue(a);\n      },\n      drawInput: function drawInput(b) {\n        function d() {\n          var a = h.value,\n              b = (k.inputDateParser || Date.parse)(a),\n              c = m.xAxis[0],\n              d = m.scroller && m.scroller.xAxis ? m.scroller.xAxis : c,\n              f = d.dataMin,\n              d = d.dataMax;\n          b !== h.previousValue && (h.previousValue = b, p(b) || (b = a.split(\"-\"), b = Date.UTC(l(b[0]), l(b[1]) - 1, l(b[2]))), p(b) && (m.time.useUTC || (b += 6E4 * new Date().getTimezoneOffset()), v ? b > e.maxInput.HCTime ? b = void 0 : b < f && (b = f) : b < e.minInput.HCTime ? b = void 0 : b > d && (b = d), void 0 !== b && c.setExtremes(v ? b : c.min, v ? c.max : b, void 0, void 0, {\n            trigger: \"rangeSelectorInput\"\n          })));\n        }\n\n        var e = this,\n            m = e.chart,\n            n = m.renderer.style || {},\n            c = m.renderer,\n            k = m.options.rangeSelector,\n            q = e.div,\n            v = \"min\" === b,\n            h,\n            z,\n            y = this.inputGroup;\n        this[b + \"Label\"] = z = c.label(u.lang[v ? \"rangeSelectorFrom\" : \"rangeSelectorTo\"], this.inputGroup.offset).addClass(\"highcharts-range-label\").attr({\n          padding: 2\n        }).add(y);\n        y.offset += z.width + 5;\n        this[b + \"DateBox\"] = c = c.label(\"\", y.offset).addClass(\"highcharts-range-input\").attr({\n          padding: 2,\n          width: k.inputBoxWidth || 90,\n          height: k.inputBoxHeight || 17,\n          \"text-align\": \"center\"\n        }).on(\"click\", function () {\n          e.showInput(b);\n          e[b + \"Input\"].focus();\n        });\n        m.styledMode || c.attr({\n          stroke: k.inputBoxBorderColor || \"#cccccc\",\n          \"stroke-width\": 1\n        });\n        c.add(y);\n        y.offset += c.width + (v ? 10 : 0);\n        this[b + \"Input\"] = h = t(\"input\", {\n          name: b,\n          className: \"highcharts-range-selector\",\n          type: \"text\"\n        }, {\n          top: m.plotTop + \"px\"\n        }, q);\n        m.styledMode || (z.css(r(n, k.labelStyle)), c.css(r({\n          color: \"#333333\"\n        }, n, k.inputStyle)), g(h, f({\n          position: \"absolute\",\n          border: 0,\n          width: \"1px\",\n          height: \"1px\",\n          padding: 0,\n          textAlign: \"center\",\n          fontSize: n.fontSize,\n          fontFamily: n.fontFamily,\n          top: \"-9999em\"\n        }, k.inputStyle)));\n\n        h.onfocus = function () {\n          e.showInput(b);\n        };\n\n        h.onblur = function () {\n          h === a.doc.activeElement && (d(), e.hideInput(b));\n        };\n\n        h.onchange = d;\n\n        h.onkeypress = function (a) {\n          13 === a.keyCode && d();\n        };\n      },\n      getPosition: function getPosition() {\n        var a = this.chart,\n            b = a.options.rangeSelector,\n            a = \"top\" === b.verticalAlign ? a.plotTop - a.axisOffset[0] : 0;\n        return {\n          buttonTop: a + b.buttonPosition.y,\n          inputTop: a + b.inputPosition.y - 10\n        };\n      },\n      getYTDExtremes: function getYTDExtremes(a, b, e) {\n        var d = this.chart.time,\n            f = new d.Date(a),\n            c = d.get(\"FullYear\", f);\n        e = e ? d.Date.UTC(c, 0, 1) : +new d.Date(c, 0, 1);\n        b = Math.max(b || 0, e);\n        f = f.getTime();\n        return {\n          max: Math.min(a || f, f),\n          min: b\n        };\n      },\n      render: function render(a, e) {\n        var d = this,\n            f = d.chart,\n            g = f.renderer,\n            c = f.container,\n            k = f.options,\n            l = k.exporting && !1 !== k.exporting.enabled && k.navigation && k.navigation.buttonOptions,\n            m = u.lang,\n            h = d.div,\n            n = k.rangeSelector,\n            p = b(k.chart.style && k.chart.style.zIndex, 0) + 1,\n            k = n.floating,\n            q = d.buttons,\n            h = d.inputGroup,\n            r = n.buttonTheme,\n            w = n.buttonPosition,\n            v = n.inputPosition,\n            y = n.inputEnabled,\n            A = r && r.states,\n            B = f.plotLeft,\n            G,\n            H = d.buttonGroup,\n            P;\n        P = d.rendered;\n        var U = d.options.verticalAlign,\n            ca = f.legend,\n            M = ca && ca.options,\n            V = w.y,\n            N = v.y,\n            Q = P || !1,\n            X = Q ? \"animate\" : \"attr\",\n            ba = 0,\n            Z = 0,\n            Y;\n\n        if (!1 !== n.enabled) {\n          P || (d.group = P = g.g(\"range-selector-group\").attr({\n            zIndex: 7\n          }).add(), d.buttonGroup = H = g.g(\"range-selector-buttons\").add(P), d.zoomText = g.text(m.rangeSelectorZoom, 0, 15).add(H), f.styledMode || (d.zoomText.css(n.labelStyle), r[\"stroke-width\"] = b(r[\"stroke-width\"], 0)), d.buttonOptions.forEach(function (a, b) {\n            q[b] = g.button(a.text, 0, 0, function () {\n              var c = a.events && a.events.click,\n                  e;\n              c && (e = c.call(a));\n              !1 !== e && d.clickButton(b);\n              d.isActive = !0;\n            }, r, A && A.hover, A && A.select, A && A.disabled).attr({\n              \"text-align\": \"center\"\n            }).add(H);\n          }), !1 !== y && (d.div = h = t(\"div\", null, {\n            position: \"relative\",\n            height: 0,\n            zIndex: p\n          }), c.parentNode.insertBefore(h, c), d.inputGroup = h = g.g(\"input-group\").add(P), h.offset = 0, d.drawInput(\"min\"), d.drawInput(\"max\")));\n          d.zoomText[X]({\n            x: b(B + w.x, B)\n          });\n          G = b(B + w.x, B) + d.zoomText.getBBox().width + 5;\n          d.buttonOptions.forEach(function (a, c) {\n            q[c][X]({\n              x: G\n            });\n            G += q[c].width + b(n.buttonSpacing, 5);\n          });\n          B = f.plotLeft - f.spacing[3];\n          d.updateButtonStates();\n          l && this.titleCollision(f) && \"top\" === U && \"right\" === w.align && w.y + H.getBBox().height - 12 < (l.y || 0) + l.height && (ba = -40);\n          \"left\" === w.align ? Y = w.x - f.spacing[3] : \"right\" === w.align && (Y = w.x + ba - f.spacing[1]);\n          H.align({\n            y: w.y,\n            width: H.getBBox().width,\n            align: w.align,\n            x: Y\n          }, !0, f.spacingBox);\n          d.group.placed = Q;\n          d.buttonGroup.placed = Q;\n          !1 !== y && (ba = l && this.titleCollision(f) && \"top\" === U && \"right\" === v.align && v.y - h.getBBox().height - 12 < (l.y || 0) + l.height + f.spacing[0] ? -40 : 0, \"left\" === v.align ? Y = B : \"right\" === v.align && (Y = -Math.max(f.axisOffset[1], -ba)), h.align({\n            y: v.y,\n            width: h.getBBox().width,\n            align: v.align,\n            x: v.x + Y - 2\n          }, !0, f.spacingBox), c = h.alignAttr.translateX + h.alignOptions.x - ba + h.getBBox().x + 2, l = h.alignOptions.width, m = H.alignAttr.translateX + H.getBBox().x, Y = H.getBBox().width + 20, (v.align === w.align || m + Y > c && c + l > m && V < N + h.getBBox().height) && h.attr({\n            translateX: h.alignAttr.translateX + (f.axisOffset[1] >= -ba ? 0 : -ba),\n            translateY: h.alignAttr.translateY + H.getBBox().height + 10\n          }), d.setInputValue(\"min\", a), d.setInputValue(\"max\", e), d.inputGroup.placed = Q);\n          d.group.align({\n            verticalAlign: U\n          }, !0, f.spacingBox);\n          a = d.group.getBBox().height + 20;\n          e = d.group.alignAttr.translateY;\n          \"bottom\" === U && (ca = M && \"bottom\" === M.verticalAlign && M.enabled && !M.floating ? ca.legendHeight + b(M.margin, 10) : 0, a = a + ca - 20, Z = e - a - (k ? 0 : n.y) - 10);\n          if (\"top\" === U) k && (Z = 0), f.titleOffset && (Z = f.titleOffset + f.options.title.margin), Z += f.margin[0] - f.spacing[0] || 0;else if (\"middle\" === U) if (N === V) Z = 0 > N ? e + void 0 : e;else if (N || V) Z = 0 > N || 0 > V ? Z - Math.min(N, V) : e - a + NaN;\n          d.group.translate(n.x, n.y + Math.floor(Z));\n          !1 !== y && (d.minInput.style.marginTop = d.group.translateY + \"px\", d.maxInput.style.marginTop = d.group.translateY + \"px\");\n          d.rendered = !0;\n        }\n      },\n      getHeight: function getHeight() {\n        var a = this.options,\n            b = this.group,\n            e = a.y,\n            f = a.buttonPosition.y,\n            a = a.inputPosition.y,\n            b = b ? b.getBBox(!0).height + 13 + e : 0,\n            e = Math.min(a, f);\n        if (0 > a && 0 > f || 0 < a && 0 < f) b += Math.abs(e);\n        return b;\n      },\n      titleCollision: function titleCollision(a) {\n        return !(a.options.title.text || a.options.subtitle.text);\n      },\n      update: function update(a) {\n        var b = this.chart;\n        r(!0, b.options.rangeSelector, a);\n        this.destroy();\n        this.init(b);\n        b.rangeSelector.render();\n      },\n      destroy: function destroy() {\n        var b = this,\n            e = b.minInput,\n            f = b.maxInput;\n        b.unMouseDown();\n        b.unResize();\n        y(b.buttons);\n        e && (e.onfocus = e.onblur = e.onchange = null);\n        f && (f.onfocus = f.onblur = f.onchange = null);\n        a.objectEach(b, function (a, d) {\n          a && \"chart\" !== d && (a.destroy ? a.destroy() : a.nodeType && q(this[d]));\n          a !== B.prototype[d] && (b[d] = null);\n        }, this);\n      }\n    };\n\n    G.prototype.toFixedRange = function (a, e, f, g) {\n      var d = this.chart && this.chart.fixedRange;\n      a = b(f, this.translate(a, !0, !this.horiz));\n      e = b(g, this.translate(e, !0, !this.horiz));\n      f = d && (e - a) / d;\n      .7 < f && 1.3 > f && (g ? a = e - d : e = a + d);\n      p(a) && p(e) || (a = e = void 0);\n      return {\n        min: a,\n        max: e\n      };\n    };\n\n    G.prototype.minFromRange = function () {\n      var a = this.range,\n          e = {\n        month: \"Month\",\n        year: \"FullYear\"\n      }[a.type],\n          f,\n          g = this.max,\n          l,\n          c,\n          k = function k(a, b) {\n        var c = new Date(a),\n            d = c[\"get\" + e]();\n        c[\"set\" + e](d + b);\n        d === c[\"get\" + e]() && c.setDate(0);\n        return c.getTime() - a;\n      };\n\n      p(a) ? (f = g - a, c = a) : (f = g + k(g, -a.count), this.chart && (this.chart.fixedRange = g - f));\n      l = b(this.dataMin, Number.MIN_VALUE);\n      p(f) || (f = l);\n      f <= l && (f = l, void 0 === c && (c = k(f, a.count)), this.newMax = Math.min(f + c, this.dataMax));\n      p(g) || (f = void 0);\n      return f;\n    };\n\n    A(m, \"afterGetContainer\", function () {\n      this.options.rangeSelector.enabled && (this.rangeSelector = new B(this));\n    });\n    A(m, \"beforeRender\", function () {\n      var a = this.axes,\n          b = this.rangeSelector;\n      b && (p(b.deferredYTDClick) && (b.clickButton(b.deferredYTDClick), delete b.deferredYTDClick), a.forEach(function (a) {\n        a.updateNames();\n        a.setScale();\n      }), this.getAxisMargins(), b.render(), a = b.options.verticalAlign, b.options.floating || (\"bottom\" === a ? this.extraBottomMargin = !0 : \"middle\" !== a && (this.extraTopMargin = !0)));\n    });\n    A(m, \"update\", function (a) {\n      var b = a.options.rangeSelector;\n      a = this.rangeSelector;\n      var d = this.extraBottomMargin,\n          e = this.extraTopMargin;\n      b && b.enabled && !v(a) && (this.options.rangeSelector.enabled = !0, this.rangeSelector = new B(this));\n      this.extraTopMargin = this.extraBottomMargin = !1;\n      a && (a.render(), b = b && b.verticalAlign || a.options && a.options.verticalAlign, a.options.floating || (\"bottom\" === b ? this.extraBottomMargin = !0 : \"middle\" !== b && (this.extraTopMargin = !0)), this.extraBottomMargin !== d || this.extraTopMargin !== e) && (this.isDirtyBox = !0);\n    });\n    A(m, \"render\", function () {\n      var a = this.rangeSelector;\n      a && !a.options.floating && (a.render(), a = a.options.verticalAlign, \"bottom\" === a ? this.extraBottomMargin = !0 : \"middle\" !== a && (this.extraTopMargin = !0));\n    });\n    A(m, \"getMargins\", function () {\n      var a = this.rangeSelector;\n      a && (a = a.getHeight(), this.extraTopMargin && (this.plotTop += a), this.extraBottomMargin && (this.marginBottom += a));\n    });\n    m.prototype.callbacks.push(function (a) {\n      function b() {\n        d = a.xAxis[0].getExtremes();\n        p(d.min) && e.render(d.min, d.max);\n      }\n\n      var d,\n          e = a.rangeSelector,\n          f,\n          c;\n      e && (c = A(a.xAxis[0], \"afterSetExtremes\", function (a) {\n        e.render(a.min, a.max);\n      }), f = A(a, \"redraw\", b), b());\n      A(a, \"destroy\", function () {\n        e && (f(), c());\n      });\n    });\n    a.RangeSelector = B;\n  })(H);\n\n  (function (a) {\n    var B = a.addEvent,\n        A = a.arrayMax,\n        G = a.arrayMin,\n        m = a.Axis,\n        g = a.Chart,\n        t = a.defined,\n        u = a.extend,\n        v = a.format,\n        y = a.isNumber,\n        q = a.isString,\n        f = a.merge,\n        e = a.pick,\n        p = a.Point,\n        r = a.Renderer,\n        b = a.Series,\n        l = a.splat,\n        n = a.SVGRenderer,\n        d = a.VMLRenderer,\n        w = b.prototype,\n        E = w.init,\n        C = w.processData,\n        F = p.prototype.tooltipFormatter;\n\n    a.StockChart = a.stockChart = function (b, d, m) {\n      var c = q(b) || b.nodeName,\n          h = arguments[c ? 1 : 0],\n          k = h,\n          n = h.series,\n          p = a.getOptions(),\n          r,\n          t = e(h.navigator && h.navigator.enabled, p.navigator.enabled, !0),\n          u = t ? {\n        startOnTick: !1,\n        endOnTick: !1\n      } : null,\n          x = {\n        marker: {\n          enabled: !1,\n          radius: 2\n        }\n      },\n          v = {\n        shadow: !1,\n        borderWidth: 0\n      };\n      h.xAxis = l(h.xAxis || {}).map(function (a, b) {\n        return f({\n          minPadding: 0,\n          maxPadding: 0,\n          overscroll: 0,\n          ordinal: !0,\n          title: {\n            text: null\n          },\n          labels: {\n            overflow: \"justify\"\n          },\n          showLastLabel: !0\n        }, p.xAxis, p.xAxis && p.xAxis[b], a, {\n          type: \"datetime\",\n          categories: null\n        }, u);\n      });\n      h.yAxis = l(h.yAxis || {}).map(function (a, b) {\n        r = e(a.opposite, !0);\n        return f({\n          labels: {\n            y: -2\n          },\n          opposite: r,\n          showLastLabel: !(!a.categories && \"category\" !== a.type),\n          title: {\n            text: null\n          }\n        }, p.yAxis, p.yAxis && p.yAxis[b], a);\n      });\n      h.series = null;\n      h = f({\n        chart: {\n          panning: !0,\n          pinchType: \"x\"\n        },\n        navigator: {\n          enabled: t\n        },\n        scrollbar: {\n          enabled: e(p.scrollbar.enabled, !0)\n        },\n        rangeSelector: {\n          enabled: e(p.rangeSelector.enabled, !0)\n        },\n        title: {\n          text: null\n        },\n        tooltip: {\n          split: e(p.tooltip.split, !0),\n          crosshairs: !0\n        },\n        legend: {\n          enabled: !1\n        },\n        plotOptions: {\n          line: x,\n          spline: x,\n          area: x,\n          areaspline: x,\n          arearange: x,\n          areasplinerange: x,\n          column: v,\n          columnrange: v,\n          candlestick: v,\n          ohlc: v\n        }\n      }, h, {\n        isStock: !0\n      });\n      h.series = k.series = n;\n      return c ? new g(b, h, m) : new g(h, d);\n    };\n\n    B(m, \"autoLabelAlign\", function (a) {\n      var b = this.chart,\n          c = this.options,\n          b = b._labelPanes = b._labelPanes || {},\n          d = this.options.labels;\n      this.chart.options.isStock && \"yAxis\" === this.coll && (c = c.top + \",\" + c.height, !b[c] && d.enabled && (15 === d.x && (d.x = 0), void 0 === d.align && (d.align = \"right\"), b[c] = this, a.align = \"right\", a.preventDefault()));\n    });\n    B(m, \"destroy\", function () {\n      var a = this.chart,\n          b = this.options && this.options.top + \",\" + this.options.height;\n      b && a._labelPanes && a._labelPanes[b] === this && delete a._labelPanes[b];\n    });\n    B(m, \"getPlotLinePath\", function (b) {\n      function c(a) {\n        var b = \"xAxis\" === a ? \"yAxis\" : \"xAxis\";\n        a = d.options[b];\n        return y(a) ? [g[b][a]] : q(a) ? [g.get(a)] : f.map(function (a) {\n          return a[b];\n        });\n      }\n\n      var d = this,\n          f = this.isLinked && !this.series ? this.linkedParent.series : this.series,\n          g = d.chart,\n          l = g.renderer,\n          m = d.left,\n          n = d.top,\n          p,\n          r,\n          u,\n          v,\n          w = [],\n          A = [],\n          B,\n          C,\n          E = b.translatedValue,\n          G = b.value,\n          F = b.force,\n          H;\n      if (\"xAxis\" === d.coll || \"yAxis\" === d.coll) b.preventDefault(), A = c(d.coll), B = d.isXAxis ? g.yAxis : g.xAxis, B.forEach(function (a) {\n        if (t(a.options.id) ? -1 === a.options.id.indexOf(\"navigator\") : 1) {\n          var b = a.isXAxis ? \"yAxis\" : \"xAxis\",\n              b = t(a.options[b]) ? g[b][a.options[b]] : g[b][0];\n          d === b && A.push(a);\n        }\n      }), C = A.length ? [] : [d.isXAxis ? g.yAxis[0] : g.xAxis[0]], A.forEach(function (b) {\n        -1 !== C.indexOf(b) || a.find(C, function (a) {\n          return a.pos === b.pos && a.len === b.len;\n        }) || C.push(b);\n      }), H = e(E, d.translate(G, null, null, b.old)), y(H) && (d.horiz ? C.forEach(function (a) {\n        var b;\n        r = a.pos;\n        v = r + a.len;\n        p = u = Math.round(H + d.transB);\n        \"pass\" !== F && (p < m || p > m + d.width) && (F ? p = u = Math.min(Math.max(m, p), m + d.width) : b = !0);\n        b || w.push(\"M\", p, r, \"L\", u, v);\n      }) : C.forEach(function (a) {\n        var b;\n        p = a.pos;\n        u = p + a.len;\n        r = v = Math.round(n + d.height - H);\n        \"pass\" !== F && (r < n || r > n + d.height) && (F ? r = v = Math.min(Math.max(n, r), d.top + d.height) : b = !0);\n        b || w.push(\"M\", p, r, \"L\", u, v);\n      })), b.path = 0 < w.length ? l.crispPolyLine(w, b.lineWidth || 1) : null;\n    });\n\n    n.prototype.crispPolyLine = function (a, b) {\n      var c;\n\n      for (c = 0; c < a.length; c += 6) {\n        a[c + 1] === a[c + 4] && (a[c + 1] = a[c + 4] = Math.round(a[c + 1]) - b % 2 / 2), a[c + 2] === a[c + 5] && (a[c + 2] = a[c + 5] = Math.round(a[c + 2]) + b % 2 / 2);\n      }\n\n      return a;\n    };\n\n    r === d && (d.prototype.crispPolyLine = n.prototype.crispPolyLine);\n    B(m, \"afterHideCrosshair\", function () {\n      this.crossLabel && (this.crossLabel = this.crossLabel.hide());\n    });\n    B(m, \"afterDrawCrosshair\", function (a) {\n      var b, c;\n\n      if (t(this.crosshair.label) && this.crosshair.label.enabled && this.cross) {\n        var d = this.chart,\n            f = this.options.crosshair.label,\n            g = this.horiz;\n        b = this.opposite;\n        c = this.left;\n        var l = this.top,\n            m = this.crossLabel,\n            n = f.format,\n            p = \"\",\n            q = \"inside\" === this.options.tickPosition,\n            r = !1 !== this.crosshair.snap,\n            w = 0,\n            y = a.e || this.cross && this.cross.e,\n            A = a.point;\n        a = this.lin2log;\n        var B, C;\n        this.isLog ? (B = a(this.min), C = a(this.max)) : (B = this.min, C = this.max);\n        a = g ? \"center\" : b ? \"right\" === this.labelAlign ? \"right\" : \"left\" : \"left\" === this.labelAlign ? \"left\" : \"center\";\n        m || (m = this.crossLabel = d.renderer.label(null, null, null, f.shape || \"callout\").addClass(\"highcharts-crosshair-label\" + (this.series[0] && \" highcharts-color-\" + this.series[0].colorIndex)).attr({\n          align: f.align || a,\n          padding: e(f.padding, 8),\n          r: e(f.borderRadius, 3),\n          zIndex: 2\n        }).add(this.labelGroup), d.styledMode || m.attr({\n          fill: f.backgroundColor || this.series[0] && this.series[0].color || \"#666666\",\n          stroke: f.borderColor || \"\",\n          \"stroke-width\": f.borderWidth || 0\n        }).css(u({\n          color: \"#ffffff\",\n          fontWeight: \"normal\",\n          fontSize: \"11px\",\n          textAlign: \"center\"\n        }, f.style)));\n        g ? (a = r ? A.plotX + c : y.chartX, l += b ? 0 : this.height) : (a = b ? this.width + c : 0, l = r ? A.plotY + l : y.chartY);\n        n || f.formatter || (this.isDatetimeAxis && (p = \"%b %d, %Y\"), n = \"{value\" + (p ? \":\" + p : \"\") + \"}\");\n        p = r ? A[this.isXAxis ? \"x\" : \"y\"] : this.toValue(g ? y.chartX : y.chartY);\n        m.attr({\n          text: n ? v(n, {\n            value: p\n          }, d.time) : f.formatter.call(this, p),\n          x: a,\n          y: l,\n          visibility: p < B || p > C ? \"hidden\" : \"visible\"\n        });\n        f = m.getBBox();\n\n        if (g) {\n          if (q && !b || !q && b) l = m.y - f.height;\n        } else l = m.y - f.height / 2;\n\n        g ? (b = c - f.x, c = c + this.width - f.x) : (b = \"left\" === this.labelAlign ? c : 0, c = \"right\" === this.labelAlign ? c + this.width : d.chartWidth);\n        m.translateX < b && (w = b - m.translateX);\n        m.translateX + f.width >= c && (w = -(m.translateX + f.width - c));\n        m.attr({\n          x: a + w,\n          y: l,\n          anchorX: g ? a : this.opposite ? 0 : d.chartWidth,\n          anchorY: g ? this.opposite ? d.chartHeight : 0 : l + f.height / 2\n        });\n      }\n    });\n\n    w.init = function () {\n      E.apply(this, arguments);\n      this.setCompare(this.options.compare);\n    };\n\n    w.setCompare = function (a) {\n      this.modifyValue = \"value\" === a || \"percent\" === a ? function (b, c) {\n        var d = this.compareValue;\n        if (void 0 !== b && void 0 !== d) return b = \"value\" === a ? b - d : b / d * 100 - (100 === this.options.compareBase ? 0 : 100), c && (c.change = b), b;\n      } : null;\n      this.userOptions.compare = a;\n      this.chart.hasRendered && (this.isDirty = !0);\n    };\n\n    w.processData = function () {\n      var a,\n          b = -1,\n          d,\n          e,\n          f = !0 === this.options.compareStart ? 0 : 1,\n          g,\n          l;\n      C.apply(this, arguments);\n      if (this.xAxis && this.processedYData) for (d = this.processedXData, e = this.processedYData, g = e.length, this.pointArrayMap && (b = this.pointArrayMap.indexOf(this.options.pointValKey || this.pointValKey || \"y\")), a = 0; a < g - f; a++) {\n        if (l = e[a] && -1 < b ? e[a][b] : e[a], y(l) && d[a + f] >= this.xAxis.min && 0 !== l) {\n          this.compareValue = l;\n          break;\n        }\n      }\n    };\n\n    B(b, \"afterGetExtremes\", function () {\n      if (this.modifyValue) {\n        var a = [this.modifyValue(this.dataMin), this.modifyValue(this.dataMax)];\n        this.dataMin = G(a);\n        this.dataMax = A(a);\n      }\n    });\n\n    m.prototype.setCompare = function (a, b) {\n      this.isXAxis || (this.series.forEach(function (b) {\n        b.setCompare(a);\n      }), e(b, !0) && this.chart.redraw());\n    };\n\n    p.prototype.tooltipFormatter = function (b) {\n      b = b.replace(\"{point.change}\", (0 < this.change ? \"+\" : \"\") + a.numberFormat(this.change, e(this.series.tooltipOptions.changeDecimals, 2)));\n      return F.apply(this, [b]);\n    };\n\n    B(b, \"render\", function () {\n      var a;\n      this.chart.is3d && this.chart.is3d() || this.chart.polar || !this.xAxis || this.xAxis.isRadial || (a = this.yAxis.len - (this.xAxis.axisLine ? Math.floor(this.xAxis.axisLine.strokeWidth() / 2) : 0), !this.clipBox && this.animate ? (this.clipBox = f(this.chart.clipBox), this.clipBox.width = this.xAxis.len, this.clipBox.height = a) : this.chart[this.sharedClipKey] && (this.chart[this.sharedClipKey].animate({\n        width: this.xAxis.len,\n        height: a\n      }), this.chart[this.sharedClipKey + \"m\"] && this.chart[this.sharedClipKey + \"m\"].animate({\n        width: this.xAxis.len\n      })));\n    });\n    B(g, \"update\", function (a) {\n      a = a.options;\n      \"scrollbar\" in a && this.navigator && (f(!0, this.options.scrollbar, a.scrollbar), this.navigator.update({}, !1), delete a.scrollbar);\n    });\n  })(H);\n\n  return H;\n});","map":null,"metadata":{},"sourceType":"script"}